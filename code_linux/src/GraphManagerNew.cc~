#include<iostream>
#include<string>
#include<fstream>
#include<sstream>
#include<queue>
#include<algorithm>
#include<iomanip> // for setprecision
#include<limits>
#include<unordered_map>
#include<stack>
#include <cmath>

#include "../include/GraphManagerNew.h"
#include "../include/XMLParser.h"
#include "../include/ModifiedExpressionManager.h"
#include "../include/macros.h"
#include "../include/rules_parser_datatypes.h"
#include "../include/rules_parser.tab.h"
#include "../include/rule_tuple_store.h"

#include "z3++.h"

// test comment
SMT_solver convert(string str) {
    if (str == "z3") return Z3;
    else if (str == "cvc4") return CVC4;
    else if (str == "boolector") return BOOLECTOR;
}

const string palette_table[] = {
    "#581845",
    "#900C3F",
    "#C70039",
    "#FF5733",
    "#FFC300",
    "#00FFFF",
    "#004FFF",
    "#4A00FF",
    "#FF0000",
    "#FF9933"

};


int GraphManagerNew::graph_id_count = 0;
//int GraphManagerNew::node_id_count = 0;
//int GraphManagerNew::edge_id_count = 0;
int NodeNew::node_id_counter = 0;
int EdgeNew::edge_id_counter = 0;

extern ofstream debug_log;
extern std::string concatenate_strings(std::vector<std::string> vec_strings, std::string delim);
extern std::string concatenate_strings2(std::vector<std::string> vec_strings, std::string delim);
extern void split_string_into_list(string name_str, string delim, list<string>& list_of_strings);
extern bool compare_pair_on_second_descending(const pair<int, int>&i, const pair<int, int>&j);
extern bool compare_pair_on_second_ascending(const pair<int, int>&i, const pair<int, int>&j);
extern bool compare_pair_on_second_descending_string_to_int(const pair<string, int>&i, const pair<string, int>&j);
extern bool compare_pair_on_second_descending_int_double(const pair<int, double>&i, const pair<int, double>&j);

extern z3::expr_vector all_z3_var_to_expr_map;

extern string FloatToString(float num);

NodeNew::NodeNew() {
    node_id = ++node_id_counter;
}

inline int NodeNew::get_node_id() {
    return node_id;
}

inline void NodeNew::set_rep_id(std::string repid) {
    rep_id = repid;
}

inline std::string NodeNew::get_rep_id() {
    return rep_id;
}

inline std::vector<std::string> NodeNew::get_all_id() {
    return all_id;
}

inline void NodeNew::set_all_id(std::vector<std::string> all_ids) {
    all_id = all_ids;
}

inline void NodeNew::add_to_all_id(std::string id) {
    all_id.push_back(id);
}

inline std::vector<int> NodeNew::get_comp_ids() {
    return components;
}

inline void NodeNew::add_comp_id(int id) {
    components.push_back(id);
}

inline void NodeNew::update_component_id_at_index(int pos, int value) {
    components[pos] = value;
}

inline void NodeNew::set_all_display_names(std::vector<std::string> all_disp_names) {
    display_names = all_disp_names;
}

inline std::vector<std::string> NodeNew::get_disp_ids() {
    return display_names;
}

inline void NodeNew::add_disp_id(std::string id) {
    display_names.push_back(id);
}

inline std::string NodeNew::get_node_type() {
    return node_type;
}

inline void NodeNew::add_node_type(std::string type) {
    node_type = type;
}

inline void NodeNew::remove_node_type() {
    node_type = "";
}

inline std::vector<int> NodeNew::get_inlist() {
    return inlist;
}

inline void NodeNew::add_to_inlist(int eid) {
    inlist.push_back(eid);
}

inline void NodeNew::remove_from_inlist(int eid) {
    vector<int>::iterator itr = find(inlist.begin(), inlist.end(), eid);
    if (itr == inlist.end()) {
        cerr << "Error: edge with id " << eid << "is not in the inlist" << endl;
    } else {
        inlist.erase(itr);
    }
}

inline std::vector<int> NodeNew::get_outlist() {
    return outlist;
}

inline void NodeNew::add_to_outlist(int eid) {
    outlist.push_back(eid);
}

inline void NodeNew::remove_from_outlist(int eid) {
    vector<int>::iterator itr = find(outlist.begin(), outlist.end(), eid);
    if (itr == outlist.end()) {
        cerr << "Error: edge with id " << eid << "is not in the outlist" << endl;
    } else {
        outlist.erase(itr);
    }
}

inline int NodeNew::get_in_degree() {
    return inlist.size();
}

inline int NodeNew::get_out_degree() {
    return outlist.size();
}

bool NodeNew::is_target_of_GErel_edge(GraphNew* graph) {
    for (vector<int>::iterator inlist_itr = inlist.begin(); inlist_itr != inlist.end(); ++inlist_itr) {
        EdgeNew* edge = graph->get_edge_from_eid(*inlist_itr);
        if (edge) {
            if (edge->get_edge_type() == "GErel" && (edge->has_subtype("expression") || edge->has_subtype("repression"))) {
                return true;
            }
        } else {
            cerr << "Error: doesn't seem to be the right graph" << endl;
        }
    }
    return false;
}

inline void NodeNew::add_description_for_node(std::string desc) {
    description = desc;
}

inline std::string NodeNew::get_description_for_node() {
    return description;
}

inline void NodeNew::add_compartment_for_node(std::string comp) {
    compartment = comp;
}

inline std::string NodeNew::get_compartment_for_node() {
    return compartment;
}

inline void NodeNew::add_other_value1(int value) {
    other_value1 = value;
}

inline int NodeNew::get_other_value1() {
    return other_value1;
}

inline void NodeNew::set_node_excess(float value) {
    excess = value;
}

inline float NodeNew::get_node_excess() {
    return excess;
}

EdgeNew::EdgeNew() {
    edge_id = ++edge_id_counter;
    
    weight_tuple.push_back(0);
    weight_tuple.push_back(0);
    weight_tuple.push_back(0);
    weight_tuple.push_back(0);
}

inline int EdgeNew::get_edge_id() {
    return edge_id;
}

inline std::string EdgeNew::get_edge_type() {
    return edge_type;
}

inline void EdgeNew::add_edge_type(std::string type) {
    edge_type = type;
}

inline void EdgeNew::remove_edge_type() {
    edge_type = "";
}

inline std::vector<std::string> EdgeNew::get_edge_subtypes() {
    return edge_subtypes;
}

inline void EdgeNew::add_subtype(std::string subtype) {
    edge_subtypes.push_back(subtype);
}

inline std::vector<std::string> EdgeNew::get_pathways() {
    return edge_belongs_to_pathways;
}

inline void EdgeNew::add_pathway(std::string pathway) {
    edge_belongs_to_pathways.push_back(pathway);
}

inline void EdgeNew::add_source(int nid) {
    edge_source = nid;
}

inline int EdgeNew::get_source() {
    return edge_source;
}

inline void EdgeNew::add_target(int nid) {
    edge_target = nid;
}

inline int EdgeNew::get_target() {
    return edge_target;
}

inline bool EdgeNew::has_subtype(std::string subtype) {
    for (vector<string>::iterator subt_itr = edge_subtypes.begin(); subt_itr != edge_subtypes.end(); subt_itr++) {
        if (*subt_itr == subtype) {
            return true;
        }
    }
    return false;
}

inline void EdgeNew::add_reaction_desc(std::string desc) {
    reaction_desc = desc;
}

inline std::string EdgeNew::get_reaction_desc() {
    return reaction_desc;
}

inline void EdgeNew::add_other_values(int value) {
    other.push_back(value);
}

inline std::vector<int> EdgeNew::get_other_values() {
    return other;
}

inline void EdgeNew::set_other_value1(int value) {
    other1 = value;
}

inline int EdgeNew::get_other_value1() {
    return other1;
}

inline void EdgeNew::set_other_value2(int value) {
    other2 = value;
}

inline int EdgeNew::get_other_value2() {
    return other2;
}

inline void EdgeNew::set_other_value3(int value) {
    other3 = value;
}

inline int EdgeNew::get_other_value3() {
    return other3;
}

inline void EdgeNew::set_other_value4(int value) {
    other4 = value;
}

inline int EdgeNew::get_other_value4() {
    return other4;
}

inline void EdgeNew::set_edge_deleted_status(bool status){ //added by anjan 21 mar 2017
	deleted = status;
}

inline bool EdgeNew::get_edge_deleted_status(){//added by anjan 21 mar 2017
	return deleted;
}

inline void EdgeNew::set_edge_weight(int wt) {
    weight = wt;
}

inline void EdgeNew::set_edge_weight_float(float wt) {
    weight_f = wt;
}
        
inline int EdgeNew::get_edge_weight() {
    return weight;
}

inline float EdgeNew::get_edge_weight_float() {
    return weight_f;
}

inline void EdgeNew::add_to_weight_tuple(float weight) {
    weight_tuple.push_back(weight);
}
        
void EdgeNew::set_weight_factor_at_tuple_index(int index, float value) {
    if (index < weight_tuple.size())
        weight_tuple[index] = value;
    else {
        cout << "Invalid tuple index " << index << endl;
        weight_tuple[index] = -1;
    }
}

float EdgeNew::get_weight_factor_at_tuple_index(int index) {
    if (index < weight_tuple.size())
        return weight_tuple.at(index);
    else {
        cout << "Unassigned tuple index " << index << endl;
        return -1;
    }
}

inline void EdgeNew::set_weight_tuple(vector<float> tuple) {
    weight_tuple = tuple;
}

inline std::vector<float> EdgeNew::get_weight_tuple() {
    return weight_tuple;
}

inline void EdgeNew::set_edge_capacity(float value) {
    capacity = value;
}
inline float EdgeNew::get_edge_capacity() {
    return capacity;
}
inline void EdgeNew::set_edge_flow(float value) {
    flow = value;
}
inline float EdgeNew::get_edge_flow() {
    return flow;
}      

//these functions and vars needed for Expression Manager and CNF
extern int idx;
extern int clauses;
extern map<string, t_Expression *> getExpressionMap;
extern map<t_Expression*, pair<string, int> > getCNFIndexMap;

extern vector<int> add_cnf(vector<int> u, vector<int> v, int& idx, int & clauses, ofstream& fout);
extern string buildRelationalExpression(string reader, t_ExpressionManager* em, t_Expression* &expr);
extern string buildArithmaticExpression(string reader, t_ExpressionManager* em, t_Expression* &expr);
extern string buildSelectExpression(string reader, t_ExpressionManager* em, t_Expression* &expr);
extern string buildConcatExpression(string reader, t_ExpressionManager *em, t_Expression* &expr);
extern string buildBracketExpression(string reader, t_ExpressionManager *em, t_Expression* &expr);
extern string buildVariableExpression(string reader, t_ExpressionManager *em, t_Expression* &expr);

extern t_Expression* build_OR_constraints(string s1, string s2, int a1, int a2, t_ExpressionManager *em);
extern t_Expression* build_AND_constraints(string s1, string s2, int a1, int a2, t_ExpressionManager *em);
extern t_Expression* build_OR_constraints(t_Expression* e1, t_Expression* e2, int a1, int a2, t_ExpressionManager *em);
extern t_Expression* build_AND_constraints(t_Expression* e1, t_Expression* e2, int a1, int a2, t_ExpressionManager *em);

extern t_Expression* build_AND_constraints_from_vector(vector<t_Expression*>& vec, t_ExpressionManager *em);
extern t_Expression* build_OR_constraints_from_vector(vector<t_Expression*>& vec, t_ExpressionManager *em);
extern t_Expression* get_expression_sequence_positive_constraint(vector<t_Expression*>& nid_dist_variable_seq, t_ExpressionManager *em);
t_Expression* build_XOR_constraints(t_Expression* a, t_Expression* b, t_ExpressionManager *em);
t_Expression* build_EQUIV_constraint(t_Expression* a, t_Expression* b, t_ExpressionManager *em);


extern string IntToString(int num);

GraphNew::GraphNew() {

}

GraphNew::~GraphNew() {

}

template<typename Data>
void GraphNew::print_vector(std::vector<Data>& vec, ofstream& fout) {
    for (typename std::vector<Data>::iterator itr = vec.begin(); itr != vec.end(); ++itr) {
        fout << *itr << "" << endl;
    }
    fout << endl;
}

template<typename Data>
void GraphNew::print_set(std::set<Data>& vec, ofstream& fout) {
    for (typename std::set<Data>::iterator itr = vec.begin(); itr != vec.end(); ++itr) {
        fout << *itr << " ";
    }
    fout << endl;
}

template<typename Key, typename Val>
void GraphNew::add_to_map(std::map<Key, Val>& generic_map, Key k, Val v) {
    generic_map.insert(pair<Key, Val>(k, v));
}

template<typename Key, typename Val>
void GraphNew::delete_from_map(std::map<Key, Val>& generic_map, Key k) {
    generic_map.erase(k);
}

template<typename Key, typename Val>
void GraphNew::print_map(std::map<Key, Val>& generic_map, ofstream& fout) {
    for (typename map<Key, Val>::iterator itr = generic_map.begin(); itr != generic_map.end(); ++itr) {
        fout << itr->first << " ==> " << itr->second << endl;
    }
    fout << endl;
}

template<typename Key, typename Val>
void GraphNew::add_to_map2(std::map<Key, std::vector<Val> >& generic_map, Key k, Val v) {
    typename std::map<Key, std::vector<Val> >::iterator itr = generic_map.find(k);
    if (itr == generic_map.end()) {
        std::vector<Val> temp;
        temp.push_back(v);
        generic_map.insert(pair<Key, std::vector<Val> >(k, temp));
    } else {
        itr->second.push_back(v);
    }
}

template<typename Key, typename Val>
std::vector<Val> GraphNew::get_val_map2(std::map<Key, std::vector<Val> >& generic_map, Key k) {
    std::vector<Val> empty_vec;
    typename std::map<Key, std::vector<Val> >::iterator itr = generic_map.find(k);
    if (itr == generic_map.end()) {
        return empty_vec;
    } else {
        return itr->second;
    }
}

template<typename Key, typename Val>
void GraphNew::delete_from_map2(std::map<Key, std::vector<Val> >& generic_map, Key k) {
    generic_map.erase(k);
}

template<typename Key, typename Val>
void GraphNew::print_map2(std::map<Key, std::vector<Val> >& generic_map, ofstream& fout) {
    for (typename map<Key, std::vector<Val> >::iterator itr = generic_map.begin(); itr != generic_map.end(); ++itr) {
        fout << itr->first << " ==> ";
        print_vector(itr->second, fout);
    }
    fout << endl;
}

template<typename Key, typename Val>
bool GraphNew::map_has_key_with_val(std::map<Key, std::vector<Val> >& generic_map, Key k, Val v) {
    typename std::map<Key, std::vector<Val> >::iterator itr = generic_map.find(k);
    if (itr == generic_map.end()) {
        return false;
    } else {
        typename std::vector<Val>::iterator itr_vec = find(itr->second.begin(), itr->second.end(), v);
        if (itr_vec == itr->second.end())
            return false;
    }
    return true;
}

inline int GraphNew::check_if_node_already_created(std::string rep_id) {
    return get_nid_from_rep_id(rep_id);
}

int GraphNew::create_new_node() {

    try {
        NodeNew * new_node = new NodeNew();
        int new_node_id = new_node->get_node_id();
        add_nid_node(new_node_id, new_node);
        return new_node_id;
    } catch (std::bad_alloc &e) {
        cerr << "new failed in GraphNew::create_new_node()" << endl;
        return -1;
    }

    return -1;
}

//inline NodeNew * GraphNew::get_node_from_nid(int nid) {
//    std::unordered_map<int, NodeNew *>::iterator itr = nid_to_node_map.find(nid);
//    if (itr == nid_to_node_map.end()) {
//        cerr << "1. Not found node with id " << nid << endl;
//        return NULL;
//    } else {
//        NodeNew * node = (*itr).second;
//        return node;
//    }
//}

inline NodeNew * GraphNew::get_node_from_nid(int nid) {
    std::unordered_map<int, NodeNew *>::iterator itr = nid_to_node_map.find(nid);
    if (itr == nid_to_node_map.end())
        return NULL;
    return (*itr).second;


}

/* HIGHLY INEFFICIENT CODE: Supratik Aug 24, 2015  NEED TO CHANGE */
int GraphNew::check_if_edge_already_created(int new_source_nid, int new_target_nid, std::string edge_type, std::vector<std::string> edge_subtypes) {

    std::vector<int> all_outlist_eids = get_outlist(new_source_nid);
    std::vector<int>::iterator list_itr;

    // for each edge in outlist of source node
    for (list_itr = all_outlist_eids.begin(); list_itr != all_outlist_eids.end(); list_itr++) {
        int id = *list_itr;

        if (get_target_node(id) == new_target_nid && get_edge_type(id) == edge_type && get_edge_subtypes_of_edge(id) == edge_subtypes) {
            return id;
        }
    }
    return -1;
}

int GraphNew::create_new_edge() {

    try {
        EdgeNew * new_edge = new EdgeNew();
        int new_edge_id = new_edge->get_edge_id();
        add_eid_edge(new_edge_id, new_edge);
        return new_edge_id;
    } catch (std::bad_alloc &e) {
        cerr << "new failed in GraphNew::create_new_edge()" << endl;
        return -1;
    }

    return -1;
}

void GraphNew::fill_maps_for_new_edge(int new_eid, int new_source_nid, int new_target_nid, string edge_type, vector<string> edge_subtypes, vector<string> edge_belongs_to_pathways) {

    add_edge_id(new_eid);

    // add edge info on new edge
    add_source_node(new_eid, new_source_nid);
    add_target_node(new_eid, new_target_nid);
    add_edge_type(new_eid, edge_type);
    std::vector<std::string>::iterator itr;
    for (itr = edge_subtypes.begin(); itr != edge_subtypes.end(); itr++) {
        add_subtype_for_edge(new_eid, (*itr));
    }
    for (itr = edge_belongs_to_pathways.begin(); itr != edge_belongs_to_pathways.end(); itr++) {
        add_pathway_for_edge(new_eid, (*itr));
    }

    //insert new edge in outlist of source and inlist of target nodes
    add_edge_to_outlist_of_node(new_source_nid, new_eid);
    add_edge_to_inlist_of_node(new_target_nid, new_eid);

}

inline EdgeNew * GraphNew::get_edge_from_eid(int eid) {
    std::unordered_map<int, EdgeNew *>::iterator itr = eid_to_edge_map.find(eid);
    if (itr == eid_to_edge_map.end())
        return NULL;
    return (*itr).second;
}

inline void GraphNew::add_nid_node(int nid, NodeNew * node) {
    nid_to_node_map.insert(pair<int, NodeNew *>(nid, node));
}

inline void GraphNew::add_eid_edge(int eid, EdgeNew * edge) {
    eid_to_edge_map.insert(pair<int, EdgeNew *>(eid, edge));
}

inline int GraphNew::get_graph_id() {
    return graph_id;
}

inline void GraphNew::set_graph_id(int gid) {
    graph_id = gid;
}

inline void GraphNew::set_first_offset(int offset) {
    first_offset = offset;
}

inline int GraphNew::get_first_offset() {
    return first_offset;
}

inline void GraphNew::add_node_id(int nid) {
    NIDSg.push_back(nid);
}

inline void GraphNew::add_edge_id(int eid) {
    EIDSg.push_back(eid);
}

inline std::vector<int> GraphNew::get_node_ids() {
    return NIDSg;
}

inline std::vector<int> GraphNew::get_edge_ids() {
    return EIDSg;
}

inline std::string GraphNew::get_rep_id_from_id(std::string id) {
    std::map<std::string, std::string>::iterator itr = id_to_rep_id_map.find(id);
    if (itr != id_to_rep_id_map.end()) {
        return itr->second;
    } else {
        return "";
    }
}
//std::string GraphNew::get_rep_id_from_id(std::string id) {
//        std::string rep_id = "";
//        std::map<int, NodeNew *>::iterator itr;
//        for (itr = nid_to_node_map.begin(); itr != nid_to_node_map.end(); itr++) {
//            std::vector<std::string> all_id = (*itr).second->get_all_id();
//            std::vector<std::string>::iterator itr1 = std::find(all_id.begin(), all_id.end(), id);
//            if (itr1 == all_id.end()) {
//                //cerr << "Not found node with id " << id << endl;
//            }
//            else {
//                NodeNew * node = (*itr).second;
//                rep_id = node->get_rep_id();
//            }
//        }
//        return rep_id;
//}

//std::string GraphNew::get_rep_id_from_nid(int nid) {
//    std::map<int, std::vector<std::string> > ::iterator itr = node_id_to_all_id_map.find(nid);
//    if (itr != node_id_to_all_id_map.end()) {
//    	assert(!((itr->second).empty()));
//        std::string temp = itr->second[0];// get first id corresponding to nid
//        std::string rid = get_rep_id_from_id(temp);
//        assert(rid != "");
//        return rid;
//    }
//    else {
//        return "";
//    }
//}

inline std::string GraphNew::get_rep_id_from_nid(int nid) {
    std::string rep_id = "";
    std::unordered_map<int, NodeNew *>::iterator itr = nid_to_node_map.find(nid);
    if (itr != nid_to_node_map.end()) {
        rep_id = (*itr).second->get_rep_id();
    }
    return rep_id;
}


//int GraphNew::get_nid_from_rep_id(std::string repid) {
//    std::map<int, std::vector<std::string> >::iterator itr;
//    vector<string> all_id_for_repid = get_all_ids_for_rep_id(repid);
//    if(all_id_for_repid.empty()){
//    	return -1;
//    }
//    for(itr = node_id_to_all_id_map.begin(); itr != node_id_to_all_id_map.end(); itr++) {
//    	if(itr->second == all_id_for_repid){
//    		return itr->first;
//    	}
//    }
//    assert(false);
//    return -1;
//}
//int GraphNew::get_nid_from_rep_id(std::string repid) {
//    std::map<int, NodeNew *>::iterator itr;
//    for (itr = nid_to_node_map.begin(); itr != nid_to_node_map.end(); itr++) {
//        NodeNew * node = (*itr).second;
//        if (node->get_rep_id() == repid){
//            return node->get_node_id();
//        }
//    }
//    return -1;
//}

inline int GraphNew::get_nid_from_rep_id(std::string repid) {
    std::map<std::string, int>::iterator itr = rep_id_to_nid_map.find(repid);
    if (itr == rep_id_to_nid_map.end()) {
        return -1;
    } else {
        return (*itr).second;
    }
}

inline void GraphNew::add_to_rep_id_nid_map(std::string rep_id, int nid) {
    rep_id_to_nid_map.insert(pair<std::string, int>(rep_id, nid)); // changed by sukanya on 27 July 2016
    //rep_id_to_nid_map[rep_id] = nid;
}

inline void GraphNew::add_rep_id_for_node(int nid, std::string rep_id) {
    NodeNew * node = get_node_from_nid(nid);
    if (node == NULL) {
        cerr << "1. Not found node with id " << nid << endl;
    } else {
        node->set_rep_id(rep_id);
        add_to_rep_id_nid_map(rep_id, nid);
    }
}

inline void GraphNew::add_id_rep_id(std::string id, std::string repid) {
    add_to_map(id_to_rep_id_map, id, repid);
}
//void GraphNew::add_id_rep_id(std::string id, std::string repid){
//    std::map<int, NodeNew *>::iterator itr;
//    for (itr = nid_to_node_map.begin(); itr != nid_to_node_map.end(); itr++) {
//        NodeNew * node = (*itr).second;
//        if (node->get_rep_id() == repid) {
//            node->add_to_all_id(id);
//        }
//    }
//}


//std::vector<std::string> GraphNew::get_all_ids_for_rep_id(std::string rep_id){
//	std::vector<std::string> all_ids_for_repid;
//	std::map<std::string, std::string>::iterator itr;
//	for(itr = id_to_rep_id_map.begin(); itr != id_to_rep_id_map.end(); ++itr){
//		if(itr->second == rep_id){
//			all_ids_for_repid.push_back(itr->first);
//		}
//	}
//	return all_ids_for_repid;
//}

vector<string> GraphNew::get_all_ids_for_rep_id(string repid) {
    std::unordered_map<int, NodeNew *>::iterator itr;
    for (itr = nid_to_node_map.begin(); itr != nid_to_node_map.end(); itr++) {
        NodeNew * node = (*itr).second;
        if (node->get_rep_id() == repid) {
            return node->get_all_id();
        }
    }
    //cout << "Not found node with rep-id " << repid << endl;
    return vector<string>();
    //    std::vector<std::string> all_ids;
    //    all_ids.empty();
    //    return all_ids;
}

inline void GraphNew::set_all_ids_for_node(int nid, std::vector<std::string> all_ids) {
    NodeNew * node = get_node_from_nid(nid);
    if (node != NULL)
        node->set_all_id(all_ids);
}

//std::vector<std::string> GraphNew::get_all_ids_of_node(int nid){
//	return get_val_map2(node_id_to_all_id_map, nid);
//}

inline std::vector<std::string> GraphNew::get_all_ids_of_node(int nid) {
    NodeNew * node = get_node_from_nid(nid);
    if (node == NULL)
        return vector<string>();
    return node->get_all_id();
}

//bool GraphNew::node_has_id(int nid, std::string id){
//	return map_has_key_with_val(node_id_to_all_id_map, nid, id);
//}

inline bool GraphNew::node_has_id(int nid, std::string id) {
    NodeNew * node = get_node_from_nid(nid);
    if (node == NULL) {
        cerr << "2. Not found node with id " << nid << endl;
        return false;
    } else {
        std::vector<std::string> all_ids = node->get_all_id();
        if (std::find(all_ids.begin(), all_ids.end(), id) == all_ids.end())
            return false;
        else
            return true;
    }
}

//void GraphNew::add_id_for_node(int nid, std::string id){
//	add_to_map2(node_id_to_all_id_map, nid, id);
//}

inline void GraphNew::add_id_for_node(int nid, std::string id) {
    NodeNew * node = get_node_from_nid(nid);
    if (node != NULL)
        node->add_to_all_id(id);

}

//std::vector<int> GraphNew::get_component_ids_of_node(int nid){
//	return get_val_map2(components, nid);
//}

inline std::vector<int> GraphNew::get_component_ids_of_node(int nid) {
    NodeNew * node = get_node_from_nid(nid);
    if (node == NULL)
        return vector<int>();
    return node->get_comp_ids();
}

//bool GraphNew::node_has_component_id(int nid, int comp_id){
//	return map_has_key_with_val(components, nid, comp_id);
//}

inline bool GraphNew::node_has_component_id(int nid, int comp_id) {
    NodeNew * node = get_node_from_nid(nid);
    if (node == NULL) {
        return false;
    } else {
        std::vector<int> components = node->get_comp_ids();
        if (std::find(components.begin(), components.end(), comp_id) != components.end()) {
            return true;
        } else
            return false;
    }
}

//void GraphNew::add_component_id_for_node(int nid, int comp_id){
//	add_to_map2(components, nid, comp_id);
//}

inline void GraphNew::add_component_id_for_node(int nid, int comp_id) {
    NodeNew * node = get_node_from_nid(nid);
    if (node != NULL)
        node->add_comp_id(comp_id);

}

void GraphNew::update_component_of_node_at_index(int nid, int pos, int value) {
    NodeNew * node = get_node_from_nid(nid);
    if (node != NULL)
        node->update_component_id_at_index(pos, value);

}

inline void GraphNew::set_all_display_id_for_node(int nid, std::vector<std::string> all_disp_names) {
    NodeNew * node = get_node_from_nid(nid);
    if (node != NULL)
        node->set_all_display_names(all_disp_names);

}



//std::vector<std::string> GraphNew::get_all_display_ids_of_node(int nid){
//	return get_val_map2(node_id_to_display_name_map, nid);
//}

inline std::vector<std::string> GraphNew::get_all_display_ids_of_node(int nid) {
    NodeNew * node = get_node_from_nid(nid);
    if (node == NULL)
        return vector<string>();
    return node->get_disp_ids();
}

//bool GraphNew::node_has_display_id(int nid, std::string id){
//	return map_has_key_with_val(node_id_to_display_name_map, nid, id);
//}

bool GraphNew::node_has_display_id(int nid, std::string id) {
    NodeNew * node = get_node_from_nid(nid);
    if (node == NULL) {
        cerr << "3. Not found node with id " << nid << endl;
        return false;
    } else {
        std::vector<std::string> all_disp_ids = node->get_disp_ids();
        if (std::find(all_disp_ids.begin(), all_disp_ids.end(), id) != all_disp_ids.end()) {
            return true;
        } else
            return false;
    }
}

//void GraphNew::add_display_id_for_node(int nid, std::string id){
//	add_to_map2(node_id_to_display_name_map, nid, id);
//}

inline void GraphNew::add_display_id_for_node(int nid, std::string id) {
    NodeNew * node = get_node_from_nid(nid);
    if (node != NULL)
        node->add_disp_id(id);

}

//std::string GraphNew::get_node_type(int nid){
//	std::map<int, std::string>::iterator itr = node_type.find(nid);
//	if(itr != node_type.end()){
//		return itr->second;
//	}
//	else{
//		return "";
//	}
//}

inline std::string GraphNew::get_node_type(int nid) {
    NodeNew * node = get_node_from_nid(nid);
    if (node == NULL)
        return "";
    return node->get_node_type();

}

//void GraphNew::add_node_type(int nid, string type){
//	add_to_map(node_type, nid, type);
//}

inline void GraphNew::add_node_type(int nid, std::string type) {
    //    if (type == "gene" || type == "protein")
    //        type = "gene_or_protein";
    NodeNew * node = get_node_from_nid(nid);
    if (node != NULL)
        node->add_node_type(type);

}

//void GraphNew::remove_node_type_info(int nid){
//	delete_from_map(node_type, nid);
//}

inline void GraphNew::remove_node_type_info(int nid) {
    NodeNew * node = get_node_from_nid(nid);
    if (node == NULL) {
        cerr << "4 .Not found node with id " << nid << endl;
    } else {
        node->remove_node_type();
    }
}

inline void GraphNew::add_description_for_node(int nid, std::string desc) {
    NodeNew * node = get_node_from_nid(nid);
    if (node == NULL) {
        cerr << "5. Not found node with id " << nid << endl;
    } else {
        node->add_description_for_node(desc);
    }

}

inline std::string GraphNew::get_description_for_node(int nid) {
    NodeNew * node = get_node_from_nid(nid);
    if (node == NULL) {
        cerr << "6. Not found node with id " << nid << endl;
        return "";
    } else {
        return node->get_description_for_node();
    }
}

void GraphNew::add_compartment_for_node(int nid, std::string comp) {
    NodeNew * node = get_node_from_nid(nid);
    if (node == NULL) {
        cerr << "7. Not found node with id " << nid << endl;
    } else {
        node->add_compartment_for_node(comp);
    }

}

inline std::string GraphNew::get_compartment_for_node(int nid) {
    NodeNew * node = get_node_from_nid(nid);
    if (node == NULL) {
        cerr << "8. Not found node with id " << nid << endl;
        return "";
    } else {
        return node->get_compartment_for_node();
    }
}

void GraphNew::add_other_value1_to_node(int nid, int value) {
    NodeNew * node = get_node_from_nid(nid);
    if (node == NULL) {
        cerr << "8b. Not found node with id " << nid << endl;
    } else {
        node->add_other_value1(value);
    }
}
        
int GraphNew::get_other_value1_from_node(int nid) {
    NodeNew * node = get_node_from_nid(nid);
    if (node == NULL) {
        cerr << "8c. Not found node with id " << nid << endl;
        return -1;
    } else {
        return node->get_other_value1();
    }
}

void GraphNew::set_node_excess(int nid, float value) {
    NodeNew * node = get_node_from_nid(nid);
    if (node == NULL) {
        cerr << "8d. Not found node with id " << nid << endl;
    } else {
        node->set_node_excess(value);
    }
}
        
float GraphNew::get_node_excess(int nid) {
    NodeNew * node = get_node_from_nid(nid);
    if (node == NULL) {
        cerr << "8e. Not found node with id " << nid << endl;
        return -1.0;
    } else {
        return node->get_node_excess();
    }
}


void GraphNew::sort_nids_by_degree(vector<int>& nids) {
    int nids_size_before = nids.size();
    vector< pair<int, int> > vec_degree_to_nid;
    for (vector<int>::iterator vec_itr = nids.begin(); vec_itr != nids.end(); vec_itr++) {
        int curr_nid = *vec_itr;
        int degree = 0;

        vector<int> outlist = get_outlist(curr_nid);
        vector<int> inlist = get_inlist(curr_nid);

        for (vector<int>::iterator vec_itr = outlist.begin(); vec_itr != outlist.end(); vec_itr++) {
#ifdef ONLY_INTERAC_EDGES_FOR_MINCUT
            if (!NOT_INTERAC_EDGE(this, *vec_itr))
#endif
                degree++;
        }

        for (vector<int>::iterator vec_itr = inlist.begin(); vec_itr != inlist.end(); vec_itr++) {
#ifdef ONLY_INTERAC_EDGES_FOR_MINCUT
            if (!NOT_INTERAC_EDGE(this, *vec_itr))
#endif
                degree++;
        }

        //int degree = get_inlist(curr_nid).size() + get_outlist(curr_nid).size();
        vec_degree_to_nid.push_back(make_pair(curr_nid, degree));
    }

    sort(vec_degree_to_nid.begin(), vec_degree_to_nid.end(), compare_pair_on_second_descending);

    nids.clear();
    for (auto vec_pair_itr = vec_degree_to_nid.begin(); vec_pair_itr != vec_degree_to_nid.end(); vec_pair_itr++) {
        nids.push_back(vec_pair_itr->first);

    }

    assert(nids.size() == nids_size_before);
}

void GraphNew::get_nids_sorted_by_degree(map<int, vector<string> >& path_id_to_path_map, map<int, vector<int> >& path_id_to_eids_map, vector<int>& sorted_path_ids, map<int, int>& nid_to_degree_map_sorted, int num_bot_nodes, ofstream& fout) {
    vector<int> nids = get_node_ids();
    vector<int> nids_in_top_ranked_paths;
    set<int> eids_in_top_ranked_paths;

    int path_index = 1;
    int num_of_top_ranked_paths = NUM_OF_COLORS;
    for (auto itr = sorted_path_ids.begin(); itr != sorted_path_ids.end(); itr++) {
        if (path_index > NUM_OF_COLORS)
            break;

        int curr_path_id = *itr;

        if (path_id_to_path_map.find(curr_path_id) == path_id_to_path_map.end())
            continue;

        if (path_id_to_eids_map.find(curr_path_id) == path_id_to_eids_map.end())
            continue;

        vector<int> curr_path_eids = path_id_to_eids_map[curr_path_id];
        for (auto e = curr_path_eids.begin(); e != curr_path_eids.end(); e++) {
            eids_in_top_ranked_paths.insert(*e);
        }

        vector<string> curr_path_repids = path_id_to_path_map[curr_path_id];
        for (auto n = curr_path_repids.begin(); n != curr_path_repids.end(); n++) {
            int nid = get_nid_from_rep_id(*n);
            if (nid != -1)
                nids_in_top_ranked_paths.push_back(nid);
        }

        path_index++;
    }

    vector< pair<int, int> > vec_nid_to_degree;

    for (vector<int>::iterator vec_itr = nids_in_top_ranked_paths.begin(); vec_itr != nids_in_top_ranked_paths.end(); vec_itr++) {
        int curr_nid = *vec_itr;
        int degree = 0;
        int indegree = 0;
        int outdegree = 0;

        set<int> inedges, outedges;

        vector<int> outlist = get_outlist(curr_nid);
        vector<int> inlist = get_inlist(curr_nid);

        if (outlist.empty() || inlist.empty())
            continue;

        for (vector<int>::iterator vec_itr = outlist.begin(); vec_itr != outlist.end(); vec_itr++) {
            if (eids_in_top_ranked_paths.find(*vec_itr) != eids_in_top_ranked_paths.end()) {
#ifdef ONLY_INTERAC_EDGES_FOR_MINCUT
                if (!NOT_INTERAC_EDGE(this, *vec_itr)) {
#endif
                    outedges.insert(*vec_itr);
                    outdegree++;
#ifdef ONLY_INTERAC_EDGES_FOR_MINCUT
                }
#endif                
            }
        }

        for (vector<int>::iterator vec_itr = inlist.begin(); vec_itr != inlist.end(); vec_itr++) {
            if (eids_in_top_ranked_paths.find(*vec_itr) != eids_in_top_ranked_paths.end()) {
#ifdef ONLY_INTERAC_EDGES_FOR_MINCUT
                if (!NOT_INTERAC_EDGE(this, *vec_itr)) {
#endif
                    inedges.insert(*vec_itr);
                    indegree++;
#ifdef ONLY_INTERAC_EDGES_FOR_MINCUT
                }
#endif                
            }
        }

        //degree = indegree + outdegree;
        degree = inedges.size() - outedges.size();

        if (degree > 0) {
            vec_nid_to_degree.push_back(make_pair(curr_nid, degree));

        }


    }

    sort(vec_nid_to_degree.begin(), vec_nid_to_degree.end(), compare_pair_on_second_descending);

    //std::reverse(vec_nid_to_degree.begin(),vec_nid_to_degree.end()); // reversing the vector gives the "downstream" nodes in case of a tie on degree


    auto it = std::unique(vec_nid_to_degree.begin(), vec_nid_to_degree.end());
    vec_nid_to_degree.resize(std::distance(vec_nid_to_degree.begin(), it));

    int n = 1;
    for (auto vec_pair_itr = vec_nid_to_degree.begin(); vec_pair_itr != vec_nid_to_degree.end(); vec_pair_itr++) {
        nid_to_degree_map_sorted[vec_pair_itr->first] = vec_pair_itr->second;
        if (n <= num_bot_nodes) {
            cout << get_all_display_ids_of_node(vec_pair_itr->first)[0] << endl;
            fout << get_rep_id_from_nid(vec_pair_itr->first) << " 255 190 0 " << endl;
            n++;
        }
    }
    cout << endl;
    fout << endl;
    //assert (nids.size() == nid_to_degree_map_sorted.size());
}

void GraphNew::get_eids_sorted_by_degree(map<int, vector<string> >& path_id_to_path_map, map<int, vector<int> >& path_id_to_eids_map, vector<int>& sorted_path_ids, map<int, int>& eid_to_degree_map_sorted, int num_bot_nodes, map<int, int>& eid_to_color_map) {
    vector<int> nids_in_top_ranked_paths;
    vector<int> eids_in_top_ranked_paths;

    int path_index = 1;
    int num_of_top_ranked_paths = NUM_OF_COLORS;
    for (auto itr = sorted_path_ids.begin(); itr != sorted_path_ids.end(); itr++) {
        if (path_index > NUM_OF_COLORS)
            break;

        int curr_path_id = *itr;

        if (path_id_to_path_map.find(curr_path_id) == path_id_to_path_map.end())
            continue;

        if (path_id_to_eids_map.find(curr_path_id) == path_id_to_eids_map.end())
            continue;

        vector<int> curr_path_eids = path_id_to_eids_map[curr_path_id];
        for (auto e = curr_path_eids.begin(); e != curr_path_eids.end(); e++) {
            eids_in_top_ranked_paths.push_back(*e);
        }

        vector<string> curr_path_repids = path_id_to_path_map[curr_path_id];
        for (auto n = curr_path_repids.begin(); n != curr_path_repids.end(); n++) {
            int nid = get_nid_from_rep_id(*n);
            if (nid != -1)
                nids_in_top_ranked_paths.push_back(nid);
        }

        path_index++;
    }

    vector< pair<int, int> > vec_eid_to_degree;

    for (vector<int>::iterator vec_itr = eids_in_top_ranked_paths.begin(); vec_itr != eids_in_top_ranked_paths.end(); vec_itr++) {
        int curr_eid = *vec_itr;
        int curr_src_nid = get_source_node(curr_eid);
        int curr_tgt_nid = get_target_node(curr_eid);


        int degree = 0;
        set<int> inedges, outedges;
        vector<int> inlist = get_inlist(curr_src_nid);
        vector<int> outlist = get_outlist(curr_tgt_nid);


        if (outlist.empty() || inlist.empty())
            continue;

        for (vector<int>::iterator vec_itr = outlist.begin(); vec_itr != outlist.end(); vec_itr++) {
            int target_nid = get_target_node(*vec_itr);

            if (std::find(nids_in_top_ranked_paths.begin(), nids_in_top_ranked_paths.end(), target_nid) != nids_in_top_ranked_paths.end()) {

                outedges.insert(target_nid);


            }
        }

        for (vector<int>::iterator vec_itr = inlist.begin(); vec_itr != inlist.end(); vec_itr++) {
            int source_nid = get_source_node(*vec_itr);
            if (std::find(nids_in_top_ranked_paths.begin(), nids_in_top_ranked_paths.end(), source_nid) != nids_in_top_ranked_paths.end()) {

                inedges.insert(source_nid);


            }
        }

        //degree = indegree + outdegree;
        degree = inedges.size() + outedges.size();

        if (degree > 0) {
            vec_eid_to_degree.push_back(make_pair(curr_eid, degree));

        }


    }

    sort(vec_eid_to_degree.begin(), vec_eid_to_degree.end(), compare_pair_on_second_descending);

    //std::reverse(vec_nid_to_degree.begin(),vec_nid_to_degree.end()); // reversing the vector gives the "downstream" nodes in case of a tie on degree


    auto it = std::unique(vec_eid_to_degree.begin(), vec_eid_to_degree.end());
    vec_eid_to_degree.resize(std::distance(vec_eid_to_degree.begin(), it));

    int n = 1;
    for (auto vec_pair_itr = vec_eid_to_degree.begin(); vec_pair_itr != vec_eid_to_degree.end(); vec_pair_itr++) {
        eid_to_degree_map_sorted[vec_pair_itr->first] = vec_pair_itr->second;
        if (n <= num_bot_nodes) {
            //cout << get_all_display_ids_of_node(vec_pair_itr->first)[0] << endl;
            ////eid_to_color_map[vec_pair_itr->first] = 8;
            //fout << get_rep_id_from_nid(vec_pair_itr->first) << " 255 190 0 " << endl;
            n++;
        }
    }
    //cout << endl;
    //fout << endl;

}

void GraphNew::get_nids_sorted_by_betweenness(map<int, float>& nid_to_betw_map) {
    vector<int> nids = get_node_ids();
    map<int, int> nid_to_p_map;     
    
    // Initialize betweenness of every vertex in the network to 0
    for (auto nid_itr = nids.begin(); nid_itr != nids.end(); nid_itr++) {
        nid_to_betw_map.insert(pair<int, float>(*nid_itr, 0.0));
        nid_to_p_map.insert(pair<int, int> (*nid_itr, 0));
    }

    
    for (auto nid_itr = nids.begin(); nid_itr != nids.end(); nid_itr++) {
        int curr_nid = *nid_itr;
        
        for (auto i = nids.begin(); i != nids.end(); i++) {
            nid_to_p_map[*i] = 0;
        }
        
        nid_to_p_map[curr_nid] = 1;

        bfs_for_betweenness(curr_nid, nid_to_p_map, nid_to_betw_map);

    }

    // sort nids by betw
//    for (auto nid_itr = nids.begin(); nid_itr != nids.end(); nid_itr++) {
//        cout << *nid_itr << ": " << nid_to_betw_map[*nid_itr] << endl;
//    }
}


//int GraphNew::get_betweenness_of_node(int nid, map<int, int>& nid_to_p_map, map<int, int>& nid_to_b_map, map<int, int>& nid_to_betw_map) {
//    vector<int> leaf_node_nids;
//    
//    bfs_for_betweenness(nid, nid_to_p_map, nid_to_b_map, nid_to_betw_map, leaf_node_nids);
//    
//    
//    
//    
//    
//    return nid_to_b_map[nid];
//}

void GraphNew::bfs_for_betweenness(int nid, map<int, int>& nid_to_p_map, map<int, float>& nid_to_betw_map) {
    cout << "NID: " << nid << endl;
    
    map<int, float> nid_to_b_map;
    
    //nid_to_b_map[nid] = 1;
    vector<int> nids = get_node_ids();
    
//    for (auto nid_itr = nids.begin(); nid_itr != nids.end(); nid_itr++) {
//        nid_to_b_map.insert(pair<int, float>(*nid_itr, 1.0));
//    }
    
    int level;

    map<int, int> nid_to_level_map;
    vector<int> leaf_node_nids;
    list<int> queue;
    vector<int> visited;

    queue.push_back(nid);


    nid_to_level_map.insert(pair<int,int>(nid, 0));
    visited.push_back(nid);
    
    while (!queue.empty()) {
        int node_i = queue.front();
        level = nid_to_level_map[node_i];
        
        queue.pop_front();
        
        vector<int> tgt_inlist = get_inlist(node_i);
        if (level == 0) {
            nid_to_p_map[node_i] = 1;
        }
        else {
            int p_node_i = 0;
                
            for (auto in_itr = tgt_inlist.begin(); in_itr != tgt_inlist.end(); in_itr++) {
                int node_k = get_source_node(*in_itr);

                if (nid_to_level_map.find(node_k) != nid_to_level_map.end()) {
                    if (nid_to_level_map[node_k] == level -1) {
                        p_node_i = p_node_i + nid_to_p_map[node_k];
                        //cout << node_i << " -- " << p_node_i << endl;
                    }
                }
            }
            nid_to_p_map[node_i] = p_node_i;
        }


        vector<int> outlist = get_outlist(node_i);
        
        for (auto out_itr = outlist.begin(); out_itr != outlist.end(); out_itr++) {

            int node_j = get_target_node(*out_itr);
            //nid_to_b_map[node_j] = 1;
            if (std::find(visited.begin(), visited.end(), node_j) == visited.end()) {

                nid_to_level_map.insert(pair<int,int>(node_j, level+1));
                queue.push_back(node_j);
                visited.push_back(node_j);

            }       
                
        }
    }
    
    
    for (auto itr = visited.begin(); itr != visited.end(); itr++) {
        nid_to_b_map.insert(pair<int, float>(*itr, 1.0));
    }

//    for (auto itr = nid_to_level_map.begin(); itr != nid_to_level_map.end(); itr++) {
//        cout << itr->first << " at " << itr->second << endl;
//    }
    
    
    for (auto itr = nid_to_level_map.begin(); itr != nid_to_level_map.end(); itr++) {
        if (itr->second == level)
            leaf_node_nids.push_back(itr->first);
    }
        
//    if (leaf_node_nids.size() == 1)
//        if (get_inlist(leaf_node_nids.front()).size() == 1)
//                nid_to_b_map[leaf_node_nids.front()] = 0;
    
    list<int> rev_queue;
    vector<int> rev_visited;
    
    for (auto leaf_itr = leaf_node_nids.begin(); leaf_itr != leaf_node_nids.end(); leaf_itr++) {
        int node_j = *leaf_itr;
        rev_queue.push_back(node_j);
    }

    

    while (!rev_queue.empty()) {
        
        int curr_j = rev_queue.front();
        
        rev_queue.pop_front();
        level = nid_to_level_map[curr_j];

        vector<int> curr_inlist = get_inlist(curr_j);

        
        for (auto in_itr = curr_inlist.begin(); in_itr != curr_inlist.end(); in_itr++) {
            int node_k = get_source_node(*in_itr);
            
            if (nid_to_level_map.find(node_k) != nid_to_level_map.end()) {
                if (nid_to_level_map[node_k] == level - 1) { 
            
                    if (std::find(rev_visited.begin(), rev_visited.end(), node_k) == rev_visited.end()) {
                        rev_queue.push_back(node_k);
                        rev_visited.push_back(node_k);
                    }
                    
                    float temp1 = (nid_to_b_map[curr_j]*((float) nid_to_p_map[node_k] / (float) nid_to_p_map[curr_j]));
            
                     nid_to_b_map[node_k] += temp1;
            
        //            cout << temp1 << " " << temp2 << endl;
        //    nid_to_b_map[node_k] = temp1 + temp2;

            
                }       
            }
    
        }
    
//    for (auto b_itr = nid_to_b_map.begin(); b_itr != nid_to_b_map.end(); b_itr++) {
//        cout << b_itr->first << " -> " << b_itr->second << endl;
//    }
//    cout << endl;


//    std::vector<int>::iterator it;
//    it = std::unique(visited.begin(), visited.end());
//    visited.resize(std::distance(visited.begin(), it));
//    
//    for (auto leaf_itr = leaf_node_nids.begin(); leaf_itr != leaf_node_nids.end(); leaf_itr++) {
//        nid_to_b_map[*leaf_itr] = 0;
//        
//        
//    }
//    
    }
    
    //cout << "visited size " << visited.size() << endl;
    
//
    for (auto node_itr = visited.begin(); node_itr != visited.end(); node_itr++) {
        int curr_nid = *node_itr;

        float b = nid_to_b_map[curr_nid];
        float B = nid_to_betw_map[curr_nid];
        nid_to_betw_map[curr_nid] = b + B;
//        cout << curr_nid << " -> " << nid_to_betw_map[curr_nid] << endl;
                      
    } 
        
        
//    for (auto b_itr = nid_to_betw_map.begin(); b_itr != nid_to_betw_map.end(); b_itr++) {
//        cout << b_itr->first << " >> " << b_itr->second << endl;
//    }
//    cout << endl;
//    cout << endl;
    
    
}

inline void GraphNew::get_all_eids_between_two_nodes(int src_nid, int tgt_nid, set<int>& all_eids) {
    vector<int> outlist = get_outlist(src_nid);
    for (vector<int>::iterator vec_itr = outlist.begin(); vec_itr != outlist.end(); vec_itr++) {
        int curr_eid = *vec_itr;
        if (get_target_node(curr_eid) == tgt_nid)
            all_eids.insert(curr_eid);
    }
}

//std::string GraphNew::get_edge_type(int eid){
//	std::map<int, std::string>::iterator itr = edge_type.find(eid);
//	if(itr != edge_type.end()){
//		return itr->second;
//	}
//	else{
//		return "";
//	}
//}

inline std::string GraphNew::get_edge_type(int eid) {
    EdgeNew * edge = get_edge_from_eid(eid);
    if (edge == NULL) {
        cerr << "9. Not found edge with id " << eid << endl;
        return "";
    } else {
        return edge->get_edge_type();
    }
}

//void GraphNew::add_edge_type(int eid, std::string type){
//	add_to_map(edge_type, eid, type);
//}

inline void GraphNew::add_edge_type(int eid, std::string type) {
    EdgeNew * edge = get_edge_from_eid(eid);
    if (edge == NULL) {
        cerr << "10. Not found edge with id " << eid << endl;
    } else {
        edge->add_edge_type(type);
    }
}

//void GraphNew::remove_edge_id_type(int eid){
//	delete_from_map(edge_type, eid);
//}

inline void GraphNew::remove_edge_id_type(int eid) {
    EdgeNew * edge = get_edge_from_eid(eid);
    if (edge == NULL) {
        cerr << "11. Not found edge with id " << eid << endl;
    } else {
        edge->remove_edge_type();
    }
}




inline void GraphNew::add_edge_to_adj_matrix(int i, int j) {
    adj_matrix[i][j] = true;
}
        
inline bool GraphNew::get_edge_presence_status_from_adj_matrix(int i, int j) {
    return adj_matrix[i][j];
}


//std::vector<std::string> GraphNew::get_edge_subtypes_of_edge(int eid){
//	return get_val_map2(edge_subtypes, eid);
//}

inline std::vector<std::string> GraphNew::get_edge_subtypes_of_edge(int eid) {
    EdgeNew * edge = get_edge_from_eid(eid);
    if (edge == NULL) {
        cerr << "12. Not found edge with id " << eid << endl;
        std::vector<std::string> subtypes;
        subtypes.empty();
        return subtypes;
    } else {
        return edge->get_edge_subtypes();
    }
}

//bool GraphNew::edge_has_subtype(int eid, std::string subtype){
//	return map_has_key_with_val(edge_subtypes, eid, subtype);
//}

inline bool GraphNew::edge_has_subtype(int eid, std::string subtype) {
    EdgeNew * edge = get_edge_from_eid(eid);
    if (edge == NULL) {
        cerr << "13. Not found edge with id " << eid << endl;
        return false;
    } else {
        std::vector<std::string> all_subtypes = edge->get_edge_subtypes();
        if (std::find(all_subtypes.begin(), all_subtypes.end(), subtype) != all_subtypes.end()) {
            return true;
        } else
            return false;
    }
}

//void GraphNew::add_subtype_for_edge(int eid, std::string subtype){
//	add_to_map2(edge_subtypes, eid, subtype);
//}

inline void GraphNew::add_subtype_for_edge(int eid, std::string subtype) {
    EdgeNew * edge = get_edge_from_eid(eid);
    if (edge == NULL) {
        cerr << "14. Not found edge with id " << eid << endl;
    } else {
        edge->add_subtype(subtype);
    }
}

inline void GraphNew::add_reaction_desc_for_edge(int eid, std::string desc) {
    EdgeNew * edge = get_edge_from_eid(eid);
    if (edge == NULL) {
        cerr << "15. Not found edge with id " << eid << endl;
    } else {
        edge->add_reaction_desc(desc);
    }
}

inline std::string GraphNew::get_reaction_desc_for_edge(int eid) {
    EdgeNew * edge = get_edge_from_eid(eid);
    if (edge == NULL) {
        cerr << "16. Not found edge with id " << eid << endl;
        return "";
    } else {
        return edge->get_reaction_desc();
    }
}
//std::vector<std::string> GraphNew::get_all_pathways_for_edge(int eid){
//	return get_val_map2(edge_belongs_to_pathways, eid);
//}

inline std::vector<std::string> GraphNew::get_all_pathways_for_edge(int eid) {
    EdgeNew * edge = get_edge_from_eid(eid);
    if (edge == NULL) {
        cerr << "17. Not found edge with id " << eid << endl;
        std::vector<std::string> pathways;
        pathways.empty();
        return pathways;
    } else {
        return edge->get_pathways();
    }
}

//bool GraphNew::edge_belongs_to_pathway(int eid, std::string pathway){
//	return map_has_key_with_val(edge_belongs_to_pathways, eid, pathway);
//}

inline bool GraphNew::edge_belongs_to_pathway(int eid, std::string pathway) {
    EdgeNew * edge = get_edge_from_eid(eid);
    if (edge == NULL) {
        cerr << "18. Not found edge with id " << eid << endl;
        return false;
    } else {
        std::vector<std::string> all_pathways = edge->get_pathways();
        if (std::find(all_pathways.begin(), all_pathways.end(), pathway) != all_pathways.end()) {
            return true;
        } else
            return false;
    }
}

//void GraphNew::add_pathway_for_edge(int eid, std::string pathway){
//	add_to_map2(edge_belongs_to_pathways, eid, pathway);
//}

inline void GraphNew::add_pathway_for_edge(int eid, std::string pathway) {
    EdgeNew * edge = get_edge_from_eid(eid);
    if (edge == NULL) {
        cerr << "19. Not found edge with id " << eid << endl;
    } else {
        edge->add_pathway(pathway);
    }
}

//void GraphNew::add_source_node(int eid, int nid){
//	add_to_map(edge_source, eid, nid);
//}

inline void GraphNew::add_source_node(int eid, int nid) {
    NodeNew * node = get_node_from_nid(nid);
    if (node == NULL) {
        cerr << "20. Not found node with id " << nid << endl;
    }
    EdgeNew * edge = get_edge_from_eid(eid);
    if (edge == NULL) {
        cerr << "Not found edge with id " << eid << endl;
    }
    edge->add_source(nid);
}

//int GraphNew::get_source_node(int eid){
//	std::map<int, int>::iterator itr = edge_source.find(eid);
//	if(itr != edge_source.end()){
//		return itr->second;
//	}
//	else{
//		return -1;
//	}
//}

inline int GraphNew::get_source_node(int eid) {
    EdgeNew * edge = get_edge_from_eid(eid);
    if (edge == NULL)
        return -1;
    return edge->get_source();

}

//void GraphNew::add_target_node(int eid, int nid){
//	add_to_map(edge_target, eid, nid);
//}

inline void GraphNew::add_target_node(int eid, int nid) {
    NodeNew * node = get_node_from_nid(nid);
    if (node == NULL) {
        cerr << "21. Not found node with id " << nid << endl;
    }
    EdgeNew * edge = get_edge_from_eid(eid);
    if (edge == NULL) {
        cerr << "Not found edge with id " << eid << endl;
    }
    edge->add_target(nid);
}

//int GraphNew::get_target_node(int eid){
//	std::map<int, int>::iterator itr = edge_target.find(eid);
//	if(itr != edge_target.end()){
//		return itr->second;
//	}
//	else{
//		return -1;
//	}
//}

inline int GraphNew::get_target_node(int eid) {
    EdgeNew * edge = get_edge_from_eid(eid);
    if (edge == NULL)
        return -1;
    return edge->get_target();

}

//std::vector<int> GraphNew::get_inlist(int nid){
//	return get_val_map2(inlist, nid);
//}

inline std::vector<int> GraphNew::get_inlist(int nid) {
    NodeNew * node = get_node_from_nid(nid);
    if (node == NULL) {
        cerr << "22a. Not found node with id " << nid << endl;
        std::vector<int> inlist;
        inlist.empty();
        return inlist;
    } else {
        return node->get_inlist();
    }
}

//bool GraphNew::node_has_edge_in_inlist(int nid, int eid){
//	return map_has_key_with_val(inlist, nid, eid);
//}

inline bool GraphNew::node_has_edge_in_inlist(int nid, int eid) {
    NodeNew * node = get_node_from_nid(nid);
    if (node == NULL) {
        cerr << "23. Not found node with id " << nid << endl;
        return false;
    } else {
        std::vector<int> edges_in_inlist = node->get_inlist();
        if (std::find(edges_in_inlist.begin(), edges_in_inlist.end(), eid) != edges_in_inlist.end()) {
            return true;
        } else
            return false;
    }
}

//void GraphNew::add_edge_to_inlist_of_node(int nid, int eid){
//	add_to_map2(inlist, nid, eid);
//}

inline void GraphNew::add_edge_to_inlist_of_node(int nid, int eid) {
    NodeNew * node = get_node_from_nid(nid);
    if (node == NULL) {
        cerr << "24. Not found node with id " << nid << endl;
    } else {
        node->add_to_inlist(eid);
    }
}

//std::vector<int> GraphNew::get_outlist(int nid){
//	return get_val_map2(outlist, nid);
//}

inline std::vector<int> GraphNew::get_outlist(int nid) {
    NodeNew * node = get_node_from_nid(nid);
    if (node == NULL) {
        cerr << "22b. Not found node with id " << nid << endl;
        std::vector<int> outlist;
        outlist.empty();
        return outlist;
    } else {
        return node->get_outlist();
    }
   
}

//bool GraphNew::node_has_edge_in_outlist(int nid, int eid){
//	return map_has_key_with_val(outlist, nid, eid);
//}

inline bool GraphNew::node_has_edge_in_outlist(int nid, int eid) {
    NodeNew * node = get_node_from_nid(nid);
    if (node == NULL) {
        cerr << "25. Not found node with id " << nid << endl;
        return false;
    } else {
        std::vector<int> edges_in_outlist = node->get_outlist();
        if (std::find(edges_in_outlist.begin(), edges_in_outlist.end(), eid) != edges_in_outlist.end()) {
            return true;
        } else
            return false;
    }
}

//void GraphNew::add_edge_to_outlist_of_node(int nid, int eid){
//	add_to_map2(outlist, nid, eid);
//}

inline void GraphNew::add_edge_to_outlist_of_node(int nid, int eid) {
    NodeNew * node = get_node_from_nid(nid);
    if (node == NULL) {
        cerr << "26. Not found node with id " << nid << endl;
    } else {
        node->add_to_outlist(eid);
    }
}

inline void GraphNew::add_other_values_in_edge(int eid, int value) {
    EdgeNew * edge = get_edge_from_eid(eid);
    if (edge == NULL) {
        cerr << "27. Not found edge with id " << eid << endl;
    } else {
        edge->add_other_values(value);
    }
}

inline std::vector<int> GraphNew::get_other_values_in_edge(int eid) {
    EdgeNew * edge = get_edge_from_eid(eid);
    if (edge == NULL)
        return vector<int>();
    return edge->get_other_values();
}

inline void GraphNew::set_other_value1_in_edge(int eid, int value) {
    EdgeNew * edge = get_edge_from_eid(eid);
    if (edge == NULL) {
        cerr << "28. Not found edge with id " << eid << endl;
    } else {
        edge->set_other_value1(value);
    }
}

inline int GraphNew::get_other_value1_in_edge(int eid) {
    EdgeNew * edge = get_edge_from_eid(eid);
    if (edge == NULL)
        return -1;
    return edge->get_other_value1();

}

inline void GraphNew::set_other_value2_in_edge(int eid, int value) {
    EdgeNew * edge = get_edge_from_eid(eid);
    if (edge == NULL) {
        cerr << "29. Not found edge with id " << eid << endl;
    } else {
        edge->set_other_value2(value);
    }
}

inline int GraphNew::get_other_value2_in_edge(int eid) {
    EdgeNew * edge = get_edge_from_eid(eid);
    if (edge == NULL)
        return -1;
    return edge->get_other_value2();

}

inline void GraphNew::set_other_value3_in_edge(int eid, int value) {
    EdgeNew * edge = get_edge_from_eid(eid);
    if (edge == NULL) {
        cerr << "30. Not found edge with id " << eid << endl;
    } else {
        edge->set_other_value3(value);
    }
}

inline int GraphNew::get_other_value3_in_edge(int eid) {
    EdgeNew * edge = get_edge_from_eid(eid);
    if (edge == NULL)
        return -1;
    return edge->get_other_value3();

}

inline void GraphNew::set_other_value4_in_edge(int eid, int value) {
    EdgeNew * edge = get_edge_from_eid(eid);
    if (edge == NULL) {
        cerr << "31. Not found edge with id " << eid << endl;
    } else {
        edge->set_other_value4(value);
    }
}

inline int GraphNew::get_other_value4_in_edge(int eid) {
    EdgeNew * edge = get_edge_from_eid(eid);
    if (edge == NULL)
        return -1;
    return edge->get_other_value4();

}

inline void GraphNew::set_edge_weight(int eid, int weight) {
    EdgeNew * edge = get_edge_from_eid(eid);
    if (edge == NULL) {
        cerr << "32. Not found edge with id " << eid << endl;
    } else {
        edge->set_edge_weight(weight);
    }
}

inline void GraphNew::set_edge_weight_float(int eid, float weight) {
    EdgeNew * edge = get_edge_from_eid(eid);
    if (edge == NULL) {
        cerr << "32b. Not found edge with id " << eid << endl;
    } else {
        edge->set_edge_weight_float(weight);
    }
}

inline int GraphNew::get_edge_weight(int eid) {
    EdgeNew * edge = get_edge_from_eid(eid);
    if (edge == NULL)
        return -1;
    return edge->get_edge_weight();
}


inline float GraphNew::get_edge_weight_float(int eid) {
    EdgeNew * edge = get_edge_from_eid(eid);
    if (edge == NULL)
        return -1.0;
    return edge->get_edge_weight_float();
}

inline void GraphNew::set_edge_capacity(int eid, float value) {
    EdgeNew * edge = get_edge_from_eid(eid);
    if (edge == NULL) {
        cerr << "32c. Not found edge with id " << eid << endl;
    } else {
        edge->set_edge_capacity(value);
    }
}

inline float GraphNew::get_edge_capacity(int eid) {
    EdgeNew * edge = get_edge_from_eid(eid);
    if (edge == NULL)
        return -1.0;
    return edge->get_edge_capacity();
}
    
inline void GraphNew::set_edge_flow(int eid, float value) {
    EdgeNew * edge = get_edge_from_eid(eid);
    if (edge == NULL) {
        cerr << "32d. Not found edge with id " << eid << endl;
    } else {
        edge->set_edge_flow(value);
    }
}
    
inline float GraphNew::get_edge_flow(int eid) {
    EdgeNew * edge = get_edge_from_eid(eid);
    if (edge == NULL)
        return -1;
    return edge->get_edge_flow();
}
        
        
void GraphNew::add_to_weight_tuple_for_edge(int eid, float weight) {
    EdgeNew * edge = get_edge_from_eid(eid);
    cout <<  eid << " ";
    if (edge == NULL)
        cerr << "33. Not found edge with id " << eid << endl;
    else
        edge->add_to_weight_tuple(weight);    
}

void GraphNew::set_weight_tuple_for_edge(int eid, vector<float> tuple) {
    EdgeNew * edge = get_edge_from_eid(eid);
    if (edge == NULL)
        cerr << "33a. Not found edge with id " << eid << endl;
    else
        edge->set_weight_tuple(tuple);
}
        
std::vector<float> GraphNew::get_weight_tuple_for_edge(int eid) {
    EdgeNew * edge = get_edge_from_eid(eid);
    if (edge == NULL) {
        cerr << "35. Not found edge with id " << eid << endl;
        return vector<float>();
    } else {
        return edge->get_weight_tuple();
    }
}

void GraphNew::set_weight_factor_at_tuple_index_for_edge(int eid, int index, float value) {
    EdgeNew * edge = get_edge_from_eid(eid);
    if (edge == NULL)
        cerr << "36. Not found edge with id " << eid << endl;
    else
        edge->set_weight_factor_at_tuple_index(index, value);
}

float GraphNew::get_weight_factor_at_tuple_index_for_edge(int eid, int index) {
    EdgeNew * edge = get_edge_from_eid(eid);
    if (edge == NULL) {
        cerr << "37. Not found edge with id " << eid << endl;
        return -1.0;
    } else {
        return edge->get_weight_factor_at_tuple_index(index);
    }
        
}

        
/****  HIGHLY INEFFICIENT CODE : Supratik, Aug 22, 2015.  NEEDS CHANGE ***/
int GraphNew::get_node_id_with_components(std::set<int>& comp_ids_set) {
    assert(!comp_ids_set.empty());
    int nid = -1;
    std::vector<int> comp_ids_vec(comp_ids_set.begin(), comp_ids_set.end());
    for (std::vector<int>::iterator node_id_itr = NIDSg.begin(); node_id_itr != NIDSg.end(); node_id_itr++) {
        if (get_node_type(*node_id_itr) == "group" && get_component_ids_of_node(*node_id_itr) == comp_ids_vec) {
            nid = *node_id_itr;
            break;
        }
    }
    return nid;
}

std::string GraphNew::concatenate_sorted_rep_ids(std::set<int>& components, std::string delim) {
    std::string to_return = "";
    std::set<std::string> comp_rep_ids;

    for (std::set<int>::iterator set_itr = components.begin(); set_itr != components.end(); set_itr++) {
        string rid = get_rep_id_from_nid(*set_itr);
        assert(rid != ""); //must be assigned rep ids to components from same graph
        comp_rep_ids.insert(rid);
    }

    if (comp_rep_ids.size() == 1) {
        return *comp_rep_ids.begin();
    }

    to_return = *comp_rep_ids.begin();

    for (std::set<std::string>::iterator set_itr = comp_rep_ids.begin(); set_itr != comp_rep_ids.end(); set_itr++) {
        if (set_itr != comp_rep_ids.begin()) {
            to_return += delim + *set_itr;
        }
    }

    return to_return;
}

void GraphNew::preprocess_graph_for_mincut(vector<int>& node_ids, vector<int>& gomoryhu_parents) {
    // Graph is undirected
    vector<int> orig_node_ids = get_node_ids();
    if (orig_node_ids.empty()) {
        cout << "Empty graph. Returning" << endl;
        return;
    }
    first_offset = orig_node_ids.front();

    // shuffle node seq numbers
    int num_of_nodes = orig_node_ids.size();


    int index = 0;
    vector<int>::iterator nid_itr;

    int counter1 = 1; //0;
    for (nid_itr = orig_node_ids.begin(); nid_itr != orig_node_ids.end(); nid_itr++) {
        if (is_isolated_node(*nid_itr)) {
            int nseq = num_of_nodes - counter1;
            counter1++;
            map_nid_to_nseq.insert(pair<int, int>(*nid_itr, nseq));
            map_nseq_to_nid.insert(pair<int, int>(nseq, *nid_itr));
        } else {
            node_ids.push_back(*nid_itr);
        }
    }

    //std::random_shuffle(node_ids.begin(), node_ids.end());
    //sort_nids_by_degree(node_ids);
    //std::reverse(node_ids.begin(), node_ids.end());

    
    for (nid_itr = node_ids.begin(); nid_itr != node_ids.end(); nid_itr++) {
        map_nid_to_nseq.insert(pair<int, int>(*nid_itr, index));
        map_nseq_to_nid.insert(pair<int, int>(index, *nid_itr));

        gomoryhu_parents.push_back(0);
        
        index++;
    }


#ifdef DEBUG_FLAG                            
    debug_log << "Set parents of nodes to 0" << endl;
#endif      


}


void GraphNew::preprocess_graph_for_node_edge_seq_num() {
   
    vector<int> nids = get_node_ids();
    vector<int> eids = get_edge_ids();
    if (nids.empty() || eids.empty()) {
        cout << "Empty graph. Returning" << endl;
        return;
    }
    

    int index = 0;
    
    for (auto nid_itr = nids.begin(); nid_itr != nids.end(); nid_itr++) {
        map_nid_to_nseq.insert(pair<int, int>(*nid_itr, index));
        map_nseq_to_nid.insert(pair<int, int>(index, *nid_itr));

        index++;
    }

    index = 0;
    

    
    for (auto eid_itr = eids.begin(); eid_itr != eids.end(); eid_itr++) {
#ifdef ONLY_INTERAC_EDGES_FOR_MINCUT
        if (NOT_INTERAC_EDGE(this, (*eid_itr)))
            continue;
#endif

        map_eid_to_eseq.insert(pair<int, int>(*eid_itr, index));
        map_eseq_to_eid.insert(pair<int, int>(index, *eid_itr));
        
        index++;
    }
    
    
}



void GraphNew::bfs(int source_node, unordered_map<int, int>& bfs_tree) {

#ifdef DEBUG_FLAG
    debug_log << endl << " -- bfs begins --" << endl;
#endif

    int curr_source, curr_target;
    list<int> queue;
    set<int> visited;


    queue.push_back(source_node);
    visited.insert(source_node);

    while (!queue.empty()) {
        curr_source = queue.front();

        queue.pop_front();

        vector<int> out_list = get_outlist(curr_source);

        for (vector<int>::iterator edge_itr = out_list.begin(); edge_itr != out_list.end(); edge_itr++) {
            curr_target = get_target_node(*edge_itr);

            if (visited.find(curr_target) == visited.end()) {
                queue.push_back(curr_target);
                bfs_tree.insert(pair<int, int>(curr_target, curr_source));
                visited.insert(curr_target);
#ifdef DEBUG_FLAG
                debug_log << curr_source << " -> " << curr_target << endl;
#endif                 
            }
        }

    }

#ifdef DEBUG_FLAG
    debug_log << " -- bfs ends --" << endl;
#endif    
}

void GraphNew::get_bfs_nodes(int i, set<int>& reachable_nodes, int direction) {
    set<int> visited;
    list<int> bfs_queue;

    bfs_queue.push_back(i);

    while (!bfs_queue.empty()) {

        int curr_node = bfs_queue.front();
        bfs_queue.pop_front();

        if (visited.find(curr_node) == visited.end()) {

            visited.insert(curr_node);
            reachable_nodes.insert(curr_node);

            vector<int> edges_list;
            if (direction == FORWARD) {
                edges_list = get_outlist(curr_node);
            } else if (direction == BACKWARD) {
                edges_list = get_inlist(curr_node);
            } else {
                cerr << "Invalid direction" << endl;
            }

            for (vector<int>::iterator vec_itr = edges_list.begin(); vec_itr != edges_list.end(); vec_itr++) {

                if (direction == FORWARD) {
                    int target_node = get_target_node(*vec_itr);
                    bfs_queue.push_back(target_node);
                } else if (direction == BACKWARD) {
                    int source_node = get_source_node(*vec_itr);
                    bfs_queue.push_back(source_node);
                } else {
                    cerr << "Invalid direction" << endl;
                }

            }
        }

    }

}

void GraphNew::augment_bfs(int source_node, int target_node, unordered_map<int, int>& bfs_tree) {

}

list<int> GraphNew::get_path(int source, int target, unordered_map<int, int> bfs_tree) {

    unordered_map<int, int>::iterator map_itr;
    list<int> path;
    path.push_front(target);
    while (target != source) {
        map_itr = bfs_tree.find(target);
        target = (*map_itr).second;
        path.push_front(target);
    }
#ifdef DEBUG_FLAG
    debug_log << " -- path -- " << endl;
    for (list<int>::iterator list_itr = path.begin(); list_itr != path.end(); list_itr++) {
        debug_log << (*list_itr) << " ";
    }
    debug_log << endl;
#endif 

    return path;
}

void GraphNew::write_node_to_dot_file_richer(GraphManagerNew * graph_man, ofstream& myfile, int nid, set<int>& drawn_nodes, color_triple_new color, string node_style, string border_color, int penwidth) {

    std::string repid = get_rep_id_from_nid(nid);
    std::string type = get_node_type(nid);
    string delim = "\\n";
    
    // -- changed by Sukanya on 6 Feb 2018
    vector<string> all_id_vec = get_all_ids_of_node(nid);
    vector<string> all_display_ids;
    for (auto i = all_id_vec.begin(); i != all_id_vec.end(); i++) {
        all_display_ids.push_back(graph_man->kegg_hsa_id_to_display_name_map[*i]);
    }
    std::string display_names = concatenate_strings(all_display_ids, ", ");
    
    
    //std::string display_names = concatenate_strings(get_all_display_ids_of_node(nid), ", ");
    std::string all_ids = concatenate_strings(get_all_ids_of_node(nid), delim);
    //std::vector<std::string> all_id_vec = get_all_ids_of_node(nid);

    // --
    
    // strip compartment information from display name
    //    string::size_type open_brac;
    //    open_brac = display_names.find("[", 0);
    //    display_names = display_names.substr(0, open_brac-1);
    //    


    if (type == "compound") {
        myfile << nid << " [shape = circle, style = filled, penwidth=2, tooltip = \"" << display_names << "\"," << " label = \"" << get_all_display_ids_of_node(nid)[0] << "\\n(" + all_ids + ")" << "\"";
    } else if (type == "group") {
        //cout << "Do I xdot groups" << endl;
        myfile << nid << " [shape = rectangle, style = filled, tooltip = \"" << display_names << "\"," << " label = \"" << get_all_display_ids_of_node(nid)[0] << "\\n(" + all_ids + ")" << "\"";
    } else if (type == "phenotype") {
        myfile << nid << " [shape = house, style = filled, penwidth=2, peripheries=2, tooltip = \"" << display_names << "\"," << " label = \"" << display_names << "\"";
    } else if (type == "reaction") {
        std::string desc = get_description_for_node(nid);
        myfile << nid << " [ shape = rectangle, style = filled, height = 0.2, width = 1, tooltip = \"" << desc << "\"," << " label = <<font color=\"grey\" point-size=\"12\">" << display_names << "</font>>, URL = \"http://www.reactome.org/content/detail/" << display_names << "\", style = \"rounded, filled\", color = orange ";
        //myfile << nid << " [shape = square, penwidth=2, peripheries=2, label = \"" << display_names + "\\n(" + all_ids + ")" << "\"";
    } else {
        //myfile << nid << " [style = \"rounded, filled\", color = grey, margin = 0.05, shape = box, tooltip = \"" << display_names << "\"," << " label = \"" << display_names + "\\n(" + all_ids + ")" << "\"";
        myfile << nid << " [style = \"rounded, filled, " << node_style << "\", color = \"" << border_color << "\", penwidth = " << penwidth << ", margin = 0.05, shape = box, height = 1, width = 2, tooltip = \"" << display_names << "\"," << " label = " <<
                "< <TABLE BORDER=\"0\" CELLBORDER=\"0\" CELLSPACING=\"0\"> " <<




                ////"<TR><TD>" << "[" << nid << "] " << get_all_display_ids_of_node(nid)[0] << "</TD></TR>" << endl;
                "<TR><TD>" << all_display_ids[0] << "</TD></TR>" << endl;
        //                for(int i = 0; i < all_id_vec.size(); i++){
        //                    //myfile << "<TR><TD TOOLTIP=\"" << display_names << "\" ";
        //                    string curr_id = all_id_vec.at(i);
        //                    //indiv_ids = split_string_into_list(curr_id, '.');
        //                    
        //                    if(curr_id.substr(0,3) == "hsa"){
        //                        //myfile << "<TR><TD TOOLTIP=\"" << "KEGG: " << curr_id << "\" " << "HREF=\"http://www.genome.jp/dbget-bin/www_bget?" << "hsa:" << curr_id.substr(3) << "\"><FONT POINT-SIZE=\"12\" COLOR=\"grey\">" << "KEGG: " << curr_id << "</FONT></TD></TR>" << endl;
        //                        myfile << "<TR><TD TOOLTIP=\"" << display_names << "\" " << "HREF=\"http://www.genome.jp/dbget-bin/www_bget?" << "hsa:" << curr_id.substr(3) << "\"><FONT POINT-SIZE=\"12\" COLOR=\"grey\">" << "KEGG: " << curr_id << "</FONT></TD></TR>" << endl;
        //                    }
        //                    else if(curr_id.substr(0,7) == "uniprot"){
        //                        myfile << "<TR><TD TOOLTIP=\"" << "UniProt: " << curr_id.substr(8) << "\" " << "HREF=\"http://www.uniprot.org/uniprot/" << curr_id.substr(8) << "\"><FONT POINT-SIZE=\"12\" COLOR=\"grey\">" << "UniProt: " << curr_id.substr(8) << "</FONT></TD></TR>" << endl;
        //                    }
        //                    else if(curr_id.substr(0,8) == "reactome"){
        //                        myfile << "<TR><TD TOOLTIP=\"" << "Reactome: " << curr_id.substr(9) << "\" " << "HREF=\"http://www.reactome.org/content/detail/" << curr_id.substr(9) << "\"><FONT POINT-SIZE=\"12\" COLOR=\"grey\">" << "Reactome: " << curr_id.substr(9) << "</FONT></TD></TR>" << endl;
        //                    }
        //                    else
        //                    {
        //                        myfile << "<TR><TD TOOLTIP=\"" << curr_id << "\" " << "><FONT POINT-SIZE=\"12\" COLOR=\"grey\">" << curr_id << "</FONT></TD></TR>" << endl;
        //                    }
        //                     
        //                }
        myfile << "</TABLE>>" << endl;
    }

    myfile << ", fillcolor = \"#";

    if (color.red < 16) {
        myfile << "0";
    }
    //myfile << hex << color.red;
    std::stringstream stream1;
    stream1 << std::hex << color.red;
    string hex_red(stream1.str());
    myfile << hex_red;
    if (color.green < 16) {
        myfile << "0";
    }
    std::stringstream stream2;
    stream2 << std::hex << color.green;
    string hex_green(stream2.str());
    myfile << hex_green;
    //myfile << hex << color.green;
    if (color.blue < 16) {
        myfile << "0";
    }
    std::stringstream stream3;
    stream3 << std::hex << color.blue;
    string hex_blue(stream3.str());
    myfile << hex_blue;
    //myfile << hex << color.blue;
    myfile << "\"";


    myfile << "];\n";
    drawn_nodes.insert(nid);
}

void GraphNew::write_node_to_dot_file(ofstream& myfile, int nid, set<int>& drawn_nodes, color_triple_new color) {

    std::string type = get_node_type(nid);
    string delim = " ";
    std::string display_names = concatenate_strings(get_all_display_ids_of_node(nid), delim);
    std::string all_ids = concatenate_strings(get_all_ids_of_node(nid), delim);

    if (type == "compound") {
        myfile << nid << " [shape = circle, penwidth=2, label = \"" << display_names + "\\n(" + all_ids + ")" << "\"";
    } else if (type == "group") {
        //cout << "Do I xdot groups" << endl;
        myfile << nid << " [shape = hexagon, penwidth=2, peripheries=2, label = \"" << display_names + "\\n(" + all_ids + ")" << "\"";
    } else if (type == "phenotype") {
        myfile << nid << " [shape = house, penwidth=2, peripheries=2, label = \"" << display_names << "\"";
    } else if (type == "reaction") {
        myfile << nid << " [shape = square, penwidth=2, peripheries=2, label = \"" << display_names + "\\n(" + all_ids + ")" << "\"";
    } else {
        myfile << nid << " [shape = box, penwidth=2, label = \"" << display_names + "\\n(" + all_ids + ")" << "\"";
    }


    myfile << ", style = filled, color = black, fillcolor = \"#";

    if (color.red < 16) {
        myfile << "0";
    }
    //myfile << hex << color.red;
    std::stringstream stream1;
    stream1 << std::hex << color.red;
    string hex_red(stream1.str());
    myfile << hex_red;
    if (color.green < 16) {
        myfile << "0";
    }
    std::stringstream stream2;
    stream2 << std::hex << color.green;
    string hex_green(stream2.str());
    myfile << hex_green;
    //myfile << hex << color.green;
    if (color.blue < 16) {
        myfile << "0";
    }
    std::stringstream stream3;
    stream3 << std::hex << color.blue;
    string hex_blue(stream3.str());
    myfile << hex_blue;
    //myfile << hex << color.blue;
    myfile << "\"";


    myfile << "];\n";
    drawn_nodes.insert(nid);
}

void GraphNew::write_file_to_sif(ofstream& myfile, int eid) {


    //cout<<"Inside write file to sif"<<endl;
    int source_id = get_source_node(eid);
    int target_id = get_target_node(eid);


    //string delim = " ";
    //get_all_display_ids_of_node(int nid)
    std::string source_names = get_all_display_ids_of_node(source_id)[0];

    std::string target_names = get_all_display_ids_of_node(target_id)[0];


    string type = get_edge_type(eid);


    myfile << source_names << "\t" << type << "\t" << target_names << endl;

}

void GraphNew::write_node_to_xml_file(int nid, map<int, int>& nid_to_xml_node_id_map, std::ofstream &fout) {
    int xml_id = nid_to_xml_node_id_map[nid];
    vector<string> all_ids = get_all_ids_of_node(nid);
    assert(all_ids.size() > 0);
    string type = get_node_type(nid);
    vector<string> all_dis_names = get_all_display_ids_of_node(nid);
    vector<int> components = get_component_ids_of_node(nid);

    string name = concatenate_strings(all_ids, " ");
    string display_name = concatenate_strings(all_dis_names, ", ");
    vector<int> components_xml_list;

    for (vector<int>::iterator itr = components.begin(); itr != components.end(); ++itr) {
        int xml_nid = nid_to_xml_node_id_map[*itr];
        components_xml_list.push_back(xml_nid);
    }

    fout << "\t<entry id=\"" << xml_id << "\" name=\"" + name << "\" type=\"" + type + "\">" << endl;
    fout << "\t\t<graphics name=\"" + display_name + "\"/>" << endl;
    for (vector<int>::iterator itr = components_xml_list.begin(); itr != components_xml_list.end(); ++itr) {
        fout << "\t\t<component id=\"" << *itr << "\"/>" << endl;
    }
    fout << "\t</entry>" << endl;
}

void GraphNew::write_edge_to_xml_file(int eid, map<int, int>& nid_to_xml_node_id_map, std::ofstream &fout) {
    int source_id = get_source_node(eid);
    int target_id = get_target_node(eid);

    int source_id_xml = nid_to_xml_node_id_map[source_id];
    int target_id_xml = nid_to_xml_node_id_map[target_id];

    vector<string> pathways = get_all_pathways_for_edge(eid);
    string concatenated_pathways = concatenate_strings(pathways, " ");

    string type = get_edge_type(eid);
    vector<string> subtypes = get_edge_subtypes_of_edge(eid);

    //fout << "\t<relation entry1=\"" << source_id_xml <<"\" entry2=\"" << target_id_xml << "\" type=\""+type+"\">"<< endl;
    fout << "\t<relation entry1=\"" << source_id_xml << "\" entry2=\"" << target_id_xml << "\" type=\"" + type << "\" pathways=\"" << concatenated_pathways + "\">" << endl;
    for (vector<string>::iterator itr = subtypes.begin(); itr != subtypes.end(); ++itr) {
        fout << "\t\t<subtype name=\"" + *itr + "\"/>" << endl;
    }
    fout << "\t</relation>" << endl;
}

void GraphNew::write_node_to_grml_file(int nid, map<int, int>& nid_to_ml_node_id_map, std::ofstream &fout, string color_map_filename, int fold_change) {

    //int ml_id = nid_to_ml_node_id_map[nid];

    int degree = 0;

    vector<int> outlist = get_outlist(nid);
    vector<int> inlist = get_inlist(nid);

    for (vector<int>::iterator vec_itr = outlist.begin(); vec_itr != outlist.end(); vec_itr++) {
#ifdef ONLY_INTERAC_EDGES_FOR_MINCUT
        if (!NOT_INTERAC_EDGE(this, *vec_itr))
#endif
            degree++;
    }

    for (vector<int>::iterator vec_itr = inlist.begin(); vec_itr != inlist.end(); vec_itr++) {
#ifdef ONLY_INTERAC_EDGES_FOR_MINCUT
        if (!NOT_INTERAC_EDGE(this, *vec_itr))
#endif
            degree++;
    }


    std::string dis_names = get_all_display_ids_of_node(nid)[0];
    std::string dis_types = get_node_type(nid);
    //std::string rep = "[" + IntToString(degree) + "] " + get_rep_id_from_nid(nid);
    std::string rep = get_rep_id_from_nid(nid);



    //********************color*******************



    map<int, color_triple_new> node_color_map;
    map<int, color_triple_new>::iterator color_itr;


    int redValue, greenValue, blueValue;
    string node_id;
    color_triple_new color;
    if (color_map_filename != "0") {

        ifstream ifs(color_map_filename.c_str());


        if (!ifs.is_open()) {
            cerr << "Error: the color file " + color_map_filename + " couldn't be opened. Returning without displaying..." << endl;
            return;
        }
        while (ifs >> node_id) {
            //cout<< node_id;
            ifs >> redValue;

            //cout<< redValue;
            ifs >> greenValue;
            ifs >> blueValue;
            /*if(rep==node_id)
              {
              color_triple_new color(redValue, greenValue, blueValue);
              }*/

            /*string rep_id = get_rep_id_from_id(node_id);
              if (rep_id != "") 
              {
              int nid1 = get_nid_from_rep_id(rep_id);
              node_color_map.insert(pair<int, color_triple_new>(nid1, color));
              }*/

            string id = get_rep_id_from_id(node_id); // added by sukanya

            //if(rep==node_id) // changed by sukanya
            if (rep == id) {
                color.red = redValue;
                color.green = greenValue;
                color.blue = blueValue;

            }

        }
    }


    //color_triple_new color;






    /*set<int> drawn_nodes;
      vector<set<int> > undirected_edges;

      for (vector<int>::iterator itr = NIDSg.begin(); itr != NIDSg.end(); itr++)
    //itr points to begin of NIDSg until NIDSg doesnt end
    {
    set<int>::iterator drawn_nodes_itr = drawn_nodes.find(*itr); 
    //drawn_nodes is the size , *itr points to nids

    if (drawn_nodes_itr == drawn_nodes.end())
    {//a node not already written
    // get color of node
    color_triple_new color;
    /*color_itr = node_color_map.find(*itr);
    if (color_itr != node_color_map.end())*/
    /*if(rep==node_id)
      {
    /*color.red = (*color_itr).second.red;
    color.green = (*color_itr).second.green;
    color.blue = (*color_itr).second.blue;*/


    /*color.red = redValue;
      color.green = greenValue;
      color.blue = blueValue;



      }
      }
      }*/




    //**********************color*************************

    //fout<<"\t\t<node id=\""<<nid<<"\"> "<<endl;
    //test
    fout << "\t\t<node id=\"" << dis_names << "\"> " << endl; //test


    //std::string delim = " ";
    //std::string display_names = concatenate_strings(, delim);
    vector<string> dispname = get_all_display_ids_of_node(nid);
    fout << "\t\t\t\t<data key=\"Description\">";
    for (vector<string>::iterator itr = dispname.begin(); itr != dispname.end(); ++itr) {



        fout << *itr << endl;

    }
    fout << "\t\t\t\t</data> " << endl;

    //fout<<"\t\t\t\t<data key=\"Name\">"<<dis_names<<"</data>"<<endl;


    //coloring based on name for node (colormap file provided by user)

    fout << "\t\t\t\t<data key=\"Type\">" << dis_types << "</data>" << endl;
    fout << "\t\t\t\t<data key=\"Label\">" << rep << "</data>" << endl;
    fout << "\t\t\t\t<data key=\"Degree\">" << degree << "</data>" << endl;
    fout<<"\t\t\t\t<data key=\"LogFold\">"<< fold_change <<"</data>"<<endl;

    fout << "\t\t\t\t<data key=\"Name\">" << nid << "</data>" << endl; //test
    //shape based on type 
    if (dis_types == "gene") {
        fout << "\t\t\t\t<data key=\"Shape\">" << " rectangle " << "</data>" << endl;
    } else if (dis_types == "compound") {
        fout << "\t\t\t\t<data key=\"Shape\">" << " circle " << "</data>" << endl;
    } else if (dis_types == "group") {
        fout << "\t\t\t\t<data key=\"Shape\">" << " hexagon " << "</data>" << endl;
    }

    fout << "\t\t\t\t<data key =\"ncolor\">";
    //fout<<"\t\t\t\t\t<y:GenericNode>"<<endl;

    //fout<<"\t\t\t\t\t<y:NodeLabel >"<<dis_names<<"</y:NodeLabel>"<<endl;






    //fout<<"\t\t\t\t\t\t<y:Fill color = \"#";
    fout << "#";


    //color_triple_new color;    
    if (color.red < 16) {
        fout << "0";

    }

    //myfile << hex << color.red;
    std::stringstream stream1;
    stream1 << std::hex << color.red;

    //cout << color.red<<endl;

    string hex_red(stream1.str()); //red component
    fout << hex_red;
    //cout << hex_red<<endl;
    if (color.green < 16) {
        fout << "0";
    }
    std::stringstream stream2;
    stream2 << std::hex << color.green;
    string hex_green(stream2.str()); //green component
    fout << hex_green;
    //myfile << hex << color.green;
    if (color.blue < 16) {
        fout << "0";
    }
    std::stringstream stream3;
    stream3 << std::hex << color.blue;
    string hex_blue(stream3.str()); //hexblue has blue component
    fout << hex_blue;
    //myfile << hex << color.blue;
    //fout << "\" transparent=\"false\"/>"<<endl;
    //fout << "\t\t\t\t\t</y:GenericNode>"<<endl;
    fout << "</data>" << endl;

    //function
    //<data key="d8">http://www.google.com</data>


    fout << "\t\t</node>" << endl;






}

void GraphNew::write_edge_to_grml_file(int eid, map<int, int>& eid_to_ml_edge_id_map, std::ofstream &fout, std::string nme) {

    //int num_of_pathways = get_all_pathways_for_edge(eid).size();

    int source_id = get_source_node(eid);
    int target_id = get_target_node(eid);

    string source_name = get_all_display_ids_of_node(source_id)[0];
    string target_name = get_all_display_ids_of_node(target_id)[0];
    //std::string eds_names = get_all_display_ids_of_node(source_id)[0];
    //std::string edt_names = get_all_display_ids_of_node(target_id)[0];

    string label; // = "[" + IntToString(num_of_pathways) + "] ";
    string type = get_edge_type(eid);
    int count = 1;
    vector<string> subtypes = get_edge_subtypes_of_edge(eid);
    //fout<<"\t\t<edge source=\""<<source_id<<"\" target=\""<<target_id<<"\"> "<<endl;
    fout << "\t\t<edge source=\"" << source_name << "\" target=\"" << target_name << "\"> " << endl;
    fout << "\t\t\t\t<data key=\"Relation\">" << type << "</data>" << endl;
    fout << "\t\t\t\t<data key=\"int\">" << source_name << " " << target_name << "</data>" << endl;
    fout << "\t\t\t\t<data key=\"Name\">" << source_name << " " << target_name << "</data>" << endl; // added by sukanya on 5 Aug 2016
    fout << "\t\t\t\t<data key=\"ID\">" << eid << "</data>" << endl;
    fout << "\t\t\t\t<data key=\"Weight\">" << get_all_pathways_for_edge(eid).size() << "</data>" << endl;
    fout << "\t\t\t\t<data key=\"Type\">";
    for (vector<string>::iterator itr = subtypes.begin(); itr != subtypes.end(); ++itr) {
        {
            if (*itr == "association") {
                label = " assoc";
            } else if (*itr == "dissociation") {
                label = " dissoc";
            } else if (*itr == "component") {
                label = " comp";
            } else if (*itr == "inhibition") {

                label = "inhb ";
            } else if (*itr == "repression") {

                label = "repr ";
            } else if (*itr == "activation") {
                label = "actv ";
            } else if (*itr == "expression") {
                label = "expr ";
            } else if (*itr == "dephosphorylation") {
                label = "-p ";
            } else if (*itr == "phosphorylation") {
                label = "+p ";
            } else if (*itr == "PPI") {
                label = "PPI ";
            } else if (*itr == "indirect") {
                label = "indirect ";
            } else {
                label = "Undefined ";
            }
        }


        fout << label;

    }
    fout << "</data>" << endl;

    fout << "\t\t\t\t<data key = \"ecolor\">";
    fout << "#";
    int gate;
    //fout<<"\t\t\t\t\t<y:PolyLineEdge>"<<endl;
    for (vector<string>::iterator itr = subtypes.begin(); itr != subtypes.end(); ++itr) {
        if (gate != 1) {
            gate = 1;
            if (*itr == "mapping") {
                fout << "FF9933";
            } else {
                fout << "800000";
            }
        }

    }
    fout << "\t\t\t\t</data>" << endl;
    for (vector<string>::iterator itr = subtypes.begin(); itr != subtypes.end(); ++itr) {
        {
            if (*itr == "inhibition") {
                fout << "\t\t\t\t<data key=\"arrow\">T</data>" << endl;
            } else if (*itr == "repression") {
                fout << "\t\t\t\t<data key=\"arrow\">T</data>" << endl;
            } else if (*itr == "association") {
                fout << "\t\t\t\t<data key=\"arrow\">None</data>" << endl;
            } else if (*itr == "dissociation") {
                fout << "\t\t\t\t<data key=\"arrow\">None</data>" << endl;
            } else if (*itr == "mapping") {
                fout << "\t\t\t\t<data key=\"arrow\">None</data>" << endl;
            } else if (*itr == "component") {
                fout << "\t\t\t\t<data key=\"arrow\">None</data>" << endl;
            } else {
                fout << "\t\t\t\t<data key=\"arrow\">Arrow</data>" << endl;
            }
        }

    }
    for (vector<string>::iterator itr = subtypes.begin(); itr != subtypes.end(); ++itr) {
        if (*itr == "mapping") {
            fout << "\t\t\t\t<data key=\"Style\">Dash</data>";
        } else if (*itr == "indirect") {
            fout << "\t\t\t\t<data key=\"Style\">Dash</data>";
        } else {
            fout << "\t\t\t\t<data key=\"Style\">Solid</data>";
        }
    }
    //fout<<"\t\t\t\t\t</y:PolyLineEdge>"<<endl;


    /*fout<<"\t\t\t\t<data key=\"Pathway\">";
      for (unordered_map<int, EdgeNew *>::iterator edge_map_itr = eid_to_edge_map.begin(); edge_map_itr != eid_to_edge_map.end(); ++edge_map_itr) {
      vector<string> edge_pathways = edge_map_itr->second->get_pathways();
      print_vector(edge_pathways, fout);
      }
      fout<<"\t\t\t\t</data>"<<endl;
      fout<<"\t\t</edge>"<<endl;
     */
    int gid = get_graph_id();
    if (nme != "") {
        //sukanya
        // extract only the file name from the string nme
        std::size_t found = nme.find_last_of("/\\");
        string filename_str = nme.substr(found + 1);
        fout << "\n<data key=\"URL\">http://www.cfdvs.iitb.ac.in/sukanya/ghtree/html/" << filename_str << "#" << eid << "</data>" << endl;
    }

    fout << "\t\t</edge>" << endl;






}

void GraphNew::write_node_to_gml_file(int nid, map<int, int>& nid_to_ml_node_id_map, std::ofstream &fout) {

    int ml_id = nid_to_ml_node_id_map[nid];

    std::string dis_names = get_all_display_ids_of_node(nid)[0];

    std::string n_type = get_node_type(ml_id);

    fout << "\t\tnode [" << endl;
    fout << "\t\t\t\tid " << nid << endl;
    fout << "\t\t\t\tlabel " << dis_names << endl;
    fout << "\t\t\t\ttype " << n_type << endl;
    fout << "\t\t]" << endl;
}

void GraphNew::write_edge_to_gml_file(int eid, map<int, int>& eid_to_ml_edge_id_map, std::ofstream &fout) {


    int source_id = get_source_node(eid);
    int target_id = get_target_node(eid);

    int source_id_ml = eid_to_ml_edge_id_map[source_id];
    int target_id_ml = eid_to_ml_edge_id_map[target_id];



    string type = get_edge_type(eid);


    fout << "\t\tedge [" << endl;
    fout << "\t\t\t\tsource " << source_id << endl;
    fout << "\t\t\t\ttarget " << target_id << endl;
    fout << "\t\t\t\tType " << type << endl;
    fout << "\t\t]" << endl;


}

void GraphNew::print_all_graph_info() {
    string file_name;
    cout << "Enter the file to store all graph information" << endl;
    cin >> file_name;
    ofstream fout(file_name.c_str());

    if (fout.is_open()) {
        fout << "Graph Id: " << graph_id << endl;
        fout << "All node ids\n";
        print_vector(NIDSg, fout);
        fout << endl;
        fout << "All edge ids\n";
        print_vector(EIDSg, fout);
        fout << endl;
        fout << "Nodes Info:\n";
        for (unordered_map<int, NodeNew *>::iterator node_map_itr = nid_to_node_map.begin(); node_map_itr != nid_to_node_map.end(); ++node_map_itr) {
            fout << "node id as key: " << node_map_itr->first << endl;
            fout << "node id in NodeNew data struct: " << node_map_itr->second->get_node_id() << endl;
            fout << "rep id: " << node_map_itr->second->get_rep_id() << endl;
            vector<string> all_ids = node_map_itr->second->get_all_id();
            fout << "all ids: ";
            print_vector(all_ids, fout);
            fout << "node type: " << node_map_itr->second->get_node_type() << endl;
            vector<int> all_comps = node_map_itr->second->get_comp_ids();
            fout << "component ids: ";
            print_vector(all_comps, fout);
            vector<string> all_dis_names = node_map_itr->second->get_disp_ids();
            fout << "all dis names: ";
            print_vector(all_dis_names, fout);
            vector<int> all_inlists = node_map_itr->second->get_inlist();
            fout << "inlist: ";
            print_vector(all_inlists, fout);
            vector<int> all_outlists = node_map_itr->second->get_outlist();
            fout << "outlist: ";
            print_vector(all_outlists, fout);
            fout << endl;
        }
        fout << endl << endl;
        fout << "Edges Info:\n";
        for (unordered_map<int, EdgeNew *>::iterator edge_map_itr = eid_to_edge_map.begin(); edge_map_itr != eid_to_edge_map.end(); ++edge_map_itr) {
            fout << "edge id as key: " << edge_map_itr->first << endl;
            fout << "edge id in EdgeNew data struct: " << edge_map_itr->second->get_edge_id() << endl;
            fout << "edge source: " << edge_map_itr->second->get_source() << "(" << get_rep_id_from_nid(edge_map_itr->second->get_source()) << ")" << endl;
            fout << "edge target: " << edge_map_itr->second->get_target() << "(" << get_rep_id_from_nid(edge_map_itr->second->get_target()) << ")" << endl;
            fout << "edge type: " << edge_map_itr->second->get_edge_type() << endl;
            vector<string> edge_subtypes = edge_map_itr->second->get_edge_subtypes();
            fout << "edge subtypes: ";
            print_vector(edge_subtypes, fout);
            vector<string> edge_pathways = edge_map_itr->second->get_pathways();
            fout << "edge pathways: ";
            print_vector(edge_pathways, fout);
            fout << endl;
        }
        fout << endl << endl;
        fout << "rep_id to nid map" << endl;
        print_map(rep_id_to_nid_map, fout);
        fout << endl << endl;
        fout << "id to rep_id map" << endl;
        print_map(id_to_rep_id_map, fout);
        fout << endl << endl;
    } else {
        cerr << "File " + file_name + " couldn't be opened" << endl;
    }
}

//void GraphNew::print_all_graph_info(){
//	string file_name;
//	cout << "Enter the file to store all graph information" << endl;
//	cin >> file_name;
//	ofstream fout(file_name.c_str());
//
//	if(fout.is_open()){
//		fout << "Graph Id: " << graph_id << endl;
//		fout << "All node ids\n";
//		print_vector(NIDSg, fout);
//		fout << endl;
//		fout << "All edge ids\n";
//		print_vector(EIDSg, fout);
//		fout << endl;
//		fout << "Id to rep id map\n";
//		print_map(id_to_rep_id_map, fout);
//		fout << endl;
//		fout << "node_id_to_all_id_map\n";
//		print_map2(node_id_to_all_id_map, fout);
//		fout << endl;
//		fout << "components\n";
//		print_map2(components, fout);
//		fout << endl;
//		fout << "node_id_to_display_name_map\n";
//		print_map2(node_id_to_display_name_map, fout);
//		fout << endl;
//		fout << "node type\n";
//		print_map(node_type, fout);
//		fout << endl;
//		fout << "edge type\n";
//		print_map(edge_type, fout);
//		fout << endl;
//		fout << "edge_subtypes\n";
//		print_map2(edge_subtypes, fout);
//		fout << endl;
//		fout << "edge_belongs_to_pathways\n";
//		print_map2(edge_belongs_to_pathways, fout);
//		fout << endl;
//		fout << "edge_source map\n";
//		print_map(edge_source, fout);
//		fout << endl;
//		fout << "edge_target map\n";
//		print_map(edge_target, fout);
//		fout << endl;
//		fout << "edge_inlist map\n";
//		print_map2(inlist, fout);
//		fout << endl;
//		fout << "edge_outlist map\n";
//		print_map2(outlist, fout);
//		fout << endl;
//		fout.close();
//	}
//	else{
//		cerr << "File " + file_name + " couldn't be opened" << endl;
//	}
//}

std::set<std::string> GraphNew::get_all_target_rep_ids() {
    set<string> all_targets;
    for (vector<int>::iterator itr = EIDSg.begin(); itr != EIDSg.end(); ++itr) {
        string target_node_rid = get_rep_id_from_nid(get_target_node(*itr));
        all_targets.insert(target_node_rid);

    }
    return all_targets;
}

std::set<std::string> GraphNew::get_all_gerel_target_rep_ids() {
    set<string> gerel_targets;
    for (vector<int>::iterator itr = EIDSg.begin(); itr != EIDSg.end(); ++itr) {
        //There might be buggy KEGG xml files where type is GErel but subtype is neither expression nor repression -- such buggy GErel edges are not picked
        if (get_edge_type(*itr) == "GErel" && (edge_has_subtype(*itr, "expression") || edge_has_subtype(*itr, "repression"))) {
            string target_node_rid = get_rep_id_from_nid(get_target_node(*itr));
            gerel_targets.insert(target_node_rid);
        }
    }
    return gerel_targets;
}

void GraphNew::print_GErel_edges() {
    string filename;
    cout << "Enter file path to which to write GErel edges" << endl;
    cin >> filename;

    ofstream fout(filename.c_str());

    if (fout.is_open()) {
        for (vector<int>::iterator itr = EIDSg.begin(); itr != EIDSg.end(); ++itr) {
            if (get_edge_type(*itr) == "GErel") {
                string source_node_rid = get_rep_id_from_nid(get_source_node(*itr));
                string target_node_rid = get_rep_id_from_nid(get_target_node(*itr));
                if (edge_has_subtype(*itr, "expression")) {
                    fout << source_node_rid << " over-expresses " << target_node_rid << endl;
                } else if (edge_has_subtype(*itr, "repression")) {
                    fout << source_node_rid << " represses " << target_node_rid << endl;
                } else {
                    cerr << "Error: GErel edge which is neither expression or repression is found from " + source_node_rid + " to " + target_node_rid << endl;
                    fout << "Error: GErel edge which is neither expression or repression is found from " + source_node_rid + " to " + target_node_rid << endl;
                }
            }
        }
        fout.close();
    } else {
        cerr << "File " + filename + " couldn't be opened" << endl;
    }
}

void GraphNew::print_GErel_targets() {
    string filename;
    cout << "Enter file path to which to write GErel edges" << endl;
    cin >> filename;
    ofstream fout(filename.c_str());

    if (fout.is_open()) {
        set<string> gerel_targets = get_all_gerel_target_rep_ids();
        for (set<string>::iterator itr = gerel_targets.begin(); itr != gerel_targets.end(); ++itr) {
            fout << *itr << endl;
        }
        fout.close();
    } else {
        cerr << "File " + filename + " couldn't be opened" << endl;
    }
}


//void GraphNew::write_microarr_assert_to_file(){
//	string up_reg_filename, down_reg_filename, assert_file;
//	cout << "\nEnter file for up regulated entries: ";
//	cin >> up_reg_filename;
//	cout << "\nEnter file for down regulated entries: ";
//	cin >> down_reg_filename;
//
//	string id;
//	ifstream ifs_up(up_reg_filename.c_str()), ifs_down(down_reg_filename.c_str());
//	set<string> up_reg_rep_ids, down_reg_rep_ids;
//	set<string> gerel_target_repids = get_all_gerel_target_rep_ids();
//	if(!ifs_up.is_open()){
//		cerr << "Error: file " + up_reg_filename + " can't be opened, returning without any microarray assertions..." << endl;
//		return;
//	}
//	if(!ifs_down.is_open()){
//		cerr << "Error: file " + down_reg_filename + " can't be opened, returning without any microarray assertions..." << endl;
//		return;
//	}
//	while (ifs_up >> id) {
//		string repid = get_rep_id_from_id(id);
//		if(repid != ""){
//			up_reg_rep_ids.insert(repid);
//		}
//	}
//	ifs_up.close();
//	while (ifs_down >> id) {
//		string repid = get_rep_id_from_id(id);
//		if(repid != ""){
//			down_reg_rep_ids.insert(repid);
//		}
//	}
//	ifs_down.close();
//
//	//Entities both up and down regulated
//	set<string> up_and_down_reg;
//	set_intersection(up_reg_rep_ids.begin(), up_reg_rep_ids.end(), down_reg_rep_ids.begin(), down_reg_rep_ids.end(), inserter(up_and_down_reg, up_and_down_reg.begin()));
//
//	if(!up_and_down_reg.empty()){
//		cout << "Note: There are " << up_and_down_reg.size() << " genes that are both upregulated and downregulated in the microarray data. Ignoring such common genes in constraint solving." << endl;
//	}
//
//	//remove such common entries
//	set<string> up_reg_minus_common, down_reg_minus_common;
//	set_difference(up_reg_rep_ids.begin(), up_reg_rep_ids.end(), up_and_down_reg.begin(), up_and_down_reg.end(), inserter(up_reg_minus_common, up_reg_minus_common.begin()));
//	set_difference(down_reg_rep_ids.begin(), down_reg_rep_ids.end(), up_and_down_reg.begin(), up_and_down_reg.end(), inserter(down_reg_minus_common, down_reg_minus_common.begin()));
//
//	// Entities up regulated common with graph GErel targets
//	set<string> up_reg_in_graph;
//	set_intersection(up_reg_minus_common.begin(), up_reg_minus_common.end(), gerel_target_repids.begin(), gerel_target_repids.end(), inserter(up_reg_in_graph, up_reg_in_graph.begin()));
//
//	// Entities down regulated common with graph
//	set<string> down_reg_in_graph;
//	set_intersection(down_reg_minus_common.begin(), down_reg_minus_common.end(), gerel_target_repids.begin(), gerel_target_repids.end(), inserter(down_reg_in_graph, down_reg_in_graph.begin()));
//
//	//Entries not differentially expressed in the graph
//	set<string> graph_unchanged_entities, temp;
//	set_difference(gerel_target_repids.begin(), gerel_target_repids.end(), up_reg_in_graph.begin(), up_reg_in_graph.end(), inserter(temp, temp.begin()));
//	set_difference(temp.begin(), temp.end(), down_reg_in_graph.begin(), down_reg_in_graph.end(), inserter(graph_unchanged_entities, graph_unchanged_entities.end()));
//
//	cout << "\nEnter the file to which to write microarray nodes assertions: ";
//	cin >> assert_file;
//
//	ofstream fout_assert(assert_file.c_str());
//	if(fout_assert.is_open()){
//		set<string>::iterator itr_set;
//		// up regulated nodes present in the graph
//		for(itr_set = up_reg_in_graph.begin(); itr_set != up_reg_in_graph.end(); itr_set++){
//			fout_assert << "(assert " << (*itr_set) << "_expression_changes)" << endl;
//			fout_assert << "(assert " << (*itr_set) << "_over_expressed)" << endl;
//		}
//
//		// down regulated nodes present in the graph
//		for(itr_set = down_reg_in_graph.begin(); itr_set != down_reg_in_graph.end(); itr_set++){
//			fout_assert << "(assert " << (*itr_set) << "_expression_changes)" << endl;
//			fout_assert << "(assert (not " << (*itr_set) << "_over_expressed))" << endl;
//		}
//
//		// unchanged nodes in the graph
//		for(itr_set = graph_unchanged_entities.begin(); itr_set != graph_unchanged_entities.end(); itr_set++){
//			fout_assert << "(assert (not " << (*itr_set) << "_expression_changes))" << endl;
//		}
//
//		fout_assert.close();
//	}
//	else{
//		cerr << "Error: file " + assert_file + " can't be opened, returning without any microarray assertions..." << endl;
//		return;
//	}
//}

void GraphNew::write_microarr_assert_to_file() {
    string up_reg_filename, down_reg_filename, assert_file;
    cout << "\nEnter file for up regulated entries: ";
    cin >> up_reg_filename;
    cout << "\nEnter file for down regulated entries: ";
    cin >> down_reg_filename;

    string id;
    ifstream ifs_up(up_reg_filename.c_str()), ifs_down(down_reg_filename.c_str());
    set<string> up_reg_rep_ids, down_reg_rep_ids;
    set<string> gerel_target_repids = get_all_gerel_target_rep_ids();
    //set<string> all_rep_ids_in_graph = gerel_target_repids;
    set<string> all_rep_ids_in_graph = get_all_target_rep_ids();
    // temporary -- 
    //        gerel_target_repids.clear();
    //        gerel_target_repids = all_rep_ids_in_graph;
    //        cout << gerel_target_repids.size() << endl;
    // --
    if (!ifs_up.is_open()) {
        cerr << "Error: file " + up_reg_filename + " can't be opened, returning without any microarray assertions..." << endl;
        return;
    }
    if (!ifs_down.is_open()) {
        cerr << "Error: file " + down_reg_filename + " can't be opened, returning without any microarray assertions..." << endl;
        return;
    }
    while (ifs_up >> id) {
        string repid = get_rep_id_from_id(id);
        if (repid != "") {
            up_reg_rep_ids.insert(repid);
        }
    }
    ifs_up.close();
    while (ifs_down >> id) {
        string repid = get_rep_id_from_id(id);
        if (repid != "") {
            down_reg_rep_ids.insert(repid);
        }
    }
    ifs_down.close();

    //Entities both up and down regulated
    set<string> up_and_down_reg;
    set_intersection(up_reg_rep_ids.begin(), up_reg_rep_ids.end(), down_reg_rep_ids.begin(), down_reg_rep_ids.end(), inserter(up_and_down_reg, up_and_down_reg.begin()));

    if (!up_and_down_reg.empty()) {
        cout << "Note: There are " << up_and_down_reg.size() << " genes that are both upregulated and downregulated in the microarray data. Ignoring such common genes in constraint solving." << endl;
    }

    //remove such common entries
    set<string> up_reg_minus_common, down_reg_minus_common;
    set_difference(up_reg_rep_ids.begin(), up_reg_rep_ids.end(), up_and_down_reg.begin(), up_and_down_reg.end(), inserter(up_reg_minus_common, up_reg_minus_common.begin()));
    set_difference(down_reg_rep_ids.begin(), down_reg_rep_ids.end(), up_and_down_reg.begin(), up_and_down_reg.end(), inserter(down_reg_minus_common, down_reg_minus_common.begin()));
    cout << "Up regulated genes: " << up_reg_minus_common.size() << endl;
    cout << "Down regulated genes: " << down_reg_minus_common.size() << endl;

    // Entities up and down regulated common with graph
    set<string> all_up_reg_in_graph, all_down_reg_in_graph;
    set_intersection(up_reg_minus_common.begin(), up_reg_minus_common.end(), all_rep_ids_in_graph.begin(), all_rep_ids_in_graph.end(), inserter(all_up_reg_in_graph, all_up_reg_in_graph.begin()));
    set_intersection(down_reg_minus_common.begin(), down_reg_minus_common.end(), all_rep_ids_in_graph.begin(), all_rep_ids_in_graph.end(), inserter(all_down_reg_in_graph, all_down_reg_in_graph.begin()));
    cout << "Up regulated as any target: " << all_up_reg_in_graph.size() << endl;
    cout << "Down regulated as any target: " << all_down_reg_in_graph.size() << endl;

    // Entities up regulated common with graph GErel targets
    set<string> up_reg_in_graph;
    set_intersection(up_reg_minus_common.begin(), up_reg_minus_common.end(), gerel_target_repids.begin(), gerel_target_repids.end(), inserter(up_reg_in_graph, up_reg_in_graph.begin()));

    // Entities down regulated common with graph
    set<string> down_reg_in_graph;
    set_intersection(down_reg_minus_common.begin(), down_reg_minus_common.end(), gerel_target_repids.begin(), gerel_target_repids.end(), inserter(down_reg_in_graph, down_reg_in_graph.begin()));
    cout << "Up regulated as GErel targets: " << up_reg_in_graph.size() << endl;
    set<string>::iterator temp_itr;
    for (temp_itr = up_reg_in_graph.begin(); temp_itr != up_reg_in_graph.end(); temp_itr++) {
        cout << (*temp_itr) << " ";
    }
    cout << endl;
    cout << "Down regulated as GErel targets: " << down_reg_in_graph.size() << endl;

    //Entries not differentially expressed in the graph
    set<string> graph_unchanged_entities, temp;
    set_difference(gerel_target_repids.begin(), gerel_target_repids.end(), up_reg_in_graph.begin(), up_reg_in_graph.end(), inserter(temp, temp.begin()));
    //set_difference(all_rep_ids_in_graph.begin(), all_rep_ids_in_graph.end(), up_reg_in_graph.begin(), up_reg_in_graph.end(), inserter(temp, temp.begin()));
    set_difference(temp.begin(), temp.end(), down_reg_in_graph.begin(), down_reg_in_graph.end(), inserter(graph_unchanged_entities, graph_unchanged_entities.end()));

    cout << "\nEnter the file to which to write microarray nodes assertions: ";
    cin >> assert_file;

    ofstream fout_assert(assert_file.c_str());
    if (fout_assert.is_open()) {
        set<string>::iterator itr_set;
        // up regulated nodes present in the graph
        for (itr_set = up_reg_in_graph.begin(); itr_set != up_reg_in_graph.end(); itr_set++) {
            fout_assert << "(assert " << (*itr_set) << "_expression_changes)" << endl;
            fout_assert << "(assert " << (*itr_set) << "_over_expressed)" << endl;
        }

        // down regulated nodes present in the graph
        for (itr_set = down_reg_in_graph.begin(); itr_set != down_reg_in_graph.end(); itr_set++) {
            fout_assert << "(assert " << (*itr_set) << "_expression_changes)" << endl;
            fout_assert << "(assert (not " << (*itr_set) << "_over_expressed))" << endl;
        }

        // unchanged nodes in the graph
        for (itr_set = graph_unchanged_entities.begin(); itr_set != graph_unchanged_entities.end(); itr_set++) {
            fout_assert << "(assert (not " << (*itr_set) << "_expression_changes))" << endl;
        }

        fout_assert.close();
    } else {
        cerr << "Error: file " + assert_file + " can't be opened, returning without any microarray assertions..." << endl;
        return;
    }
}

/*
   void GraphNew::write_microarr_assert_to_file() {
   string up_reg_filename, down_reg_filename, assert_file;
   cout << "\nEnter file for up regulated entries: ";
   cin >> up_reg_filename;
   cout << "\nEnter file for down regulated entries: ";
   cin >> down_reg_filename;

   string id;
   ifstream ifs_up(up_reg_filename.c_str()), ifs_down(down_reg_filename.c_str());
   set<string> up_reg_rep_ids, down_reg_rep_ids;
   set<string> gerel_target_repids = get_all_gerel_target_rep_ids();
   if (!ifs_up.is_open()) {
   cerr << "Error: file " + up_reg_filename + " can't be opened, returning without any microarray assertions..." << endl;
   return;
   }
   if (!ifs_down.is_open()) {
   cerr << "Error: file " + down_reg_filename + " can't be opened, returning without any microarray assertions..." << endl;
   return;
   }
   while (ifs_up >> id) {
   string repid = get_rep_id_from_id(id);
   if (repid != "") {
   up_reg_rep_ids.insert(repid);
   }
   }
   ifs_up.close();
   while (ifs_down >> id) {
   string repid = get_rep_id_from_id(id);
   if (repid != "") {
   down_reg_rep_ids.insert(repid);
   }
   }
   ifs_down.close();

//Entities both up and down regulated
set<string> up_and_down_reg;
set_intersection(up_reg_rep_ids.begin(), up_reg_rep_ids.end(), down_reg_rep_ids.begin(), down_reg_rep_ids.end(), inserter(up_and_down_reg, up_and_down_reg.begin()));

if (!up_and_down_reg.empty()) {
cout << "Note: There are " << up_and_down_reg.size() << " genes that are both upregulated and downregulated in the microarray data. Ignoring such common genes in constraint solving." << endl;
}

//remove such common entries
set<string> up_reg_minus_common, down_reg_minus_common;
set_difference(up_reg_rep_ids.begin(), up_reg_rep_ids.end(), up_and_down_reg.begin(), up_and_down_reg.end(), inserter(up_reg_minus_common, up_reg_minus_common.begin()));
set_difference(down_reg_rep_ids.begin(), down_reg_rep_ids.end(), up_and_down_reg.begin(), up_and_down_reg.end(), inserter(down_reg_minus_common, down_reg_minus_common.begin()));

// Entities up regulated common with graph GErel targets
set<string> up_reg_in_graph;
set_intersection(up_reg_minus_common.begin(), up_reg_minus_common.end(), gerel_target_repids.begin(), gerel_target_repids.end(), inserter(up_reg_in_graph, up_reg_in_graph.begin()));

// Entities down regulated common with graph
set<string> down_reg_in_graph;
set_intersection(down_reg_minus_common.begin(), down_reg_minus_common.end(), gerel_target_repids.begin(), gerel_target_repids.end(), inserter(down_reg_in_graph, down_reg_in_graph.begin()));

//Entries not differentially expressed in the graph
set<string> graph_unchanged_entities, temp;
set_difference(gerel_target_repids.begin(), gerel_target_repids.end(), up_reg_in_graph.begin(), up_reg_in_graph.end(), inserter(temp, temp.begin()));
set_difference(temp.begin(), temp.end(), down_reg_in_graph.begin(), down_reg_in_graph.end(), inserter(graph_unchanged_entities, graph_unchanged_entities.end()));

cout << "\nEnter the file to which to write microarray nodes assertions: ";
cin >> assert_file;

ofstream fout_assert(assert_file.c_str());
if (fout_assert.is_open()) {
set<string>::iterator itr_set;
// up regulated nodes present in the graph
for (itr_set = up_reg_in_graph.begin(); itr_set != up_reg_in_graph.end(); itr_set++) {
fout_assert << "(assert " << (*itr_set) << "_expression_changes)" << endl;
fout_assert << "(assert " << (*itr_set) << "_over_expressed)" << endl;
}

// down regulated nodes present in the graph
for (itr_set = down_reg_in_graph.begin(); itr_set != down_reg_in_graph.end(); itr_set++) {
        fout_assert << "(assert " << (*itr_set) << "_expression_changes)" << endl;
        fout_assert << "(assert (not " << (*itr_set) << "_over_expressed))" << endl;
}

// unchanged nodes in the graph
for (itr_set = graph_unchanged_entities.begin(); itr_set != graph_unchanged_entities.end(); itr_set++) {
        fout_assert << "(assert (not " << (*itr_set) << "_expression_changes))" << endl;
}

fout_assert.close();
} else {
        cerr << "Error: file " + assert_file + " can't be opened, returning without any microarray assertions..." << endl;
        return;
}
}
 */

void GraphNew::write_microarr_decl_to_file() {
    string decl_file;
    cout << "Enter the file to which to write microarray nodes declarations: ";
    cin >> decl_file;
    ofstream fout(decl_file.c_str());

    if (fout.is_open()) {
        ////set<string> gerel_targets = get_all_gerel_target_rep_ids();
        set<string> gerel_targets = get_all_target_rep_ids();
        for (set<string>::iterator itr = gerel_targets.begin(); itr != gerel_targets.end(); ++itr) {

            //int node_id = get_nid_from_rep_id(*itr);
            //if(get_node_type(node_id) != "group"){//this check is temporary - groups can't be seen in microarray data but still we can do something about it later
            string decl1 = "(declare-const " + *itr + "_expression_changes Bool)";
            string decl2 = "(declare-const " + *itr + "_over_expressed Bool)";
            fout << decl1 << endl;
            fout << decl2 << endl;
            //}
        }
        fout.close();
    } else {
        cerr << "Error: can't open file " + decl_file + " for writing microarray declarations\n";
    }
}

//adds edges from components of a complex to the complex with edge subtype component

void GraphNew::add_component_edges_for_complexes_sbml(GraphManagerNew* gm) {
    for (vector<int>::iterator itr = NIDSg.begin(); itr != NIDSg.end(); itr++) {
        NodeNew * node = get_node_from_nid(*itr);
        if (node->get_node_type() == "") {
            std::vector<int> components = node->get_comp_ids();
            std::vector<int>::iterator comp_itr;
            for (comp_itr = components.begin(); comp_itr != components.end(); comp_itr++) {
                int source_node_id = *comp_itr;
                int target_node_id = *itr;
                std::string type = "";
                vector<string> subtype;
                std::string curr_subtype = "component";
                subtype.push_back(curr_subtype);
                std::string pathway = "";
                int eid = check_if_edge_already_created(source_node_id, target_node_id, type, subtype);
                if (eid == -1) {
                    eid = create_new_edge();
                    add_edge_id(eid);
                    gm->add_edge_id_graph_id(eid, get_graph_id());
                    add_edge_type(eid, type);
                    add_edge_to_outlist_of_node(source_node_id, eid);
                    add_edge_to_inlist_of_node(target_node_id, eid);
                    add_source_node(eid, source_node_id);
                    add_target_node(eid, target_node_id);
                    for (vector<string>::iterator subt_itr = subtype.begin(); subt_itr != subtype.end(); subt_itr++) {
                        add_subtype_for_edge(eid, *subt_itr);
                    }
                    add_pathway_for_edge(eid, pathway);
                }
            }
        }
    }
}

//adds edges from components of a complex to the complex with edge subtype component

void GraphNew::add_component_edges_for_complexes(GraphManagerNew* gm) {
    for (vector<int>::iterator itr = NIDSg.begin(); itr != NIDSg.end(); itr++) {
        NodeNew * node = get_node_from_nid(*itr);
        if (node->get_node_type() == "group") {
            std::vector<int> components = node->get_comp_ids();
            std::vector<int>::iterator comp_itr;
            for (comp_itr = components.begin(); comp_itr != components.end(); comp_itr++) {
                int source_node_id = *comp_itr;
                int target_node_id = *itr;
                std::string type = "PPrel";
                vector<string> subtype;
                std::string curr_subtype = "component";
                subtype.push_back(curr_subtype);
                std::vector<std::string> all_pathways = get_all_pathways_for_edge(*(get_edge_ids().begin()));
                int eid = check_if_edge_already_created(source_node_id, target_node_id, type, subtype);
#ifdef DUMMY_EDGE_FLAG                       
                if (eid == -1) {
                    vector<string> subtype_copy = subtype;
                    subtype_copy.push_back("dummy_u_to_d");
                    eid = check_if_edge_already_created(source_node_id, target_node_id, type, subtype_copy);
                }
#endif                
                if (eid == -1) {
                    eid = create_new_edge();
                    add_edge_id(eid);
                    gm->add_edge_id_graph_id(eid, get_graph_id());
                    add_edge_type(eid, type);
                    add_edge_to_outlist_of_node(source_node_id, eid);
                    add_edge_to_inlist_of_node(target_node_id, eid);
                    add_source_node(eid, source_node_id);
                    add_target_node(eid, target_node_id);
                    for (vector<string>::iterator subt_itr = subtype.begin(); subt_itr != subtype.end(); subt_itr++) {
                        add_subtype_for_edge(eid, *subt_itr);
                    }
#ifdef DUMMY_EDGE_FLAG   
                    //if (get_rep_id_from_nid(source_node_id) > get_rep_id_from_nid(target_node_id))
                    add_subtype_for_edge(eid, "dummy_u_to_d");
#endif                     
                    for (std::vector<std::string>::iterator path_itr = all_pathways.begin(); path_itr != all_pathways.end(); path_itr++) {
                        add_pathway_for_edge(eid, *path_itr);
                    }
                }

                // reverse edge
                eid = check_if_edge_already_created(target_node_id, source_node_id, type, subtype);
#ifdef DUMMY_EDGE_FLAG                       
                if (eid == -1) {
                    vector<string> subtype_copy = subtype;
                    subtype_copy.push_back("dummy_u_to_d");
                    eid = check_if_edge_already_created(target_node_id, source_node_id, type, subtype_copy);
                }
#endif                 
                if (eid == -1) {
                    eid = create_new_edge();
                    add_edge_id(eid);
                    gm->add_edge_id_graph_id(eid, get_graph_id());
                    add_edge_type(eid, type);
                    add_edge_to_outlist_of_node(target_node_id, eid);
                    add_edge_to_inlist_of_node(source_node_id, eid);
                    add_source_node(eid, target_node_id);
                    add_target_node(eid, source_node_id);
                    for (vector<string>::iterator subt_itr = subtype.begin(); subt_itr != subtype.end(); subt_itr++) {
                        add_subtype_for_edge(eid, *subt_itr);
                    }
#ifdef DUMMY_EDGE_FLAG   
                    //if (get_rep_id_from_nid(target_node_id) > get_rep_id_from_nid(source_node_id))
                    add_subtype_for_edge(eid, "dummy_u_to_d");
#endif                    
                    //#ifdef DUMMY_EDGE_FLAG                        
                    //                        add_subtype_for_edge(eid, "dummy");
                    //#endif                    
                    for (std::vector<std::string>::iterator path_itr = all_pathways.begin(); path_itr != all_pathways.end(); path_itr++) {
                        add_pathway_for_edge(eid, *path_itr);
                    }

                }
            }
        }
    }
}

//includes edges whose removal can remove cycle
//includes all assoc-dissoc edges because they exist in pairs and thus always cyclic

set<int> GraphNew::edges_to_remove_cycles(vector<string>& source_nodes_set) {
    set<int> edges_to_remove;
    for (vector<string>::iterator itr = source_nodes_set.begin(); itr != source_nodes_set.end(); itr++) {
        string rid = get_rep_id_from_id(*itr);
        if (rid == "") {
            cerr << "Error: one of the source nodes " + *itr << " has no rep id in the graph, ignoring..." << endl;
            continue;
        }
        int nid = get_nid_from_rep_id(rid);
#ifdef ASSERT_FLAG
        assert(nid != -1);
#endif
        if (nid == -1) {
            cerr << "Error: one of the source nodes " + *itr << " has a rep id but no node id for it in the graph.\n You have made a bug in the code -- fix it" << endl;
            exit(1);
        }
        set<int> grey_nodes, black_nodes; //grey_nodes can be thought of as currently in the stack of DFS, while black_nodes are the finally explored nodes
        get_edges_to_remove_cycles_DFS(nid, grey_nodes, black_nodes, edges_to_remove);
    }
    return edges_to_remove;
}

set<int> GraphNew::edges_to_remove_cycles_backwards(vector<string>& target_nodes_set) {
    set<int> edges_to_remove;
    for (vector<string>::iterator itr = target_nodes_set.begin(); itr != target_nodes_set.end(); itr++) {
        string rid = get_rep_id_from_id(*itr);
        if (rid == "") {
            cerr << "Error: one of the source nodes " + *itr << " has no rep id in the graph, ignoring..." << endl;
        }
        int nid = get_nid_from_rep_id(rid);
        if (nid == -1) {
            cerr << "Error: one of the source nodes " + *itr << " has a rep id but no node id for it in the graph.\n You have made a bug in the code -- fix it" << endl;
            exit(1);
        }
        set<int> grey_nodes, black_nodes; //grey_nodes can be thought of as currently in the stack of DFS, while black_nodes are the finally explored nodes
        get_edges_to_remove_cycles_DFS_backwards(nid, grey_nodes, black_nodes, edges_to_remove);
    }
    return edges_to_remove;
}

//grey_nodes can be thought of as currently in the stack of DFS, while black_nodes are the finally explored nodes
//includes edges whose removal can remove cycle
//includes all assoc-dissoc edges because they exist in pairs and thus always cyclic

void GraphNew::get_edges_to_remove_cycles_DFS(int nid, set<int> &grey_nodes, set<int> &black_nodes, set<int>& edges_to_remove) {
    grey_nodes.insert(nid);
    vector<int> out_list = get_outlist(nid);
    for (vector<int>::iterator out_itr = out_list.begin(); out_itr != out_list.end(); ++out_itr) {
        int target_nid = get_target_node(*out_itr);
        bool is_assoc = edge_has_subtype(*out_itr, "association");
        bool is_dissoc = edge_has_subtype(*out_itr, "dissociation");
        bool is_mapping = edge_has_subtype(*out_itr, "mapping");
        //grey node case (cycle found)
        if (grey_nodes.find(target_nid) != grey_nodes.end()) {
            edges_to_remove.insert(*out_itr);
            //if this is assoc or dissoc edge then the there must be its pair in opposite direction - that must be included as well
            if (is_assoc || is_dissoc || is_mapping) {
                vector<int> target_out_list = get_outlist(target_nid);
                for (vector<int>::iterator target_out_itr = target_out_list.begin(); target_out_itr != target_out_list.end(); ++target_out_itr) {
                    if (get_target_node(*target_out_itr) == nid) {
                        if ((is_assoc && edge_has_subtype(*target_out_itr, "association")) || (is_dissoc && edge_has_subtype(*target_out_itr, "dissociation")) || (is_dissoc && edge_has_subtype(*target_out_itr, "mapping"))) {
                            edges_to_remove.insert(*target_out_itr);
                        }
                    }
                }
            }
            //cout << "cycle complete with edge from " << get_rep_id_from_nid(nid) << "to " << get_rep_id_from_nid(target_nid) << endl;
        }//black node case
        else if (black_nodes.find(target_nid) != black_nodes.end()) {
            //do nothing for black node
        }//white node case
        else {
            get_edges_to_remove_cycles_DFS(target_nid, grey_nodes, black_nodes, edges_to_remove);
        }
    }
    //grey node becomes a black node
    grey_nodes.erase(nid);
    black_nodes.insert(nid);
}

void GraphNew::get_edges_to_remove_cycles_DFS_backwards(int nid, set<int> &grey_nodes, set<int> &black_nodes, set<int>& edges_to_remove) {
    grey_nodes.insert(nid);
    vector<int> in_list = get_inlist(nid);
    for (vector<int>::iterator in_itr = in_list.begin(); in_itr != in_list.end(); ++in_itr) {
        int source_nid = get_source_node(*in_itr);
        bool is_assoc = edge_has_subtype(*in_itr, "association");
        bool is_dissoc = edge_has_subtype(*in_itr, "dissociation");
        bool is_mapping = edge_has_subtype(*in_itr, "mapping");
        //grey node case (cycle found)
        if (grey_nodes.find(source_nid) != grey_nodes.end()) {
            edges_to_remove.insert(*in_itr);
            //if this is assoc or dissoc edge then the there must be its pair in opposite direction - that must be included as well
            if (is_assoc || is_dissoc || is_mapping) {
                vector<int> source_out_list = get_inlist(source_nid);
                for (vector<int>::iterator source_out_itr = source_out_list.begin(); source_out_itr != source_out_list.end(); ++source_out_itr) {
                    if (get_source_node(*source_out_itr) == nid) {
                        if ((is_assoc && edge_has_subtype(*source_out_itr, "association")) || (is_dissoc && edge_has_subtype(*source_out_itr, "dissociation")) || (is_dissoc && edge_has_subtype(*source_out_itr, "mapping"))) {
                            edges_to_remove.insert(*source_out_itr);
                        }
                    }
                }
            }
            //cout << "cycle complete with edge from " << get_rep_id_from_nid(nid) << "to " << get_rep_id_from_nid(target_nid) << endl;
        }//black node case
        else if (black_nodes.find(source_nid) != black_nodes.end()) {
            //do nothing for black node
        }//white node case
        else {
            get_edges_to_remove_cycles_DFS(source_nid, grey_nodes, black_nodes, edges_to_remove);
        }
    }
    //grey node becomes a black node
    grey_nodes.erase(nid);
    black_nodes.insert(nid);
}

void GraphNew::remove_edge(int eid) {
    EdgeNew* edge = get_edge_from_eid(eid);
    if (edge == NULL) {
        cerr << "Error: no edge found with edge id " << eid << endl;
        return;
    }
    int source_id = get_source_node(eid);
    int target_id = get_target_node(eid);
    NodeNew* source_node = get_node_from_nid(source_id);
    NodeNew* target_node = get_node_from_nid(target_id);
    source_node->remove_from_outlist(eid);
    target_node->remove_from_inlist(eid);
    eid_to_edge_map.erase(eid);
    // EIDSg.erase(eid); -- replaced by
    EIDSg.erase(std::find(EIDSg.begin(), EIDSg.end(), eid));

    delete edge;
}

//returns bit sequence of expressions representing distance of a node

std::vector<t_Expression*> GraphNew::get_node_distance_expression_sequence(int nid, t_ExpressionManager* em, GraphManagerNew* gm) {
    TypeOfExpressionTuple te1 = {TYPE_UNSIGNED_BITVECTOR, 1};
    vector<t_Expression*> to_return(NODE_DISTANCE_BIT_SEQ_LENGTH, NULL); //distance variable is bit sequence of length NODE_DISTANCE_BIT_SEQ_LENGTH
    string rid = get_rep_id_from_nid(nid);
    if (rid == "") {
        cerr << "Error: No node of id " << nid << " found, exiting..." << endl;
        exit(1);
    } else {
        //give variables has distance_<rid>_<i>, with i from 0 to NODE_DISTANCE_BIT_SEQ_LENGTH-1 as bits in the distance variables
        for (int i = 0; i < NODE_DISTANCE_BIT_SEQ_LENGTH; ++i) {
            string node_distance_bit_var_indexed = "distance_" + rid + "_" + IntToString(i); //this is the variable name
            t_Expression* expr_node_distance_bit_var_indexed = em->createSymbol(node_distance_bit_var_indexed, te1);
            getExpressionMap[node_distance_bit_var_indexed] = expr_node_distance_bit_var_indexed;
            to_return[i] = expr_node_distance_bit_var_indexed;
            getCNFIndexMap[expr_node_distance_bit_var_indexed] = make_pair(node_distance_bit_var_indexed, -1);
        }
    }
    return to_return;
}

inline bool GraphNew::is_isolated_node(int nid) {
    bool to_return = false;
    NodeNew* node = get_node_from_nid(nid);

    if (node) {
        to_return = (node->get_in_degree() == 0) && (node->get_out_degree() == 0);
    }

    return to_return;
}

void GraphNew::print_nodes_rids_with_no_in_edges(std::ostream &fout) {
    for (vector<int>::iterator nid_itr = NIDSg.begin(); nid_itr != NIDSg.end(); nid_itr++) {
        vector<int> inlist = get_inlist(*nid_itr);
        if (inlist.empty()) {
            string rid = get_rep_id_from_nid(*nid_itr);
            fout << rid << endl;
        }
    }
}

//the vectors source_node_distance_expr_vec and target_node_distance_expr_vec must have the expressions for the bits of the distance, adn the expression_true_bit corresponds to the one bit and must already have been among the aserted constraints
//overflow will give UNSAT and cab checked by reading variables

t_Expression* GraphNew::get_constraint_node_distance_differ_by_one(vector<t_Expression*>& source_node_distance_expr_vec, vector<t_Expression*>& target_node_distance_expr_vec, t_Expression* expression_true_bit, t_ExpressionManager* em, GraphManagerNew* gm) {
    t_Expression* to_return = NULL;
    vector<t_Expression*> to_AND;
    TypeOfExpressionTuple te1 = {TYPE_UNSIGNED_BITVECTOR, 1};

    assert(source_node_distance_expr_vec.size() == NODE_DISTANCE_BIT_SEQ_LENGTH);
    assert(target_node_distance_expr_vec.size() == NODE_DISTANCE_BIT_SEQ_LENGTH);

    //asserting target_dist = source_dist + 1 at bit level
    t_Expression* current_carry = expression_true_bit;
    for (int i = 0; i < NODE_DISTANCE_BIT_SEQ_LENGTH; ++i) {
        t_Expression* current_sum = build_XOR_constraints(source_node_distance_expr_vec[i], current_carry, em);
        t_Expression* current_sum_equals_target_distance = build_EQUIV_constraint(current_sum, target_node_distance_expr_vec[i], em);
        to_AND.push_back(current_sum_equals_target_distance);
        t_Expression* temp = build_AND_constraints(source_node_distance_expr_vec[i], current_carry, 0, 0, em);
        current_carry = temp;
    }

    //overflow can be detected by asserting current_carry to false here
    t_Expression* carry_no_overflow = em->createOneBitExpressionWithOneOperand(em->m_operatorLabelLogNOT, current_carry);
    string distance_no_overflow = "distance_no_over_flow";
    t_Expression* expr_distance_no_overflow = em->createSymbol(distance_no_overflow, te1);
    getCNFIndexMap[expr_distance_no_overflow] = make_pair(distance_no_overflow, -1);
    getExpressionMap[distance_no_overflow] = expr_distance_no_overflow;

    t_Expression* dist_no_over_flow_equiv_carry_no_over_flow = build_EQUIV_constraint(carry_no_overflow, expr_distance_no_overflow, em);

    to_AND.push_back(dist_no_over_flow_equiv_carry_no_over_flow);

    to_return = build_AND_constraints_from_vector(to_AND, em);
    return to_return;
}

//nid_distanc_var_map must have vectors assigned for all nodes

t_Expression* GraphNew::get_constraints_distance_source_target_for_visible_edge(int source_nid, map<int, vector<t_Expression*> >& nid_distanc_var_map, t_Expression* expression_true_bit, t_ExpressionManager* em, GraphManagerNew* gm) {
    t_Expression* to_return = NULL;
    vector<t_Expression*> to_AND;
    TypeOfExpressionTuple te1 = {TYPE_UNSIGNED_BITVECTOR, 1};

    for (vector<int>::iterator edge_itr = EIDSg.begin(); edge_itr != EIDSg.end(); ++edge_itr) {
        int source_id = get_source_node(*edge_itr);
        int target_id = get_target_node(*edge_itr);

        if (target_id != source_nid) {//the perturbed node can't be at one more distance than any other node

            string repid_source_node = get_rep_id_from_nid(source_id);
            string repid_target_node = get_rep_id_from_nid(target_id);
            string edge_type_str = get_edge_type(*edge_itr);
            vector<string> edge_subtype_vec_str = get_edge_subtypes_of_edge(*edge_itr);
            string edge_subtypes_str = gm->get_edge_substring_for_constraint_variable(edge_subtype_vec_str);

            string edge_variable_visible = "edge." + repid_source_node + "to" + repid_target_node + "." + edge_type_str + "-" + edge_subtypes_str + "visible";

            t_Expression* expression_edge_visible = NULL;

            if (getExpressionMap.find(edge_variable_visible) == getExpressionMap.end()) {
                expression_edge_visible = em->createSymbol(edge_variable_visible, te1);
                getExpressionMap[edge_variable_visible] = expression_edge_visible;
                getCNFIndexMap[expression_edge_visible] = make_pair(edge_variable_visible, -1);
            } else {
                expression_edge_visible = getExpressionMap[edge_variable_visible];
            }


            vector<t_Expression*> source_node_distance_expr_vec = nid_distanc_var_map[source_id];
            vector<t_Expression*> target_node_distance_expr_vec = nid_distanc_var_map[target_id];

            t_Expression* expr_source_distance_one_less_target = get_constraint_node_distance_differ_by_one(source_node_distance_expr_vec, target_node_distance_expr_vec, expression_true_bit, em, gm);

            t_Expression* expr_visible_edge_implies_edge_difference = build_OR_constraints(expression_edge_visible, expr_source_distance_one_less_target, 1, 0, em);

            //testing starts
            /*string naming = "distance_source_target_for_visible_edge_" + repid_source_node + "-to-" + repid_target_node;
              ofstream test_fout(naming.c_str());
              em->printExpressionToFileAsDAG(naming, expr_visible_edge_implies_edge_difference, test_fout);
              test_fout.close();*/
            //testing ends

            to_AND.push_back(expr_visible_edge_implies_edge_difference);
            //cout << "Writing distance constraint for edge id " << *edge_itr << " between " + repid_source_node + " and " + repid_target_node << endl;
        }
    }

    to_return = build_AND_constraints_from_vector(to_AND, em);
    return to_return;
}

t_Expression* GraphNew::get_constraints_expr_visible_in_if_out_non_source_node(int source_nid, t_ExpressionManager* em, GraphManagerNew* gm) {
    t_Expression* to_return = NULL;
    vector<t_Expression*> to_AND;
    TypeOfExpressionTuple te1 = {TYPE_UNSIGNED_BITVECTOR, 1};

    for (vector<int>::iterator nid_itr = NIDSg.begin(); nid_itr != NIDSg.end(); nid_itr++) {
        vector<int> outlist = get_outlist(*nid_itr);
        vector<int> inlist = get_inlist(*nid_itr);

        if (*nid_itr != source_nid && !outlist.empty() && !inlist.empty()) {
            //get ORed for inlist edges
            vector<t_Expression*> to_OR;
            for (vector<int>::iterator inlist_itr = inlist.begin(); inlist_itr != inlist.end(); inlist_itr++) {
                int source_id = get_source_node(*inlist_itr);
                string repid_source_node = get_rep_id_from_nid(source_id);
                string repid_target_node = get_rep_id_from_nid(*nid_itr);
                string edge_type_str = get_edge_type(*inlist_itr);
                vector<string> edge_subtype_vec_str = get_edge_subtypes_of_edge(*inlist_itr);
                string edge_subtypes_str = gm->get_edge_substring_for_constraint_variable(edge_subtype_vec_str);
                string edge_variable_visible = "edge." + repid_source_node + "to" + repid_target_node + "." + edge_type_str + "-" + edge_subtypes_str + "visible";

                t_Expression* expression_edge_visible = NULL;
                if (getExpressionMap.find(edge_variable_visible) == getExpressionMap.end()) {
                    expression_edge_visible = em->createSymbol(edge_variable_visible, te1);
                    getExpressionMap[edge_variable_visible] = expression_edge_visible;
                    getCNFIndexMap[expression_edge_visible] = make_pair(edge_variable_visible, -1);
                } else {
                    expression_edge_visible = getExpressionMap[edge_variable_visible];
                }

                if (expression_edge_visible) {
                    to_OR.push_back(expression_edge_visible);
                } else {
                    cerr << "Error: expression for edge visible is NULL!" << endl;
                }
            }


            t_Expression* expr_atleast_one_in_edge_if_out = build_OR_constraints_from_vector(to_OR, em);


            for (vector<int>::iterator outlist_itr = outlist.begin(); outlist_itr != outlist.end(); outlist_itr++) {
                //now for visibility of each of these outlist edges one of the those from inlist must be visible
                int target_id = get_target_node(*outlist_itr);
                string repid_source_node = get_rep_id_from_nid(*nid_itr);
                string repid_target_node = get_rep_id_from_nid(target_id);
                string edge_type_str = get_edge_type(*outlist_itr);
                vector<string> edge_subtype_vec_str = get_edge_subtypes_of_edge(*outlist_itr);
                string edge_subtypes_str = gm->get_edge_substring_for_constraint_variable(edge_subtype_vec_str);
                string edge_variable_visible = "edge." + repid_source_node + "to" + repid_target_node + "." + edge_type_str + "-" + edge_subtypes_str + "visible";

                t_Expression* expression_edge_visible = NULL;
                if (getExpressionMap.find(edge_variable_visible) == getExpressionMap.end()) {
                    expression_edge_visible = em->createSymbol(edge_variable_visible, te1);
                    getExpressionMap[edge_variable_visible] = expression_edge_visible;
                    getCNFIndexMap[expression_edge_visible] = make_pair(edge_variable_visible, -1);
                } else {
                    expression_edge_visible = getExpressionMap[edge_variable_visible];
                }

                //now make the implication

                t_Expression* out_implies_at_least_one_in = build_OR_constraints(expression_edge_visible, expr_atleast_one_in_edge_if_out, 1, 0, em);
                if (out_implies_at_least_one_in) {
                    to_AND.push_back(out_implies_at_least_one_in);
                } else {
                    cerr << "Error: expression for out edge visible implies at least one in edge visible is NULL!" << endl;
                }
            }
        }
    }

    to_return = build_AND_constraints_from_vector(to_AND, em);
    return to_return;
}

//At least one GErel with expr/repr edge  incoming edge to a differentially expressed node is visible.
//this function assumes that the set of differentially expressed nodes passed as arguments are indeed there in the graph as GErel targets with expression or repression

t_Expression* GraphNew::get_constraint_expr_visible_incoming_edge_to_diff_expr_node(set<int>& differentially_expressed_nids, t_ExpressionManager* em, GraphManagerNew* gm) {
    t_Expression* to_return = NULL;
    vector<t_Expression*> to_AND;
    TypeOfExpressionTuple te1 = {TYPE_UNSIGNED_BITVECTOR, 1};

    for (set<int>::iterator diff_nodes_itr = differentially_expressed_nids.begin(); diff_nodes_itr != differentially_expressed_nids.end(); ++diff_nodes_itr) {
        vector<int> inlist_diff_node = get_inlist(*diff_nodes_itr);
        vector<t_Expression*> to_OR;

        for (vector<int>::iterator edge_itr = inlist_diff_node.begin(); edge_itr != inlist_diff_node.end(); edge_itr++) {
            if (get_edge_type(*edge_itr) == "GErel" && (edge_has_subtype(*edge_itr, "expression") || edge_has_subtype(*edge_itr, "repression"))) {
                int source_id = get_source_node(*edge_itr);
                string repid_source_node = get_rep_id_from_nid(source_id);
                string repid_target_node = get_rep_id_from_nid(*diff_nodes_itr);
                string edge_type_str = get_edge_type(*edge_itr);
                vector<string> edge_subtype_vec_str = get_edge_subtypes_of_edge(*edge_itr);
                string edge_subtypes_str = gm->get_edge_substring_for_constraint_variable(edge_subtype_vec_str);
                string edge_variable_visible = "edge." + repid_source_node + "to" + repid_target_node + "." + edge_type_str + "-" + edge_subtypes_str + "visible";

                t_Expression* expression_edge_visible = NULL;
                if (getExpressionMap.find(edge_variable_visible) == getExpressionMap.end()) {
                    expression_edge_visible = em->createSymbol(edge_variable_visible, te1);
                    getExpressionMap[edge_variable_visible] = expression_edge_visible;
                    getCNFIndexMap[expression_edge_visible] = make_pair(edge_variable_visible, -1);
                } else {
                    expression_edge_visible = getExpressionMap[edge_variable_visible];
                }

                if (expression_edge_visible) {
                    to_OR.push_back(expression_edge_visible);
                } else {
                    cerr << "Error: expression for edge visible is NULL?" << endl;
                }
            }
        }

        t_Expression* expr_atleast_one_in_edge_for_diff_node = build_OR_constraints_from_vector(to_OR, em);
        if (expr_atleast_one_in_edge_for_diff_node) {
            to_AND.push_back(expr_atleast_one_in_edge_for_diff_node);
        } else {
            cerr << "Error: no atleast one in edge visible constraint for the diff node?" << endl;
        }
    }

    to_return = build_AND_constraints_from_vector(to_AND, em);
    return to_return;
}

t_Expression* GraphNew::get_zero_distance_constraint_for_node(int nid, map<int, vector<t_Expression*> >& nid_distanc_var_map, t_ExpressionManager* em, GraphManagerNew* gm) {
    t_Expression* to_return = NULL;
    vector<t_Expression*> nid_dist_variable_seq;
    //if the variables to represent the bit sequence for node is not present then make it, other wise use it
    if (nid_distanc_var_map.find(nid) == nid_distanc_var_map.end()) {
        nid_dist_variable_seq = get_node_distance_expression_sequence(nid, em, gm);
        nid_distanc_var_map[nid] = nid_dist_variable_seq;
    } else {
        nid_dist_variable_seq = nid_distanc_var_map[nid];
    }

    //for distance to to be zero, all bits must be zero , so ORing all bits must generate zero
    t_Expression* temp = build_OR_constraints_from_vector(nid_dist_variable_seq, em);
    to_return = em->createOneBitExpressionWithOneOperand(em->m_operatorLabelLogNOT, temp); //negating

    return to_return;
}

t_Expression* GraphNew::get_positive_distance_constrains_for_non_source_nodes(int source_nid, map<int, vector<t_Expression*> >& nid_distanc_var_map, t_ExpressionManager* em, GraphManagerNew* gm) {
    t_Expression* to_return = NULL;
    vector<t_Expression*> to_AND;
    TypeOfExpressionTuple te1 = {TYPE_UNSIGNED_BITVECTOR, 1};

    for (vector<int>::iterator nid_itr = NIDSg.begin(); nid_itr != NIDSg.end(); nid_itr++) {
        if (*nid_itr != source_nid) {
            vector<t_Expression*> nid_dist_variable_seq;
            //if the variables to represent the bit sequence for node is not present then make it, other wise use it
            if (nid_distanc_var_map.find(*nid_itr) == nid_distanc_var_map.end()) {
                nid_dist_variable_seq = get_node_distance_expression_sequence(*nid_itr, em, gm);
                nid_distanc_var_map[*nid_itr] = nid_dist_variable_seq;
            } else {
                nid_dist_variable_seq = nid_distanc_var_map[*nid_itr];
            }
            assert(nid_dist_variable_seq.size() == NODE_DISTANCE_BIT_SEQ_LENGTH);

            t_Expression* distance_node_positive_constraint = get_expression_sequence_positive_constraint(nid_dist_variable_seq, em);
            if (distance_node_positive_constraint) {
                to_AND.push_back(distance_node_positive_constraint);
            } else {
                cerr << "Error: node distance constraint for node id " << *nid_itr << " is NULL, ignoring..." << endl;
            }
        }
    }

    //ANding constraints for all edges
    to_return = build_AND_constraints_from_vector(to_AND, em);

    return to_return;
}

t_Expression* GraphNew::get_edge_presence_implies_visible_constraints(t_ExpressionManager* em, GraphManagerNew* gm) {
    t_Expression* to_return = NULL;
    vector<t_Expression*> to_AND;
    TypeOfExpressionTuple te1 = {TYPE_UNSIGNED_BITVECTOR, 1};

    for (vector<int>::iterator edge_itr = EIDSg.begin(); edge_itr != EIDSg.end(); ++edge_itr) {
        int source_id = get_source_node(*edge_itr);
        int target_id = get_target_node(*edge_itr);
        string repid_source_node = get_rep_id_from_nid(source_id);
        string repid_target_node = get_rep_id_from_nid(target_id);
        string edge_type_str = get_edge_type(*edge_itr);
        vector<string> edge_subtype_vec_str = get_edge_subtypes_of_edge(*edge_itr);
        string edge_subtypes_str = gm->get_edge_substring_for_constraint_variable(edge_subtype_vec_str);

        string edge_variable_present = "edge." + repid_source_node + "to" + repid_target_node + "." + edge_type_str + "-" + edge_subtypes_str + "present";
        string edge_variable_visible = "edge." + repid_source_node + "to" + repid_target_node + "." + edge_type_str + "-" + edge_subtypes_str + "visible";

        t_Expression* expression_edge_present = NULL;
        t_Expression* expression_edge_visible = NULL;

        if (getExpressionMap.find(edge_variable_present) == getExpressionMap.end()) {
            expression_edge_present = em->createSymbol(edge_variable_present, te1);
            getExpressionMap[edge_variable_present] = expression_edge_present;
            getCNFIndexMap[expression_edge_present] = make_pair(edge_variable_present, -1);
        } else {
            expression_edge_present = getExpressionMap[edge_variable_present];
        }

        if (getExpressionMap.find(edge_variable_visible) == getExpressionMap.end()) {
            expression_edge_visible = em->createSymbol(edge_variable_visible, te1);
            getExpressionMap[edge_variable_visible] = expression_edge_visible;
            getCNFIndexMap[expression_edge_visible] = make_pair(edge_variable_visible, -1);
        } else {
            expression_edge_visible = getExpressionMap[edge_variable_visible];
        }

        if (expression_edge_present && expression_edge_visible) {
            t_Expression* expression_edge_present_implies_visible = build_OR_constraints(expression_edge_present, expression_edge_visible, 1, 0, em);
            if (expression_edge_present) {
                to_AND.push_back(expression_edge_present_implies_visible);
            } else {
                cerr << "Error: implication is NULL, shouldn't be, check?" << endl;
            }
        } else {
            cout << "Note: edge present or visible expression is NULL, check?" << endl;
        }
    }

    //ANding constraints for all edges
    to_return = build_AND_constraints_from_vector(to_AND, em);

    return to_return;
}

t_Expression* GraphNew::get_reach_path_constraints(t_ExpressionManager* em, GraphManagerNew* gm) {
    t_Expression* to_return = NULL;
    vector<t_Expression*> to_AND;
    TypeOfExpressionTuple te1 = {TYPE_UNSIGNED_BITVECTOR, 1};

    //get constraints: if an edge is present it must be visible
    cout << "Writing constraints: Edge present implies Edge visible" << endl;
    t_Expression* edge_present_implies_visible = get_edge_presence_implies_visible_constraints(em, gm);
    if (edge_present_implies_visible) {
        to_AND.push_back(edge_present_implies_visible);
    } else {
        cerr << "Note: no constraints for edge present implies visible in the graph" << endl;
    }

    //testing starts
    /*ofstream test_fout1("constraintsPresenceImpliesVisible");
      em->printExpressionToFileAsDAG("constraintsPresenceImpliesVisible ", edge_present_implies_visible, test_fout1);
      test_fout1.close();*/
    //testing ends

    //get source nodes and differentially expressed  nodes that are actually GErel targets with expression or repression as subtype
    string source_node_id;
    cout << "\nEnter source node id, e.g. hsa100 etc: ";
    cin >> source_node_id;
    string source_rid = get_rep_id_from_id(source_node_id);
    if (source_rid == "") {
        cerr << "Error: No rep id found for source node " + source_node_id + ", returning NULL" << endl;
        return NULL;
    }
    int source_nid = get_nid_from_rep_id(source_rid);
    assert(source_nid != -1);

    set<int> differentially_expressed_nids;
    string file_diff_exp;
    string s;
    cout << "Enter the file path containing the list of ids of differentially expressed nodes: ";
    cin >> file_diff_exp;

    ifstream fin(file_diff_exp.c_str());
    if (fin.is_open()) {
        while (fin >> s) {
            string diff_rid = get_rep_id_from_id(s);
            if (diff_rid != "") {
                int diff_nid = get_nid_from_rep_id(diff_rid);

                vector<int> inlist = get_inlist(diff_nid);
                for (vector<int>::iterator in_itr = inlist.begin(); in_itr != inlist.end(); in_itr++) {
                    if (get_edge_type(*in_itr) == "GErel" && (edge_has_subtype(*in_itr, "expression") || edge_has_subtype(*in_itr, "repression"))) {
                        //check: source node shouldn't be the same as the differentially expressed node
                        if (diff_nid == source_nid) {
                            cout << "Source node is also differentialy expressed node, ignoring it as differentially expressed node" << endl;
                        } else {
                            differentially_expressed_nids.insert(diff_nid);
                        }
                        break; //one edge is enough
                    }
                }
            } else {
                cerr << "Error: no rep id for differentially expressed id " + s << endl;
            }
        }
    } else {
        cerr << "Error: Couldn't open the file " + file_diff_exp << endl;
    }

    //get constraints: All the distances other than the source are positive.
    cout << "Writing constraints: all non_source distance are positive" << endl;
    map<int, vector<t_Expression*> > nid_distanc_var_map; //maps from a node id to each of its distances represented by a variable sequence
    t_Expression* expr_non_source_positive_dists = get_positive_distance_constrains_for_non_source_nodes(source_nid, nid_distanc_var_map, em, gm);
    if (expr_non_source_positive_dists) {
        to_AND.push_back(expr_non_source_positive_dists);
    } else {
        cerr << "Error: No non-source distance positive constraints" << endl;
    }

    //testing starts
    /*ofstream test_fout2("non_source_positive");
      em->printExpressionToFileAsDAG("non_source_positive ", expr_non_source_positive_dists, test_fout2);
      test_fout2.close();*/
    //testing ends

    cout << "Writing constraints: source node distance is zero" << endl;
    //get constraint: Distance of source node is 0.
    t_Expression* expr_source_node_zero_distance = get_zero_distance_constraint_for_node(source_nid, nid_distanc_var_map, em, gm);
    if (expr_source_node_zero_distance) {
        to_AND.push_back(expr_source_node_zero_distance);
    } else {
        cerr << "Error: No source distance zero constraints" << endl;
    }

    //testing starts
    /*ofstream test_fout3("source_zero");
      em->printExpressionToFileAsDAG("source_zero ", expr_source_node_zero_distance, test_fout3);
      test_fout3.close();*/
    //testing ends

    cout << "Writing constraints: At least one incoming edge to a differentially expressed node is visible" << endl;
    //get constraints: At least one incoming edge to a differentially expressed node is visible.

    t_Expression* expr_visible_incoming_edge_to_diff_expr_node = get_constraint_expr_visible_incoming_edge_to_diff_expr_node(differentially_expressed_nids, em, gm);
    if (expr_visible_incoming_edge_to_diff_expr_node) {
        to_AND.push_back(expr_visible_incoming_edge_to_diff_expr_node);
    } else {
        cerr << "Error: No source distance zero constraints" << endl;
    }

    //testing starts
    /*ofstream test_fout4("visible_incoming_edge_to_diff_expr_node");
      em->printExpressionToFileAsDAG("visible_incoming_edge_to_diff_expr_node ", expr_visible_incoming_edge_to_diff_expr_node, test_fout4);
      test_fout4.close();*/
    //testing ends

    cout << "Writing constraints: If a non-source node has an outgoing visible edge then it must have an incoming visible edge" << endl;
    //get constraints: If a non-source node has an outgoing visible edge then it must have an incoming visible edge
    t_Expression* expr_non_source_node_visible_edges_in_if_out = get_constraints_expr_visible_in_if_out_non_source_node(source_nid, em, gm);
    if (expr_non_source_node_visible_edges_in_if_out) {
        to_AND.push_back(expr_non_source_node_visible_edges_in_if_out);
    } else {
        cerr << "Error: No source distance zero constraints" << endl;
    }

    //testing starts
    /*ofstream test_fout5("non_source_node_visible_edges_in_if_out");
      em->printExpressionToFileAsDAG("non_source_node_visible_edges_in_if_out ", expr_non_source_node_visible_edges_in_if_out, test_fout5);
      test_fout5.close();*/
    //testing ends

    //create a variable that is asserted to true and thus acts as 1 in constraint solver -- used as we need to say distane of a nodes is one more than distance of the other node
    //variable name  given "true_bit"
    string true_bit = "true_bit";
    t_Expression* expression_true_bit = em->createSymbol(true_bit, te1);
    getExpressionMap[true_bit] = expression_true_bit;
    getCNFIndexMap[expression_true_bit] = make_pair(true_bit, -1);
    to_AND.push_back(expression_true_bit); //this will assert that this bit is set to 1

    //testing starts
    /*ofstream test_fout6("true bit");
      em->printExpressionToFileAsDAG("true_bit ", expression_true_bit, test_fout6);
      test_fout6.close();*/
    //testing ends

    cout << "Writing constraints: if an edge is visible then distance[target] = distance[source]+1" << endl;
    //get constraints: if an edge is visible then distance[target] = distance[source]+1
    t_Expression* expr_distance_source_target_for_visible_edge = get_constraints_distance_source_target_for_visible_edge(source_nid, nid_distanc_var_map, expression_true_bit, em, gm);
    if (expr_distance_source_target_for_visible_edge) {
        to_AND.push_back(expr_distance_source_target_for_visible_edge);
    } else {
        cerr << "Error: No constraint for source distance one less than edge distance for visible edges" << endl;
    }

    //testing starts
    /*ofstream test_fout7("distance_source_target_for_visible_edge ");
      em->printExpressionToFileAsDAG("distance_source_target_for_visible_edge  ", expr_distance_source_target_for_visible_edge, test_fout7);
      test_fout7.close();*/
    //testing ends

    //get constraints: assoc/dissoc edge exist in pair
    //add later

    cout << "Anding reach constraints..." << endl;
    to_return = build_AND_constraints_from_vector(to_AND, em);
    return to_return;
}

t_Expression* GraphNew::get_DAG_reach_path_constraints(t_ExpressionManager* em, GraphManagerNew* gm) {
    t_Expression* to_return = NULL;

    vector<t_Expression*> to_AND;

    //go over each edge and if that edge is present then one of its incoming edges must be present
    for (vector<int>::iterator edge_itr = EIDSg.begin(); edge_itr != EIDSg.end(); ++edge_itr) {
        int source_id = get_source_node(*edge_itr);
        int target_id = get_target_node(*edge_itr);
        string repid_source_node = get_rep_id_from_nid(source_id);
        string repid_target_node = get_rep_id_from_nid(target_id);
        string edge_type_str = get_edge_type(*edge_itr);
        vector<string> edge_subtype_vec_str = get_edge_subtypes_of_edge(*edge_itr);
        string edge_subtypes_str = gm->get_edge_substring_for_constraint_variable(edge_subtype_vec_str);

        string source_node_variable = repid_source_node + "_active";
        string edge_variable = "edge." + repid_source_node + "to" + repid_target_node + "." + edge_type_str + "-" + edge_subtypes_str + "present";

        vector<t_Expression*> to_OR;

        //go over all incoming edges of source
        vector<int> source_inlist = get_inlist(source_id);
        for (vector<int>::iterator source_in_itr = source_inlist.begin(); source_in_itr != source_inlist.end(); source_in_itr++) {
            //if the source node is active and source-target edge is present then it must be explained by one of the activating incoming edges and source of source being active
            //so collect all these to be ored later
            if (edge_has_subtype(*source_in_itr, "activation")) {
                int id_source_of_source = get_source_node(*source_in_itr);
                string repid_source_of_source = get_rep_id_from_nid(id_source_of_source);
                string edge_type_str_in = get_edge_type(*source_in_itr);
                vector<string> edge_subtype_vec_str_in = get_edge_subtypes_of_edge(*source_in_itr);
                string edge_subtypes_str_in = gm->get_edge_substring_for_constraint_variable(edge_subtype_vec_str_in);

                string source_of_source_node_variable = repid_source_of_source + "_active";
                string edge_variable_in = "edge." + repid_source_of_source + "to" + repid_source_node + "." + edge_type_str_in + "-" + edge_subtypes_str_in + "present";

                t_Expression* expression_to_OR = NULL;
                t_Expression* expression_node = NULL;
                t_Expression* expression_edge = NULL;
                TypeOfExpressionTuple te1 = {TYPE_UNSIGNED_BITVECTOR, 1};

                if (getExpressionMap.find(source_of_source_node_variable) == getExpressionMap.end()) {
                    expression_node = em->createSymbol(source_of_source_node_variable, te1);
                    getExpressionMap[source_of_source_node_variable] = expression_node;
                    getCNFIndexMap[expression_node] = make_pair(source_of_source_node_variable, -1);
                } else {
                    expression_node = getExpressionMap[source_of_source_node_variable];
                }

                if (getExpressionMap.find(edge_variable_in) == getExpressionMap.end()) {
                    expression_edge = em->createSymbol(edge_variable_in, te1);
                    getExpressionMap[edge_variable_in] = expression_edge;
                    getCNFIndexMap[expression_edge] = make_pair(edge_variable_in, -1);
                } else {
                    expression_edge = getExpressionMap[edge_variable_in];
                }

                expression_to_OR = build_AND_constraints(expression_node, expression_edge, 0, 0, em);
                to_OR.push_back(expression_to_OR);
            }

            //inhibition cases to be added later -- may need to redo some missing edges

        }

        t_Expression* expression_ORred = NULL;

        //if indeed the to_OR vector is not empty then we must have found an explaining incoming edge
        if (!to_OR.empty()) {
            expression_ORred = to_OR[0];
            if (to_OR.size() > 1) {
                //OR rest of the expressions
                for (vector<t_Expression*>::iterator to_or_itr = to_OR.begin() + 1; to_or_itr != to_OR.end(); to_or_itr++) {
                    t_Expression* temp = build_OR_constraints(expression_ORred, *to_or_itr, 0, 0, em);
                    expression_ORred = temp;
                }
            }

            t_Expression* expression_to_AND = NULL;
            t_Expression* expression_edge = NULL;
            TypeOfExpressionTuple te1 = {TYPE_UNSIGNED_BITVECTOR, 1};

            if (getExpressionMap.find(edge_variable) == getExpressionMap.end()) {
                expression_edge = em->createSymbol(edge_variable, te1);
                getExpressionMap[edge_variable] = expression_edge;
                getCNFIndexMap[expression_edge] = make_pair(edge_variable, -1);
            } else {
                expression_edge = getExpressionMap[edge_variable];
            }

            expression_to_AND = build_OR_constraints(expression_edge, expression_ORred, 1, 0, em);
            to_AND.push_back(expression_to_AND);
        }
    }

    to_return = build_AND_constraints_from_vector(to_AND, em);

    return to_return;
}

void GraphNew::perform_kegg_consistency_check() {
    std::vector<int>::iterator itr;
    int gid = get_graph_id();
    string consistency_log = "log_kegg_consistency_graph_" + IntToString(gid);
    ofstream fout(consistency_log.c_str());
    if (fout.is_open()) {
        for (itr = EIDSg.begin(); itr != EIDSg.end(); itr++) {
            EdgeNew * edge = get_edge_from_eid(*itr);
            int source_id = edge->get_source();
            int target_id = edge->get_target();
            string source_rid = get_rep_id_from_nid(source_id);
            string target_rid = get_rep_id_from_nid(target_id);
            string edge_type = edge->get_edge_type();

            string source_type = get_node_type(source_id);
            string target_type = get_node_type(target_id);

            //adjacent compound implies edge type PCrel
            if ((target_type == "compound" || source_type == "compound") && edge_type != "PCrel") {
                fout << "Edge between " + source_rid + " and " + target_rid + " is of type " + edge_type + ", changing it to PCrel" << endl;
                remove_edge_id_type(*itr);
                add_edge_type(*itr, "PCrel");
            }

            //expression or repression implies GErel
            if ((edge_has_subtype(*itr, "expression") || edge_has_subtype(*itr, "repression")) && edge_type != "GErel") {
                fout << "Edge between " + source_rid + " and " + target_rid + " is of type " + edge_type + ", changing it to GErel" << endl;
                remove_edge_id_type(*itr);
                add_edge_type(*itr, "GErel");
            }

            //remaining checks are statistically less and to be added later



        }
        fout.close();
    } else {
        cerr << "Error: Log file " + consistency_log + " couldn't be opened" << endl;
    }
}

void GraphNew::display_graph_silent(string color_map_filename, string vis_edges_filename, string dot_filename, GraphManagerNew* gm) {

    map<int, color_triple_new> node_color_map;
    map<int, color_triple_new>::iterator color_itr;

    char color_visible_edges = 'y';
    //cout << "Enter 'y' or 'Y' to color edges that are visible but not present as assigned by the constraint solver for subgraph generation, any other key to not...";
    //cin >> color_visible_edges;
    set<int> red_vis_edges;

    if (color_visible_edges == 'y' || color_visible_edges == 'Y') {
        string visi_edges_file = vis_edges_filename;
        //cout << "Enter the file containing visible edges list: ";
        //cin >> visi_edges_file;

        ifstream fin(visi_edges_file.c_str());
        string vis_edge_var;
        if (fin.is_open()) {
            while (fin >> vis_edge_var) {
                list<string> *subparts = gm->get_list_of_names_from_string(vis_edge_var, ".");
                subparts->pop_front(); // remove 'edge' prefix
                string end_names = subparts->front(); //source to target
                subparts->pop_front();
                string edge_info = subparts->front(); //type subtype

                //get source and target rep ids
                list<string> *end_nodes = gm->get_list_of_names_from_string(end_names, "to");
                string source_rep_id = end_nodes->front();
                end_nodes->pop_front();
                string target_rep_id = end_nodes->front();
                end_nodes->pop_front();

                //get type info
                list<string>* edgeInfo = gm->get_list_of_names_from_string(edge_info, "-");
                string edgeType = edgeInfo->front(); //get edge type
                edgeInfo->pop_front(); // Remove the 'edge type' from list of strings

                //edgeInfo now has only subtypes

                //go over edges of the graph and if edge matches add it to red_vis_edges to be colored red later
                for (vector<int>::iterator edge_itr = EIDSg.begin(); edge_itr != EIDSg.end(); ++edge_itr) {
                    string ingraph_edge_type = get_edge_type(*edge_itr);
                    vector<string> ingraph_edge_subtypes = get_edge_subtypes_of_edge(*edge_itr);
                    sort(ingraph_edge_subtypes.begin(), ingraph_edge_subtypes.end());
                    vector<string> edgeSubtypes(edgeInfo->begin(), edgeInfo->end());
                    sort(edgeSubtypes.begin(), edgeSubtypes.end());
                    string ingraph_source_rid = get_rep_id_from_nid(get_source_node(*edge_itr));
                    string ingraph_target_rid = get_rep_id_from_nid(get_target_node(*edge_itr));
                    if (ingraph_source_rid == source_rep_id && ingraph_target_rid == target_rep_id && ingraph_edge_type == edgeType && edgeSubtypes == ingraph_edge_subtypes) {
                        red_vis_edges.insert(*edge_itr);
                    }
                }
            }
            fin.close();
        } else {
            cerr << "Error: Couldn't open assg file " + visi_edges_file << endl;
        }
    }

    if (color_map_filename != "0") {
        ifstream ifs(color_map_filename.c_str());
        string node_id;
        int redValue, greenValue, blueValue;
        if (!ifs.is_open()) {
            cerr << "Error: the color file " + color_map_filename + " couldn't be opened. Returning without displaying..." << endl;
            return;
        }
        while (ifs >> node_id) {
            ifs >> redValue;
            ifs >> greenValue;
            ifs >> blueValue;

            color_triple_new color(redValue, greenValue, blueValue);

            string rep_id = get_rep_id_from_id(node_id);
            if (rep_id != "") {
                int nid = get_nid_from_rep_id(rep_id);
                node_color_map.insert(pair<int, color_triple_new>(nid, color));
            }
        }
    }

    std::string dis_name = dot_filename;
    //std::cout << "\nEnter a file name for the graph display with .dot extension (e.g. mygraph.dot): ";
    //std::cin >> dis_name;

    ofstream fout(dis_name.c_str());

    if (fout.is_open()) {
        fout << "Digraph G  {\n";
        fout << "label = \"Graph " << this->graph_id << "\";\n";
        fout << "labelloc = top;\n";
        fout << "labeljust = left;\n";
        fout << "labelfontsize = 20.0;\n";
        fout << "edge [style=\"solid\"];\n";

        set<int> drawn_nodes;
        //set<int> drawn_edges;

        vector<set<int> > undirected_edges;

        for (vector<int>::iterator itr = NIDSg.begin(); itr != NIDSg.end(); itr++) {
            set<int>::iterator drawn_nodes_itr = drawn_nodes.find(*itr);

            if (drawn_nodes_itr == drawn_nodes.end()) {//a node not already written
                // get color of node
                color_triple_new color_to_set;
                color_itr = node_color_map.find(*itr);
                if (color_itr != node_color_map.end()) {
                    color_to_set.red = (*color_itr).second.red;
                    color_to_set.green = (*color_itr).second.green;
                    color_to_set.blue = (*color_itr).second.blue;
                }
                write_node_to_dot_file(fout, *itr, drawn_nodes, color_to_set);

            }
            vector<int> node_out_list = get_outlist(*itr);

            if (!node_out_list.empty()) {
                for (vector<int>::iterator out_itr = node_out_list.begin(); out_itr != node_out_list.end(); out_itr++) {
                    int target_node_id = get_target_node(*out_itr);
                    drawn_nodes_itr = drawn_nodes.find(target_node_id);
                    if (drawn_nodes_itr == drawn_nodes.end()) {

                        // get color of node
                        color_triple_new color_to_set2;
                        color_itr = node_color_map.find(target_node_id);
                        if (color_itr != node_color_map.end()) {
                            color_to_set2.red = (*color_itr).second.red;
                            color_to_set2.green = (*color_itr).second.green;
                            color_to_set2.blue = (*color_itr).second.blue;
                        }
                        write_node_to_dot_file(fout, target_node_id, drawn_nodes, color_to_set2);

                    }
                    set<int> edge_nodes;
                    edge_nodes.insert(*itr);
                    edge_nodes.insert(target_node_id);
                    //undirected edge - so we draw it onle once with no arrow
                    if (find(undirected_edges.begin(), undirected_edges.end(), edge_nodes) == undirected_edges.end()) {
                        fout << "\t" << *itr;
                        fout << " -> ";
                        fout << get_target_node(*out_itr);

                        string edge_type = get_edge_type(*out_itr);
                        vector<string> edge_subtypes = get_edge_subtypes_of_edge(*out_itr);
                        vector<string> edge_belongs_to_pathways = get_all_pathways_for_edge(*out_itr);

                        string arrowhead, style, label, color;
                        fout << "[";

                        vector<string>::iterator vec_str_itr;

                        for (vec_str_itr = edge_subtypes.begin(); vec_str_itr != edge_subtypes.end(); vec_str_itr++) {
                            if (*vec_str_itr == "association" || *vec_str_itr == "dissociation") {

                                arrowhead = "none";
                                style = "bold";

                                if (*vec_str_itr == "association") {
                                    label += "assoc\\n";
                                }
                                if (*vec_str_itr == "dissociation") {
                                    label += "dissoc\\n";
                                }
                                undirected_edges.push_back(edge_nodes);
                            }

                            if (*vec_str_itr == "inhibition") {
                                arrowhead = "tee";
                                label += "inhb\\n";
                            }

                            if (*vec_str_itr == "repression") {
                                arrowhead = "tee";
                                label += "repr\\n";
                            }

                            if (*vec_str_itr == "activation") {
                                label += "actv\\n";
                            }

                            if (*vec_str_itr == "expression") {
                                label += "expr\\n";
                            }

                            if (*vec_str_itr == "dephosphorylation") {
                                label += "-p\\n";
                            }

                            if (*vec_str_itr == "phosphorylation") {
                                label += "+p\\n";
                            }

                            if (*vec_str_itr == "indirect") {
                                style = "dashed";
                            }

                            if (*vec_str_itr == "component") {
                                label += "comp\\n";
                            }

                            if (*vec_str_itr == "PPI") {
                                label = "PPI";

                            }
                        }

                        if (edge_type == "PPrel") {
                            label = label + "PPrel\\n";
                        }
                        if (edge_type == "GErel") {
                            label = label + "GErel\\n";
                        }
                        if (edge_type == "PCrel") {
                            label = label + "PCrel\\n";
                        }
                        if (edge_type == "ECrel") {
                            label = label + "ECrel\\n";
                        }

                        for (vec_str_itr = edge_belongs_to_pathways.begin(); vec_str_itr != edge_belongs_to_pathways.end(); vec_str_itr++) {
                            label += *vec_str_itr + "\\n";
                        }

                        if ((color_visible_edges == 'y' || color_visible_edges == 'Y') && red_vis_edges.find(*out_itr) != red_vis_edges.end()) {
                            fout << "arrowhead=\"" << arrowhead << "\", style=\"" << style << "\", color=red, label=\"" << label << "\", ";
                        } else {
                            fout << "arrowhead=\"" << arrowhead << "\", style=\"" << style << "\", color=\"" << color << "\", label=\"" << label << "\", ";
                        }
                        fout << "arrowsize=1, penwidth = 2]";
                        fout << ";" << "\n";

                    }
                }
            }
        }
        fout << "}";
        fout.close();

        string xdot_path_name = XDOT_PATH_NAME;
        string systemCommand = xdot_path_name + dis_name + " & ";
        //string systemCommand =  xdot_path_name + dis_name;
        //system(systemCommand.c_str());
    } else {
        cerr << "\nCouldn't open file for writing: " << dis_name << endl;
    }
}

void GraphNew::display_graph(string color_map_filename, GraphManagerNew* gm) {
    map<int, color_triple_new> node_color_map;
    map<int, color_triple_new>::iterator color_itr;

    char color_visible_edges;
    cout << "Enter 'y' or 'Y' to color edges that are visible but not present as assigned by the constraint solver for subgraph generation, any other key to not...";
    cin >> color_visible_edges;
    set<int> red_vis_edges;

    if (color_visible_edges == 'y' || color_visible_edges == 'Y') {
        string visi_edges_file;
        cout << "Enter the file containing visible edges list: ";
        cin >> visi_edges_file;

        ifstream fin(visi_edges_file.c_str());
        string vis_edge_var;
        if (fin.is_open()) {
            while (fin >> vis_edge_var) {
                list<string> *subparts = gm->get_list_of_names_from_string(vis_edge_var, ".");
                subparts->pop_front(); // remove 'edge' prefix
                string end_names = subparts->front(); //source to target
                subparts->pop_front();
                string edge_info = subparts->front(); //type subtype

                //get source and target rep ids
                list<string> *end_nodes = gm->get_list_of_names_from_string(end_names, "to");
                string source_rep_id = end_nodes->front();
                end_nodes->pop_front();
                string target_rep_id = end_nodes->front();
                end_nodes->pop_front();

                //get type info
                list<string>* edgeInfo = gm->get_list_of_names_from_string(edge_info, "-");
                string edgeType = edgeInfo->front(); //get edge type
                edgeInfo->pop_front(); // Remove the 'edge type' from list of strings

                //edgeInfo now has only subtypes

                //go over edges of the graph and if edge matches add it to red_vis_edges to be colored red later
                for (vector<int>::iterator edge_itr = EIDSg.begin(); edge_itr != EIDSg.end(); ++edge_itr) {
                    string ingraph_edge_type = get_edge_type(*edge_itr);
                    vector<string> ingraph_edge_subtypes = get_edge_subtypes_of_edge(*edge_itr);
                    sort(ingraph_edge_subtypes.begin(), ingraph_edge_subtypes.end());
                    vector<string> edgeSubtypes(edgeInfo->begin(), edgeInfo->end());
                    sort(edgeSubtypes.begin(), edgeSubtypes.end());
                    string ingraph_source_rid = get_rep_id_from_nid(get_source_node(*edge_itr));
                    string ingraph_target_rid = get_rep_id_from_nid(get_target_node(*edge_itr));
                    if (ingraph_source_rid == source_rep_id && ingraph_target_rid == target_rep_id && ingraph_edge_type == edgeType && edgeSubtypes == ingraph_edge_subtypes) {
                        red_vis_edges.insert(*edge_itr);
                    }
                }
            }
            fin.close();
        } else {
            cerr << "Error: Couldn't open assg file " + visi_edges_file << endl;
        }
    }




    if (color_map_filename != "0") {
        ifstream ifs(color_map_filename.c_str());
        string node_id;
        int redValue, greenValue, blueValue;
        if (!ifs.is_open()) {
            cerr << "Error: the color file " + color_map_filename + " couldn't be opened. Returning without displaying..." << endl;
            return;
        }
        while (ifs >> node_id) {
            ifs >> redValue;
            ifs >> greenValue;
            ifs >> blueValue;

            color_triple_new color(redValue, greenValue, blueValue);

            string rep_id = get_rep_id_from_id(node_id);
            if (rep_id != "") {
                int nid = get_nid_from_rep_id(rep_id);
                node_color_map.insert(pair<int, color_triple_new>(nid, color));
            }
        }
    }













    //dot conversion occurs here
    std::string dis_name;
    std::cout << "\nEnter a file name for the graph display with .dot extension (e.g. mygraph.dot): ";
    std::cin >> dis_name;

    ofstream fout(dis_name.c_str());

    if (fout.is_open()) {
        fout << "Digraph G  {\n";
        fout << "label = \"Graph " << this->graph_id << "\";\n";
        fout << "labelloc = top;\n";
        fout << "labeljust = left;\n";
        fout << "labelfontsize = 20.0;\n";
        fout << "edge [style=\"solid\"];\n";

        set<int> drawn_nodes;
        //set<int> drawn_edges;

        vector<set<int> > undirected_edges;

        for (vector<int>::iterator itr = NIDSg.begin(); itr != NIDSg.end(); itr++)
            //itr points to begin of NIDSg until NIDSg doesnt end
        {
            set<int>::iterator drawn_nodes_itr = drawn_nodes.find(*itr);
            //drawn_nodes is the size , *itr points to nids

            if (drawn_nodes_itr == drawn_nodes.end()) {//a node not already written
                // get color of node
                color_triple_new color_to_set;
                color_itr = node_color_map.find(*itr);
                if (color_itr != node_color_map.end()) {
                    color_to_set.red = (*color_itr).second.red;
                    color_to_set.green = (*color_itr).second.green;
                    color_to_set.blue = (*color_itr).second.blue;
                }
                //main conversion carried out in function below
                write_node_to_dot_file(fout, *itr, drawn_nodes, color_to_set);

            }
            vector<int> node_out_list = get_outlist(*itr);
            //outlist is the corresponding out degree

            if (!node_out_list.empty()) {
                for (vector<int>::iterator out_itr = node_out_list.begin(); out_itr != node_out_list.end(); out_itr++) {
                    int target_node_id = get_target_node(*out_itr);
                    drawn_nodes_itr = drawn_nodes.find(target_node_id);
                    if (drawn_nodes_itr == drawn_nodes.end()) {

                        // not required right now
                        // get color of node
                        color_triple_new color_to_set2;
                        color_itr = node_color_map.find(target_node_id);
                        if (color_itr != node_color_map.end()) {
                            color_to_set2.red = (*color_itr).second.red;
                            color_to_set2.green = (*color_itr).second.green;
                            color_to_set2.blue = (*color_itr).second.blue;
                        }
                        //same goes
                        write_node_to_dot_file(fout, target_node_id, drawn_nodes, color_to_set2);

                    }
                    set<int> edge_nodes;
                    edge_nodes.insert(*itr);
                    edge_nodes.insert(target_node_id);
                    //undirected edge - so we draw it only once with no arrow
                    if (find(undirected_edges.begin(), undirected_edges.end(), edge_nodes) == undirected_edges.end()) {
                        fout << "\t" << *itr;
                        fout << " -> ";
                        fout << get_target_node(*out_itr);

                        string edge_type = get_edge_type(*out_itr);
                        vector<string> edge_subtypes = get_edge_subtypes_of_edge(*out_itr);
                        vector<string> edge_belongs_to_pathways = get_all_pathways_for_edge(*out_itr);

                        string arrowhead, style, label, color;
                        fout << "[";

                        vector<string>::iterator vec_str_itr;

                        for (vec_str_itr = edge_subtypes.begin(); vec_str_itr != edge_subtypes.end(); vec_str_itr++) {
                            if (*vec_str_itr == "association" || *vec_str_itr == "dissociation") {

                                arrowhead = "none";
                                style = "bold";

                                if (*vec_str_itr == "association") {
                                    label += "assoc\\n";
                                }
                                if (*vec_str_itr == "dissociation") {
                                    label += "dissoc\\n";
                                }
                                undirected_edges.push_back(edge_nodes);
                            }

                            if (*vec_str_itr == "inhibition") {
                                arrowhead = "tee";
                                label += "inhb\\n";
                            }

                            if (*vec_str_itr == "repression") {
                                arrowhead = "tee";
                                label += "repr\\n";
                            }

                            if (*vec_str_itr == "activation") {
                                label += "actv\\n";
                            }

                            if (*vec_str_itr == "expression") {
                                label += "expr\\n";
                            }

                            if (*vec_str_itr == "dephosphorylation") {
                                label += "-p\\n";
                            }

                            if (*vec_str_itr == "phosphorylation") {
                                label += "+p\\n";
                            }

                            if (*vec_str_itr == "indirect") {
                                style = "dashed";
                            }

                            if (*vec_str_itr == "component") {
                                label += "comp\\n";
                            }

                            if (*vec_str_itr == "PPI") {
                                label = "PPI";

                            }
                        }

                        if (edge_type == "PPrel") {
                            label = label + "PPrel\\n";
                        }
                        if (edge_type == "GErel") {
                            label = label + "GErel\\n";
                        }
                        if (edge_type == "PCrel") {
                            label = label + "PCrel\\n";
                        }
                        if (edge_type == "ECrel") {
                            label = label + "ECrel\\n";
                        }

                        for (vec_str_itr = edge_belongs_to_pathways.begin(); vec_str_itr != edge_belongs_to_pathways.end(); vec_str_itr++) {
                            label += *vec_str_itr + "\\n";
                        }

                        if ((color_visible_edges == 'y' || color_visible_edges == 'Y') && red_vis_edges.find(*out_itr) != red_vis_edges.end()) {
                            fout << "arrowhead=\"" << arrowhead << "\", style=\"" << style << "\", color=red, label=\"" << label << "\", ";
                        } else {
                            fout << "arrowhead=\"" << arrowhead << "\", style=\"" << style << "\", color=\"" << color << "\", label=\"" << label << "\", ";
                        }
                        fout << "arrowsize=1, penwidth = 2]";
                        fout << ";" << "\n";

                    }
                }
            }
        }
        fout << "}";
        fout.close();

        string xdot_path_name = XDOT_PATH_NAME;
        string systemCommand = xdot_path_name + dis_name + " & ";
        //string systemCommand =  xdot_path_name + dis_name;
        system(systemCommand.c_str());
    } else {
        cerr << "\nCouldn't open file for writing: " << dis_name << endl;
    }
}

void GraphNew::display_graph_richer_ordering_nodes(string color_map_filename, GraphManagerNew* gm) {
    map<int, color_triple_new> node_color_map;
    map<int, color_triple_new>::iterator color_itr;

    map<string, int> disp_name_nid_map;

    if (color_map_filename != "0") {
        ifstream ifs(color_map_filename.c_str());
        string node_id;
        int redValue, greenValue, blueValue;
        if (!ifs.is_open()) {
            cerr << "Error: the color file " + color_map_filename + " couldn't be opened. Returning without displaying..." << endl;
            return;
        }
        while (ifs >> node_id) {
            ifs >> redValue;
            ifs >> greenValue;
            ifs >> blueValue;

            color_triple_new color(redValue, greenValue, blueValue);

            string rep_id = get_rep_id_from_id(node_id);
            if (rep_id != "") {
                int nid = get_nid_from_rep_id(rep_id);
                node_color_map.insert(pair<int, color_triple_new>(nid, color));
            }
        }
    }

    std::string dis_name;
    std::cout << "\nEnter a file name for the graph display without .dot extension (e.g. mygraph): ";
    std::cin >> dis_name;

    string dis_name_dot = dis_name + ".dot";

    ofstream fout(dis_name_dot.c_str());

    if (fout.is_open()) {
        fout << "Digraph G  {\n";
        fout << "label = \"Graph " << this->graph_id << "\";\n";
        fout << "labelloc = top;\n";
        fout << "labeljust = left;\n";
        fout << "labelfontsize = 20.0;\n";
        fout << "edge [style=\"solid\"];\n";

        set<int> drawn_nodes;
        //set<int> drawn_edges;

        vector<set<int> > undirected_edges;

        // put the nodes in a map with the first display id as the key
        // this will sort the nodes (nids) based on the display names
        for (vector<int>::iterator itr = NIDSg.begin(); itr != NIDSg.end(); itr++) {
            int curr_nid = (*itr);
            string curr_disp_name = get_all_display_ids_of_node(curr_nid).front();
            disp_name_nid_map.insert(pair<string, int>(curr_disp_name, curr_nid));
        }

        // draw the nodes in the order of the display names
        map<string, int>::iterator map_iter;
        for (map_iter = disp_name_nid_map.begin(); map_iter != disp_name_nid_map.end(); map_iter++) {
            int curr_nid = (*map_iter).second;
            // get color of node
            color_triple_new color_to_set;
            color_itr = node_color_map.find(curr_nid);
            if (color_itr != node_color_map.end()) {
                color_to_set.red = (*color_itr).second.red;
                color_to_set.green = (*color_itr).second.green;
                color_to_set.blue = (*color_itr).second.blue;
            }
            write_node_to_dot_file_richer(gm, fout, curr_nid, drawn_nodes, color_to_set,  "solid", "#000000", 1);
        }

        // draw the edges
        for (vector<int>::iterator itr = NIDSg.begin(); itr != NIDSg.end(); itr++) {

            vector<int> node_out_list = get_outlist(*itr);

            if (!node_out_list.empty()) {
                for (vector<int>::iterator out_itr = node_out_list.begin(); out_itr != node_out_list.end(); out_itr++) {
                    int target_node_id = get_target_node(*out_itr);

                    set<int> edge_nodes;
                    edge_nodes.insert(*itr);
                    edge_nodes.insert(target_node_id);
                    //undirected edge - so we draw it onle once with no arrow
                    if (find(undirected_edges.begin(), undirected_edges.end(), edge_nodes) == undirected_edges.end()) {
                        fout << "\t" << *itr;
                        fout << " -> ";
                        fout << get_target_node(*out_itr);

                        string edge_type = get_edge_type(*out_itr);
                        vector<string> edge_subtypes = get_edge_subtypes_of_edge(*out_itr);
                        vector<string> edge_belongs_to_pathways = get_all_pathways_for_edge(*out_itr);

                        string label = " ";
                        string arrowhead, style, color;
                        fout << "[";

                        vector<string>::iterator vec_str_itr;

                        for (vec_str_itr = edge_subtypes.begin(); vec_str_itr != edge_subtypes.end(); vec_str_itr++) {
                            if (*vec_str_itr == "association" || *vec_str_itr == "dissociation" || *vec_str_itr == "reaction") {

                                arrowhead = "none";

                                if (*vec_str_itr == "association") {
                                    label += " assoc";
                                }
                                if (*vec_str_itr == "dissociation") {
                                    label += " dissoc";
                                }
                                if (*vec_str_itr == "component") {
                                    label += " comp";
                                }
                                undirected_edges.push_back(edge_nodes);
                            }

                            if (*vec_str_itr == "inhibition") {
                                arrowhead = "tee";
                                label += "inhb ";
                            }

                            if (*vec_str_itr == "repression") {
                                arrowhead = "tee";
                                label += "repr ";
                            }

                            if (*vec_str_itr == "activation") {
                                label += "actv ";
                            }

                            if (*vec_str_itr == "expression") {
                                label += "expr ";
                            }

                            if (*vec_str_itr == "dephosphorylation") {
                                label += "-p ";
                            }

                            if (*vec_str_itr == "phosphorylation") {
                                label += "+p ";
                            }

                            if (*vec_str_itr == "indirect") {
                                style = "dashed";
                            }

                            if (*vec_str_itr == "PPI") {
                                label = "PPI ";
                            }

                            if (*vec_str_itr == "name_map") {
                                style = "dotted";
                                color = "blue";
                            }
                        }

                        //                        if (edge_type == "PPrel") {
                        //                            label = label + "PPrel\\n";
                        //                        }
                        //                        if (edge_type == "GErel") {
                        //                            label = label + "GErel\\n";
                        //                        }
                        //                        if (edge_type == "PCrel") {
                        //                            label = label + "PCrel\\n";
                        //                        }
                        //                        if (edge_type == "ECrel") {
                        //                            label = label + "ECrel\\n";
                        //                        }

                        //                        for (vec_str_itr = edge_belongs_to_pathways.begin(); vec_str_itr != edge_belongs_to_pathways.end(); vec_str_itr++) {
                        //                            label += *vec_str_itr + "\\n";
                        //                        }
                        //                        for (vec_str_itr = edge_belongs_to_pathways.begin(); vec_str_itr != edge_belongs_to_pathways.end(); vec_str_itr++) {
                        //                            label += *vec_str_itr + "\\n";
                        //                        }

                        fout << "arrowhead=\"" << arrowhead << "\", arrowsize=0.7, style=\"" << style << "\", color=\"" << color << "\", label=< <TABLE BORDER=\"0\" CELLBORDER=\"0\" CELLSPACING=\"0\">\n ";
                        EdgeNew * edge = get_edge_from_eid(*out_itr);
                        vector<string> all_path_vec = get_all_pathways_for_edge(*out_itr);
                        //fout << "<TR><TD TOOLTIP=\"" << get_all_display_ids_of_node(get_source_node(edge->get_edge_id())).front() << "-" << get_all_display_ids_of_node(get_target_node(edge->get_edge_id())).front() << "\">" << label << "</TD></TR>\n";
                        fout << "<TR><TD>" << label << "</TD></TR>\n";
                        for (int i = 0; i < all_path_vec.size(); i++) {

                            string curr_path = all_path_vec.at(i);
                            string pathway_name = gm->get_pathway_names_from_path_id(curr_path);
                            if (curr_path.substr(0, 8) == "path:hsa") {
                                fout << "<TR><TD TOOLTIP=\"KEGG:" << pathway_name << "\" HREF=\"http://www.genome.jp/kegg-bin/show_pathway?" << curr_path.substr(5) << "\"><FONT POINT-SIZE=\"12\" COLOR=\"grey\">KEGG:" << curr_path.substr(5) << "</FONT></TD></TR>" << endl;
                            } else if (curr_path.substr(0, 8) == "pathway_") {
                                fout << "<TR><TD TOOLTIP=\"Reactome:" << pathway_name << "\" HREF=\"http://www.reactome.org/content/detail/R-HSA-" << curr_path.substr(8) << "\"><FONT POINT-SIZE=\"12\" COLOR=\"grey\">Reactome:" << curr_path << "</FONT></TD></TR>";

                            } else {
                                fout << "<TR><TD TOOLTIP=\"" << curr_path << "\" ><FONT POINT-SIZE=\"12\" COLOR=\"grey\">" << curr_path << "</FONT></TD></TR>" << endl;
                            }

                            //                            else if(curr_id.substr(0,7) == "uniprot"){
                            //                        myfile << "<TR><TD TOOLTIP=\"" << "UniProt: " << curr_id.substr(8) << "\" " << "HREF=\"http://www.uniprot.org/uniprot/" << curr_id.substr(8) << "\"><FONT POINT-SIZE=\"12\" COLOR=\"grey\">" << "UniProt: " << curr_id.substr(8) << "</FONT></TD></TR>" << endl;
                            //                    }
                        }
                        fout << "</TABLE>>" << endl;


                        fout << "]";
                        fout << ";" << "\n";

                    }
                }
            }
        }
        fout << "}";
        fout.close();

        string dot_path_name = DOT_PATH_NAME;
        string systemCommand1 = dot_path_name + "-Tcmapx " + dis_name + ".dot -o " + dis_name + ".cmapx & ";
        system(systemCommand1.c_str());

        string systemCommand2 = dot_path_name + "-Tsvg " + dis_name + ".dot -o " + dis_name + ".svg & ";
        system(systemCommand2.c_str());

        string systemCommand3 = "firefox " + dis_name + ".svg &";
        system(systemCommand3.c_str());

    } else {
        cerr << "\nCouldn't open file for writing: " << dis_name << endl;
    }
}

void GraphNew::display_graph_richer_clustering_nodes(string color_map_filename, GraphManagerNew* gm) {
    map<int, color_triple_new> node_color_map;
    map<int, color_triple_new>::iterator color_itr;

    //    map<string, set<int> > disp_name_nid_map;
    //    map<string, set<int> >::iterator umap_itr;
    unordered_map<string, set<int> > disp_name_nid_map;
    unordered_map<string, set<int> >::iterator umap_itr;

    if (color_map_filename != "0") {
        ifstream ifs(color_map_filename.c_str());
        string node_id;
        int redValue, greenValue, blueValue;
        if (!ifs.is_open()) {
            cerr << "Error: the color file " + color_map_filename + " couldn't be opened. Returning without displaying..." << endl;
            return;
        }
        while (ifs >> node_id) {
            ifs >> redValue;
            ifs >> greenValue;
            ifs >> blueValue;

            color_triple_new color(redValue, greenValue, blueValue);

            string rep_id = get_rep_id_from_id(node_id);
            if (rep_id != "") {
                int nid = get_nid_from_rep_id(rep_id);
                node_color_map.insert(pair<int, color_triple_new>(nid, color));
            }
        }
    }

    std::string dis_name;
    std::cout << "\nEnter a file name for the graph display without .dot extension (e.g. mygraph): ";
    std::cin >> dis_name;

    string dis_name_dot = dis_name + ".dot";

    ofstream fout(dis_name_dot.c_str());

    if (fout.is_open()) {
        fout << "Digraph G  {\n";
        fout << "label = \"Graph " << this->graph_id << "\";\n";
        fout << "labelloc = top;\n";
        fout << "labeljust = left;\n";
        fout << "labelfontsize = 20.0;\n";
        fout << "edge [style=\"solid\"];\n";

        set<int> drawn_nodes;
        set<int> reaction_nodes;
        //set<int> drawn_edges;

        vector<set<int> > undirected_edges;

        // put the nodes in an unordered map with the first 3 characters of display id as the key
        for (vector<int>::iterator itr = NIDSg.begin(); itr != NIDSg.end(); itr++) {

            int curr_nid = (*itr);
            if (get_node_type(curr_nid) == "reaction") {
                reaction_nodes.insert(curr_nid);
                //                vector<int> in, out;
                //                in = get_inlist(curr_nid);
                //                out = get_outlist(curr_nid);
                //                string in_node_name = get_all_display_ids_of_node(in.front()).front();
                //                string out_node_name = get_all_display_ids_of_node(out.front()).front();
                //                if (in.size() == 1 && out.size() == 1 && (in_node_name.substr(0,3) == out_node_name.substr(0,3))){
                //                    string substr = in_node_name.substr(0,3);
                //                    
                //                    umap_itr = disp_name_nid_map.find(substr);
                //                    if (umap_itr == disp_name_nid_map.end()) {
                //                        set<int> curr_ids;
                //                        curr_ids.insert(curr_nid);
                //                        disp_name_nid_map.insert(pair<string, set<int> >(substr, curr_ids));
                //                    }
                //                    else {
                //                        (*umap_itr).second.insert(curr_nid);
                //                    }
                //                }
            } else {
                string curr_disp_name = get_all_display_ids_of_node(curr_nid).front();

                // remove heading 'active' and 'activated' terms - remove upto first whitespace
                if (curr_disp_name.substr(0, 5) == "activ" || curr_disp_name.substr(0, 5) == "Activ") {

                    string::size_type spac;
                    spac = curr_disp_name.find(" ", 0);
                    curr_disp_name = curr_disp_name.substr(spac + 1);

                }

                string substr = curr_disp_name.substr(0, 3);
                std::transform(substr.begin(), substr.end(), substr.begin(), ::toupper); //converts substr (future key of the unordered map) to uppercase - handles mixed cases

                umap_itr = disp_name_nid_map.find(substr);
                if (umap_itr == disp_name_nid_map.end()) {
                    set<int> curr_ids;
                    curr_ids.insert(curr_nid);
                    disp_name_nid_map.insert(pair<string, set<int> >(substr, curr_ids));
                } else {
                    (*umap_itr).second.insert(curr_nid);
                }
            }
        }
        // write the clusters in the dot files
        int cluster_num = 0;

        for (umap_itr = disp_name_nid_map.begin(); umap_itr != disp_name_nid_map.end(); umap_itr++) {
            set<int> cluster_content = (*umap_itr).second;
            cout << (*umap_itr).first << " - " << (*umap_itr).second.size() << endl;

            //fout << "subgraph cluster_" << cluster_num << " {\n";
            fout << "subgraph {\n";
            fout << "style=filled;\n";
            fout << "color=lightgrey;\n";
            string invis_path = "";
            for (set<int>::iterator set_itr = cluster_content.begin(); set_itr != cluster_content.end(); set_itr++) {
                // get color of node
                color_triple_new color_to_set;
                color_itr = node_color_map.find(*set_itr);
                if (color_itr != node_color_map.end()) {
                    color_to_set.red = (*color_itr).second.red;
                    color_to_set.green = (*color_itr).second.green;
                    color_to_set.blue = (*color_itr).second.blue;
                }
                write_node_to_dot_file_richer(gm, fout, *set_itr, drawn_nodes, color_to_set,  "solid", "#000000", 1);
                invis_path = invis_path + (*set_itr) + " -> ";
            }

            invis_path = invis_path.substr(0, invis_path.size() - 4);
            if (cluster_content.size() > 1)
                fout << invis_path << " [arrowhead=\"none\", style = invisible];\n";
            fout << " label = \"\";\n";
            fout << "}\n";
            cluster_num++;
        }

        // write the reaction nodes separately
        for (set<int>::iterator itr = reaction_nodes.begin(); itr != reaction_nodes.end(); itr++) {
            // get color of node
            color_triple_new color_to_set;
            color_itr = node_color_map.find(*itr);
            if (color_itr != node_color_map.end()) {
                color_to_set.red = (*color_itr).second.red;
                color_to_set.green = (*color_itr).second.green;
                color_to_set.blue = (*color_itr).second.blue;
            }
            write_node_to_dot_file_richer(gm, fout, *itr, drawn_nodes, color_to_set,  "solid", "#000000", 1);
        }



        // draw the edges
        for (vector<int>::iterator itr = NIDSg.begin(); itr != NIDSg.end(); itr++) {

            vector<int> node_out_list = get_outlist(*itr);

            if (!node_out_list.empty()) {
                for (vector<int>::iterator out_itr = node_out_list.begin(); out_itr != node_out_list.end(); out_itr++) {
                    int target_node_id = get_target_node(*out_itr);

                    set<int> edge_nodes;
                    edge_nodes.insert(*itr);
                    edge_nodes.insert(target_node_id);
                    //undirected edge - so we draw it onle once with no arrow
                    if (find(undirected_edges.begin(), undirected_edges.end(), edge_nodes) == undirected_edges.end()) {
                        fout << "\t" << *itr;
                        fout << " -> ";
                        fout << get_target_node(*out_itr);

                        string edge_type = get_edge_type(*out_itr);
                        vector<string> edge_subtypes = get_edge_subtypes_of_edge(*out_itr);
                        vector<string> edge_belongs_to_pathways = get_all_pathways_for_edge(*out_itr);

                        string label = " ";
                        string arrowhead, style, color;
                        fout << "[";

                        vector<string>::iterator vec_str_itr;

                        for (vec_str_itr = edge_subtypes.begin(); vec_str_itr != edge_subtypes.end(); vec_str_itr++) {
                            if (*vec_str_itr == "association" || *vec_str_itr == "dissociation" || *vec_str_itr == "reaction") {

                                arrowhead = "none";

                                if (*vec_str_itr == "association") {
                                    label += " assoc";
                                }
                                if (*vec_str_itr == "dissociation") {
                                    label += " dissoc";
                                }
                                if (*vec_str_itr == "reaction") {
                                    label += " reaction";
                                }
                                undirected_edges.push_back(edge_nodes);
                            }

                            if (*vec_str_itr == "inhibition") {
                                arrowhead = "tee";
                                label += "inhb ";
                            }

                            if (*vec_str_itr == "repression") {
                                arrowhead = "tee";
                                label += "repr ";
                            }

                            if (*vec_str_itr == "activation") {
                                label += "actv ";
                            }

                            if (*vec_str_itr == "expression") {
                                label += "expr ";
                            }

                            if (*vec_str_itr == "dephosphorylation") {
                                label += "-p ";
                            }

                            if (*vec_str_itr == "phosphorylation") {
                                label += "+p ";
                            }

                            if (*vec_str_itr == "indirect") {
                                style = "dashed";
                            }

                            if (*vec_str_itr == "component") {
                                label += "comp ";
                            }

                            if (*vec_str_itr == "PPI") {
                                label = "PPI ";

                            }
                        }

                        fout << "arrowhead=\"" << arrowhead << "\", arrowsize=0.7, style=\"" << style << "\", color=\"" << color << "\", label=< <TABLE BORDER=\"0\" CELLBORDER=\"0\" CELLSPACING=\"0\">\n ";
                        EdgeNew * edge = get_edge_from_eid(*out_itr);
                        vector<string> all_path_vec = get_all_pathways_for_edge(*out_itr);
                        //fout << "<TR><TD TOOLTIP=\"" << get_all_display_ids_of_node(get_source_node(edge->get_edge_id())).front() << "-" << get_all_display_ids_of_node(get_target_node(edge->get_edge_id())).front() << "\">" << label << "</TD></TR>\n";
                        fout << "<TR><TD>" << label << "</TD></TR>\n";
                        for (int i = 0; i < all_path_vec.size(); i++) {

                            string curr_path = all_path_vec.at(i);
                            string pathway_name = gm->get_pathway_names_from_path_id(curr_path);
                            if (curr_path.substr(0, 8) == "path:hsa") {
                                fout << "<TR><TD TOOLTIP=\"KEGG:" << pathway_name << "\" HREF=\"http://www.genome.jp/kegg-bin/show_pathway?" << curr_path.substr(5) << "\"><FONT POINT-SIZE=\"12\" COLOR=\"grey\">KEGG:" << curr_path.substr(5) << "</FONT></TD></TR>" << endl;
                            } else if (curr_path.substr(0, 8) == "pathway_") {
                                fout << "<TR><TD TOOLTIP=\"Reactome:" << pathway_name << "\" HREF=\"http://www.reactome.org/content/detail/R-HSA-" << curr_path.substr(8) << "\"><FONT POINT-SIZE=\"12\" COLOR=\"grey\">Reactome:" << curr_path << "</FONT></TD></TR>";

                            } else {
                                fout << "<TR><TD TOOLTIP=\"" << curr_path << "\" ><FONT POINT-SIZE=\"12\" COLOR=\"grey\">" << curr_path << "</FONT></TD></TR>" << endl;
                            }

                            //                            else if(curr_id.substr(0,7) == "uniprot"){
                            //                        myfile << "<TR><TD TOOLTIP=\"" << "UniProt: " << curr_id.substr(8) << "\" " << "HREF=\"http://www.uniprot.org/uniprot/" << curr_id.substr(8) << "\"><FONT POINT-SIZE=\"12\" COLOR=\"grey\">" << "UniProt: " << curr_id.substr(8) << "</FONT></TD></TR>" << endl;
                            //                    }
                        }
                        fout << "</TABLE>>" << endl;


                        fout << "]";
                        fout << ";" << "\n";

                    }
                }
            }
        }
        fout << "}";
        fout.close();

        string dot_path_name = DOT_PATH_NAME;
        string systemCommand1 = dot_path_name + "-Tcmapx " + dis_name + ".dot -o " + dis_name + ".cmapx & ";
        system(systemCommand1.c_str());

        string systemCommand2 = dot_path_name + "-Tsvg " + dis_name + ".dot -o " + dis_name + ".svg & ";
        system(systemCommand2.c_str());

        string systemCommand3 = "firefox " + dis_name + ".svg &";
        system(systemCommand3.c_str());

    } else {
        cerr << "\nCouldn't open file for writing: " << dis_name << endl;
    }
}

void GraphNew::display_graph_richer(string color_map_filename, GraphManagerNew* gm, string dis_name) {
    map<int, color_triple_new> node_color_map;
    map<int, color_triple_new>::iterator color_itr;

    if (color_map_filename != "0") {
        ifstream ifs(color_map_filename.c_str());
        string node_id;
        int redValue, greenValue, blueValue;
        if (!ifs.is_open()) {
            cerr << "Error: the color file " + color_map_filename + " couldn't be opened. Returning without displaying..." << endl;
            return;
        }
        while (ifs >> node_id) {
            ifs >> redValue;
            ifs >> greenValue;
            ifs >> blueValue;

            color_triple_new color(redValue, greenValue, blueValue);

            string rep_id = get_rep_id_from_id(node_id);
            if (rep_id != "") {
                int nid = get_nid_from_rep_id(rep_id);
                node_color_map.insert(pair<int, color_triple_new>(nid, color));
            }
        }
    }

    //    std::string dis_name;
    //    std::cout << "\nEnter a file name for the graph display without .dot extension (e.g. mygraph): ";
    //    std::cin >> dis_name;

    string dis_name_dot = dis_name + ".dot";

    //    std::string dis_name_dot;
    //    cout << "Enter filename (eg., mygraph.dot): ";
    //    cin >> dis_name_dot;

    ofstream fout(dis_name_dot.c_str());

    if (fout.is_open()) {
        fout << "Digraph G  {\n";
        fout << "label = \"Graph " << this->graph_id << "\";\n";
        fout << "labelloc = top;\n";
        fout << "labeljust = left;\n";
        fout << "labelfontsize = 20.0;\n";
        fout << "edge [style=\"solid\"];\n";

        set<int> drawn_nodes;
        //set<int> drawn_edges;

        vector<set<int> > undirected_edges;

        for (vector<int>::iterator itr = NIDSg.begin(); itr != NIDSg.end(); itr++) {
            set<int>::iterator drawn_nodes_itr = drawn_nodes.find(*itr);
            int curr_nid = *itr;
            if (is_isolated_node(curr_nid))
                continue;

            if (drawn_nodes_itr == drawn_nodes.end()) {//a node not already written
                // get color of node
                color_triple_new color_to_set;
                color_itr = node_color_map.find(curr_nid);
                if (color_itr != node_color_map.end()) {
                    color_to_set.red = (*color_itr).second.red;
                    color_to_set.green = (*color_itr).second.green;
                    color_to_set.blue = (*color_itr).second.blue;
                }
                write_node_to_dot_file_richer(gm, fout, curr_nid, drawn_nodes, color_to_set,  "solid", "#000000", 1);

            }
            vector<int> node_out_list = get_outlist(curr_nid);

            if (!node_out_list.empty()) {
                for (vector<int>::iterator out_itr = node_out_list.begin(); out_itr != node_out_list.end(); out_itr++) {
                    int target_node_id = get_target_node(*out_itr);
                    drawn_nodes_itr = drawn_nodes.find(target_node_id);
                    if (drawn_nodes_itr == drawn_nodes.end()) {

                        // get color of node
                        color_triple_new color_to_set2;
                        color_itr = node_color_map.find(target_node_id);
                        if (color_itr != node_color_map.end()) {
                            color_to_set2.red = (*color_itr).second.red;
                            color_to_set2.green = (*color_itr).second.green;
                            color_to_set2.blue = (*color_itr).second.blue;
                        }
                        write_node_to_dot_file_richer(gm, fout, target_node_id, drawn_nodes, color_to_set2,  "solid", "#000000", 1);

                    }
                    set<int> edge_nodes;
                    edge_nodes.insert(curr_nid);
                    edge_nodes.insert(target_node_id);
                    //undirected edge - so we draw it onle once with no arrow
                    if (find(undirected_edges.begin(), undirected_edges.end(), edge_nodes) == undirected_edges.end()) {
                        fout << "\t" << curr_nid;
                        fout << " -> ";
                        fout << get_target_node(*out_itr);

                        string edge_type = get_edge_type(*out_itr);
                        vector<string> edge_subtypes = get_edge_subtypes_of_edge(*out_itr);
                        vector<string> edge_belongs_to_pathways = get_all_pathways_for_edge(*out_itr);

                        //string label = " ";
                        
                        vector<float> weight_elements = get_weight_tuple_for_edge(*out_itr);
                        string wt_str = FloatToString(*weight_elements.begin());
                        
                        for (auto e = weight_elements.begin()+1; e != weight_elements.end(); e++) {
                            wt_str = wt_str + ", " + FloatToString(*e);
                        }
                        
                        string label = "[" + IntToString(*out_itr) + "]" + " {" + wt_str + "} " + get_edge_weight(*out_itr) + " ";
                        string arrowhead, style, color;
                        fout << "[";

                        vector<string>::iterator vec_str_itr;

                        for (vec_str_itr = edge_subtypes.begin(); vec_str_itr != edge_subtypes.end(); vec_str_itr++) {
                            if (*vec_str_itr == "association" || *vec_str_itr == "dissociation" || *vec_str_itr == "mapping" || *vec_str_itr == "component") {

                                arrowhead = "none";

                                if (*vec_str_itr == "association") {
                                    label += " assoc";
                                }
                                if (*vec_str_itr == "dissociation") {
                                    label += " dissoc";
                                }
                                if (*vec_str_itr == "mapping") {
                                    label += "map";
                                }
                                if (*vec_str_itr == "component") {
                                    label += " comp";
                                }

                                undirected_edges.push_back(edge_nodes);
                            }

                            if (*vec_str_itr == "inhibition") {
                                arrowhead = "tee";
                                label += "inhb ";
                            }

                            if (*vec_str_itr == "repression") {
                                arrowhead = "tee";
                                label += "repr ";
                            }

                            if (*vec_str_itr == "activation") {
                                label += "actv ";
                            }

                            if (*vec_str_itr == "expression") {
                                label += "expr ";
                            }

                            if (*vec_str_itr == "dephosphorylation") {
                                label += "-p ";
                            }

                            if (*vec_str_itr == "phosphorylation") {
                                label += "+p ";
                            }

                            if (*vec_str_itr == "indirect") {
                                label += "ind";
                                style = "dashed";
                            }

                            if (*vec_str_itr == "PPI") {
                                label += "PPI ";

                            }
                            if (*vec_str_itr == "reaction") {
                                label = "reaction";
                            }
                            if (*vec_str_itr == "mapping") {
                                style = "dashed";
                                color = "blue";

                            }
                        }

                        //                        if (edge_type == "PPrel") {
                        //                            label = label + "PPrel\\n";
                        //                        }
                        //                        if (edge_type == "GErel") {
                        //                            label = label + "GErel\\n";
                        //                        }
                        //                        if (edge_type == "PCrel") {
                        //                            label = label + "PCrel\\n";
                        //                        }
                        //                        if (edge_type == "ECrel") {
                        //                            label = label + "ECrel\\n";
                        //                        }

                        //                        for (vec_str_itr = edge_belongs_to_pathways.begin(); vec_str_itr != edge_belongs_to_pathways.end(); vec_str_itr++) {
                        //                            label += *vec_str_itr + "\\n";
                        //                        }
                        //                        for (vec_str_itr = edge_belongs_to_pathways.begin(); vec_str_itr != edge_belongs_to_pathways.end(); vec_str_itr++) {
                        //                            label += *vec_str_itr + "\\n";
                        //                        }

                        fout << "arrowhead=\"" << arrowhead << "\", arrowsize=1.3, style=\"" << style << "\", color=\"" << color << "\", label=< <TABLE BORDER=\"0\" CELLBORDER=\"0\" CELLSPACING=\"0\">\n ";
                        EdgeNew * edge = get_edge_from_eid(*out_itr);
                        vector<string> all_path_vec = get_all_pathways_for_edge(*out_itr);

                        //fout << "<TR><TD><FONT POINT-SIZE=\"10\" COLOR=\"black\">" << "[" << *out_itr << "] " << label << "</FONT></TD></TR>\n";
                        fout << "<TR><TD><FONT POINT-SIZE=\"10\" COLOR=\"black\">" << label << "</FONT></TD></TR>\n";
                        for (int i = 0; i < all_path_vec.size(); i++) {

                            string curr_path = all_path_vec.at(i);
                            string pathway_name = gm->get_pathway_names_from_path_id(curr_path);
                            if (curr_path.substr(0, 8) == "path:hsa") {
                                fout << "<TR><TD TOOLTIP=\"KEGG:" << pathway_name << "\" HREF=\"http://www.genome.jp/kegg-bin/show_pathway?" << curr_path.substr(5) << "\"><FONT POINT-SIZE=\"10\" COLOR=\"grey\">KEGG:" << curr_path.substr(5) << "</FONT></TD></TR>" << endl;
                            } else if (curr_path.substr(0, 8) == "pathway_") {
                                fout << "<TR><TD TOOLTIP=\"Reactome:" << pathway_name << "\" HREF=\"http://www.reactome.org/content/detail/R-HSA-" << curr_path.substr(8) << "\"><FONT POINT-SIZE=\"10\" COLOR=\"grey\">Reactome:" << curr_path << "</FONT></TD></TR>";

                            } else {
                                fout << "<TR><TD TOOLTIP=\"" << (*out_itr) << "\" ><FONT POINT-SIZE=\"12\" COLOR=\"black\">" << curr_path << "</FONT></TD></TR>" << endl;
                            }

                            //                            else if(curr_id.substr(0,7) == "uniprot"){
                            //                        myfile << "<TR><TD TOOLTIP=\"" << "UniProt: " << curr_id.substr(8) << "\" " << "HREF=\"http://www.uniprot.org/uniprot/" << curr_id.substr(8) << "\"><FONT POINT-SIZE=\"12\" COLOR=\"grey\">" << "UniProt: " << curr_id.substr(8) << "</FONT></TD></TR>" << endl;
                            //                    }
                        }
                        fout << "</TABLE>>" << endl;


                        fout << "]";
                        fout << ";" << "\n";

                    }
                }
            }
        }
        fout << "}";
        fout.close();

        string dot_path_name = DOT_PATH_NAME;
        string systemCommand1 = dot_path_name + "-Tcmapx " + dis_name + ".dot -o " + dis_name + ".cmapx & ";
        system(systemCommand1.c_str());

        string systemCommand2 = dot_path_name + "-Tsvg -Gsize=67! -Goverlap=scale " + dis_name + ".dot -o " + dis_name + ".svg & ";
        //string systemCommand2 = dot_path_name + "-Tsvg " + dis_name + ".dot -o " + dis_name + ".svg & ";
        system(systemCommand2.c_str());

        string systemCommand3 = "firefox " + dis_name + ".svg &";
        system(systemCommand3.c_str());

    } else {
        //cerr << "\nCouldn't open file for writing: " << dis_name << endl;
    }
}

void GraphNew::display_graph_richer_with_edge_color(string node_color_map_filename, string edge_color_map_filename, map<int,int>& eid_to_color_map, string active_nodes_filename, string inactive_nodes_filename, string relaxed_nodes_filename, string relaxed_edges_repids_filename, GraphManagerNew* gm, string dis_name) {
    
       
    // -- added by Sukanya on 8 Feb 2018
    // prints all primary display names of a merged node to a tab separated file
    string node_names_filename = dis_name + "_node_names_filename";
    ofstream nodes_ofs(node_names_filename.c_str());
    
    string edge_names_filename = dis_name + "_edge_names_filename";
    ofstream edges_ofs(edge_names_filename.c_str());
    // --
    
    map<int, color_triple_new> node_color_map, edge_color_map;
    map<int, color_triple_new>::iterator color_itr;
    
    set<int> active_nids;
    set<int> inactive_nids;
    set<int> relaxed_nids;
    set<int> relaxed_eids;

    if (node_color_map_filename != "0") {
        ifstream ifs(node_color_map_filename.c_str());
        string node_id;
        int redValue, greenValue, blueValue;
        if (!ifs.is_open()) {
            cerr << "Error: the color file " + node_color_map_filename + " couldn't be opened. Returning without displaying..." << endl;
            return;
        }
        while (ifs >> node_id) {
            ifs >> redValue;
            ifs >> greenValue;
            ifs >> blueValue;

            color_triple_new color(redValue, greenValue, blueValue);

            string rep_id = get_rep_id_from_id(node_id);
            if (rep_id != "") {
                int nid = get_nid_from_rep_id(rep_id);
                node_color_map.insert(pair<int, color_triple_new>(nid, color));
            }
        }
    }
    
    if (edge_color_map_filename != "0") {
        ifstream ifs(edge_color_map_filename.c_str());
        string src_node_id, tgt_node_id;
        int redValue, greenValue, blueValue;
        if (!ifs.is_open()) {
            cerr << "Error: the color file " + edge_color_map_filename + " couldn't be opened. Returning without displaying..." << endl;
            return;
        }
        while (ifs >> src_node_id) {
            ifs >> tgt_node_id;
            ifs >> redValue;
            ifs >> greenValue;
            ifs >> blueValue;

            color_triple_new color(redValue, greenValue, blueValue);

            string src_rep_id = get_rep_id_from_id(src_node_id);
            string tgt_rep_id = get_rep_id_from_id(tgt_node_id);
            set<int> eids;
            if (src_rep_id != "" && tgt_rep_id != "") {
                int src_nid = get_nid_from_rep_id(src_rep_id);
                int tgt_nid = get_nid_from_rep_id(tgt_rep_id);
                if (src_nid != -1 & tgt_nid != -1) {
                    get_all_eids_between_two_nodes(src_nid, tgt_nid, eids);
                }
                
                  
                for (set<int>::iterator e = eids.begin(); e != eids.end(); e++)
                    edge_color_map.insert(pair<int, color_triple_new>(*e, color));
            }
        }
    }

    if (active_nodes_filename != "0") {
        ifstream ifs(active_nodes_filename.c_str());
        string node_repid;
        
        if (!ifs.is_open()) {
            cerr << "Error: the color file " + active_nodes_filename + " couldn't be opened. Returning without displaying..." << endl;
            return;
        }
        while (ifs >> node_repid) {
            int nid = get_nid_from_rep_id(node_repid);
            if (nid != -1) {
                active_nids.insert(nid);
                
            }
        }
    }
    
    if (inactive_nodes_filename != "0") {
        ifstream ifs(inactive_nodes_filename.c_str());
        string node_repid;
        
        if (!ifs.is_open()) {
            cerr << "Error: the color file " + inactive_nodes_filename + " couldn't be opened. Returning without displaying..." << endl;
            return;
        }
        while (ifs >> node_repid) {
            int nid = get_nid_from_rep_id(node_repid);
            if (nid != -1) {
                inactive_nids.insert(nid);
                
            }
        }
    }
    
    if (relaxed_nodes_filename != "0") {
        ifstream ifs(relaxed_nodes_filename.c_str());
        string node_repid;
        string node_display_name;
        
        if (!ifs.is_open()) {
            cerr << "Error: the color file " + relaxed_nodes_filename + " couldn't be opened. Returning without displaying..." << endl;
            return;
        }
        while (ifs >> node_repid) {
            ifs >> node_display_name;
            int nid = get_nid_from_rep_id(node_repid);
            if (nid != -1) {
                relaxed_nids.insert(nid);
                
            }
        }
    }
    
    if (relaxed_edges_repids_filename != "0") {
        ifstream ifs(relaxed_edges_repids_filename.c_str());
        string src_repid, tgt_repid, types_as_string;
        int eid;
        
        if (!ifs.is_open()) {
            cerr << "Error: the color file " + relaxed_edges_repids_filename + " couldn't be opened. Returning without displaying..." << endl;
            return;
        }
        while (ifs >> src_repid) {
            ifs >> types_as_string;
            ifs >> tgt_repid;
            
            int src_nid = get_nid_from_rep_id(src_repid);
            int tgt_nid = get_nid_from_rep_id(tgt_repid);
            
            vector<int> outlist = get_outlist(src_nid);
            for (auto i = outlist.begin(); i != outlist.end(); i++) {
                int curr_eid = *i;
                int curr_tgt = get_target_node(curr_eid);
                
                if (curr_tgt != tgt_nid)
                    continue;
                
                string curr_eid_types_as_string = concatenate_strings(get_edge_subtypes_of_edge(curr_eid), "_");
                
                if (curr_eid_types_as_string == types_as_string) {
                    relaxed_eids.insert(curr_eid);
                }
            }
           
        }
    }

    string dis_name_dot = dis_name + ".dot";

    ofstream fout(dis_name_dot.c_str());

    if (fout.is_open()) {
        fout << "Digraph G  {\n";
        fout << "label = \"Graph " << this->graph_id << "\";\n";
        fout << "labelloc = top;\n";
        fout << "labeljust = left;\n";
        fout << "labelfontsize = 20.0;\n";
        fout << "edge [style=\"solid\"];\n";

        set<int> drawn_nodes;

        vector<set<int> > undirected_edges;

        for (vector<int>::iterator itr = NIDSg.begin(); itr != NIDSg.end(); itr++) {
            int curr_nid = *itr;
            
            // -- added by Sukanya on 8 Feb 2018
            // prints all primary display names of a merged node to a tab separated file
            
            // get all ids of nid
            
            if (get_node_type(curr_nid) == "group") {
                nodes_ofs << get_all_display_ids_of_node(curr_nid)[0] << endl;
            }
            else if (get_node_type(curr_nid) == "compound") {
                 nodes_ofs << get_rep_id_from_nid(curr_nid) << endl;
            }
            else { // any other type of node
                vector<string> all_ids_of_nid = get_all_ids_of_node(curr_nid);
                string curr_id = all_ids_of_nid[0];
                string name = gm->kegg_hsa_id_to_display_name_map[curr_id];
                if (name == "")
                    name = get_rep_id_from_id(curr_id);
                nodes_ofs << name;
                for (auto id_iter = all_ids_of_nid.begin()+1; id_iter != all_ids_of_nid.end(); id_iter++) {
                    curr_id = *id_iter;
                    name = gm->kegg_hsa_id_to_display_name_map[curr_id];
                    if (name == "")
                        name = get_rep_id_from_id(curr_id);
                    nodes_ofs << "\t" << name;
                    
                }
                nodes_ofs << endl;
            }
            
            // --
            
            
            
            set<int>::iterator drawn_nodes_itr = drawn_nodes.find(curr_nid);
            
            if (is_isolated_node(curr_nid))
                continue;

            if (drawn_nodes_itr == drawn_nodes.end()) {//a node not already written
                // get color of node
                color_triple_new color_to_set;
                color_itr = node_color_map.find(curr_nid);
                if (color_itr != node_color_map.end()) {
                    color_to_set.red = (*color_itr).second.red;
                    color_to_set.green = (*color_itr).second.green;
                    color_to_set.blue = (*color_itr).second.blue;
                }
                
                // penwidth and node border color for activation status
                int penwidth = 1;
                string border_color = "#000000";
                string node_style = "solid";
                if (active_nids.find(curr_nid) != active_nids.end()) {
                    penwidth = 10;
                    border_color = "#00FF00";
                }
                else if (inactive_nids.find(curr_nid) != inactive_nids.end()) {
                    penwidth = 10;
                    border_color = "#FF0000";
                }
                
                if (relaxed_nids.find(curr_nid) != relaxed_nids.end()) {
                    node_style = "dashed";
                }
                write_node_to_dot_file_richer(gm, fout, curr_nid, drawn_nodes, color_to_set, node_style, border_color, penwidth);

            }
            vector<int> node_out_list = get_outlist(curr_nid);

            if (!node_out_list.empty()) {
                for (vector<int>::iterator out_itr = node_out_list.begin(); out_itr != node_out_list.end(); out_itr++) {
                    int curr_edge_id = *out_itr;
                    
                    int edge_color_index = 0;
                    if (eid_to_color_map.find(curr_edge_id) != eid_to_color_map.end())
                        edge_color_index = eid_to_color_map[curr_edge_id]; 
                    
                    if (relaxed_eids.find(curr_edge_id) != relaxed_eids.end())
                        edge_color_index = 9;
                                        
                    color_triple_new edge_color_to_set;
                    color_itr = edge_color_map.find(curr_edge_id);
                    if (color_itr != edge_color_map.end()) {
                        edge_color_to_set.red = (*color_itr).second.red;
                        edge_color_to_set.green = (*color_itr).second.green;
                        edge_color_to_set.blue = (*color_itr).second.blue;
                    }

                    int target_node_id = get_target_node(curr_edge_id);
                    drawn_nodes_itr = drawn_nodes.find(target_node_id);
                    if (drawn_nodes_itr == drawn_nodes.end()) {

                        // get color of node
                        color_triple_new color_to_set2;
                        color_itr = node_color_map.find(target_node_id);
                        if (color_itr != node_color_map.end()) {
                            color_to_set2.red = (*color_itr).second.red;
                            color_to_set2.green = (*color_itr).second.green;
                            color_to_set2.blue = (*color_itr).second.blue;
                        }
                        
                        // penwidth and node border color for activation status
                        int penwidth = 1;
                        string border_color = "#000000";
                        string node_style = "solid";
                              
                        if (active_nids.find(target_node_id) != active_nids.end()) {
                            penwidth = 10;
                            border_color = "#00FF00";
                        }
                        else if (inactive_nids.find(target_node_id) != inactive_nids.end()) {
                            penwidth = 10;
                            border_color = "#FF0000";
                        }
                        if (relaxed_nids.find(target_node_id) != relaxed_nids.end()) {
                            node_style = "dashed";
                        }
                        write_node_to_dot_file_richer(gm, fout, target_node_id, drawn_nodes, color_to_set2, node_style, border_color, penwidth);

                    }
                    set<int> edge_nodes;
                    edge_nodes.insert(curr_nid);
                    edge_nodes.insert(target_node_id);
                    //undirected edge - so we draw it onle once with no arrow
                    if (find(undirected_edges.begin(), undirected_edges.end(), edge_nodes) == undirected_edges.end()) {
                        fout << "\t" << curr_nid;
                        fout << " -> ";
                        fout << get_target_node(curr_edge_id);

                        string edge_type = get_edge_type(curr_edge_id);
                        vector<string> edge_subtypes = get_edge_subtypes_of_edge(curr_edge_id);
                        vector<string> edge_belongs_to_pathways = get_all_pathways_for_edge(curr_edge_id);

                        string label = " ";
                        string arrowhead, style, color, penwidth;

                        penwidth = "";

                        if (edge_color_index >= 1 && edge_color_index <= NUM_OF_COLORS) {
                            color = COLOR_STR(edge_color_index - 1);
                        } else if (edge_color_index == 8) {
                            color = COLOR_STR(8);
                        } else if (edge_color_index == 9) {
                            color = COLOR_STR(9);
                        } else if (edge_color_map.find(curr_edge_id) != edge_color_map.end()) {
                            color = "#";

                            if (edge_color_to_set.red < 16) {
                                color = color + "0";
                            }
                            //myfile << hex << color.red;
                            std::stringstream stream1;
                            stream1 << std::hex << edge_color_to_set.red;
                            string hex_red(stream1.str());
                            color = color + hex_red;
                            if (edge_color_to_set.green < 16) {
                                color = color + "0";
                            }
                            std::stringstream stream2;
                            stream2 << std::hex << edge_color_to_set.green;
                            string hex_green(stream2.str());
                            color = color + hex_green;
                            //myfile << hex << color.green;
                            if (edge_color_to_set.blue < 16) {
                                color = color + "0";
                            }
                            std::stringstream stream3;
                            stream3 << std::hex << edge_color_to_set.blue;
                            string hex_blue(stream3.str());
                            color = color + hex_blue;
                            //myfile << hex << color.blue;
                            
                            
                            penwidth = "10";
                        }
                        
                        else {
                            color = "";
                        }

                        if (edge_color_index == 1) {
                            penwidth = "15";

                        } else if (edge_color_index == 2) {
                            penwidth = "12";

                        } else if (edge_color_index == 3) {
                            penwidth = "10";

                        } else if (edge_color_index >= 4 && edge_color_index <= NUM_OF_COLORS) {
                            penwidth = "7";
                        } else if (edge_color_index == 8) {
                            penwidth = "10";
                        } else if (edge_color_index == 9) {
                            penwidth = "4";
                        } else if (penwidth == "") {
                            penwidth = "1";
                        }
                        fout << "[";

                        vector<string>::iterator vec_str_itr;

                        for (vec_str_itr = edge_subtypes.begin(); vec_str_itr != edge_subtypes.end(); vec_str_itr++) {
                            if (*vec_str_itr == "association" || *vec_str_itr == "dissociation" || *vec_str_itr == "mapping" || *vec_str_itr == "component") {

                                arrowhead = "none";

                                if (*vec_str_itr == "association") {
                                    label += " assoc";
                                }
                                if (*vec_str_itr == "dissociation") {
                                    label += " dissoc";
                                }
                                if (*vec_str_itr == "mapping") {
                                    label += "map";
                                }
                                if (*vec_str_itr == "component") {
                                    label += " comp";
                                }

                                undirected_edges.push_back(edge_nodes);
                            }
                            
                            if (*vec_str_itr == "compound") {
                                label += " ";
                            }

                            if (*vec_str_itr == "inhibition") {
                                arrowhead = "tee";
                                label += "inhb ";
                            }

                            if (*vec_str_itr == "repression") {
                                arrowhead = "tee";
                                label += "repr ";
                            }

                            if (*vec_str_itr == "activation") {
                                label += "actv ";
                            }

                            if (*vec_str_itr == "expression") {
                                label += "expr ";
                            }

                            if (*vec_str_itr == "dephosphorylation") {
                                label += "-p ";
                            }

                            if (*vec_str_itr == "phosphorylation") {
                                label += "+p ";
                            }

                            if (*vec_str_itr == "indirect") {
                                label += "ind";
                                style = "dashed";
                            }

                            if (*vec_str_itr == "PPI") {
                                label += "PPI ";

                            }
                            if (*vec_str_itr == "reaction") {
                                label += "reaction";
                            }
                            if (*vec_str_itr == "mapping") {
                                style = "dashed";
                                color = "blue";

                            }
                        }

                        fout << "arrowhead=\"" << arrowhead << "\", arrowsize=1.3, style=\"" << style << "\", color=\"" << color << "\", penwidth=\"" << penwidth << "\", label=< <TABLE BORDER=\"0\" CELLBORDER=\"0\" CELLSPACING=\"0\">\n ";
                        EdgeNew * edge = get_edge_from_eid(*out_itr);
                        vector<string> all_path_vec = get_all_pathways_for_edge(*out_itr);
                        
                        
                        // -- printing to edge file
                        int out_eid = *out_itr;
                        string source_name = get_all_display_ids_of_node(get_source_node(out_eid))[0];
                        string target_name = get_all_display_ids_of_node(get_target_node(out_eid))[0];
                        string edge_types = concatenate_strings2(get_edge_subtypes_of_edge(out_eid), ",");
                        edges_ofs << source_name << "\t" << edge_types << "\t" << target_name << "\t" << gm->get_pathway_names_from_path_id(all_path_vec[0]);
                        for (auto pw_iter = all_path_vec.begin()+1; pw_iter != all_path_vec.end(); pw_iter++) {
                            edges_ofs << "\t" << gm->get_pathway_names_from_path_id(*pw_iter);
                        }
                        edges_ofs << endl;
                        // --
                        

                        //fout << "<TR><TD><FONT POINT-SIZE=\"10\" COLOR=\"black\">" << "[" << *out_itr << "] " << label << "</FONT></TD></TR>\n";
                        fout << "<TR><TD><FONT POINT-SIZE=\"10\" COLOR=\"black\">" << label << "</FONT></TD></TR>\n";
                        for (int i = 0; i < all_path_vec.size(); i++) {

                            string curr_path = all_path_vec.at(i);
                            string pathway_name = gm->get_pathway_names_from_path_id(curr_path);
                            
                            if (curr_path.substr(0, 8) == "path:hsa") {
                                fout << "<TR><TD TOOLTIP=\"KEGG:" << pathway_name << "\" HREF=\"http://www.genome.jp/kegg-bin/show_pathway?" << curr_path.substr(5) << "\"><FONT POINT-SIZE=\"10\" COLOR=\"grey\">KEGG:" << curr_path.substr(5) << "</FONT></TD></TR>" << endl;
                            } else if (curr_path.substr(0, 8) == "pathway_") {
                                fout << "<TR><TD TOOLTIP=\"Reactome:" << pathway_name << "\" HREF=\"http://www.reactome.org/content/detail/R-HSA-" << curr_path.substr(8) << "\"><FONT POINT-SIZE=\"10\" COLOR=\"grey\">Reactome:" << curr_path << "</FONT></TD></TR>";

                            } else {
                                fout << "<TR><TD TOOLTIP=\"" << (*out_itr) << "\" ><FONT POINT-SIZE=\"12\" COLOR=\"black\">" << curr_path << "</FONT></TD></TR>" << endl;
                            }

                            //                            else if(curr_id.substr(0,7) == "uniprot"){
                            //                        myfile << "<TR><TD TOOLTIP=\"" << "UniProt: " << curr_id.substr(8) << "\" " << "HREF=\"http://www.uniprot.org/uniprot/" << curr_id.substr(8) << "\"><FONT POINT-SIZE=\"12\" COLOR=\"grey\">" << "UniProt: " << curr_id.substr(8) << "</FONT></TD></TR>" << endl;
                            //                    }
                        }
                        fout << "</TABLE>>" << endl;


                        fout << "]";
                        fout << ";" << "\n";

                    }
                }
            }
        }
        fout << "}";
        fout.close();

        string dot_path_name = DOT_PATH_NAME;
        string systemCommand1 = dot_path_name + "-Tcmapx " + dis_name + ".dot -o " + dis_name + ".cmapx & ";
        system(systemCommand1.c_str());

        string systemCommand2 = dot_path_name + "-Tsvg -Gsize=67! -Goverlap=scale " + dis_name + ".dot -o " + dis_name + ".svg & ";
        //string systemCommand2 = dot_path_name + "-Tsvg " + dis_name + ".dot -o " + dis_name + ".svg & ";
        system(systemCommand2.c_str());

        string systemCommand3 = "firefox " + dis_name + ".svg &";
        system(systemCommand3.c_str());

        nodes_ofs.close();
        edges_ofs.close();
    } else {
        cerr << "\nCouldn't open file for writing: " << dis_name << endl;
    }
}

void GraphNew::write_graph_as_dot_richer_with_edge_color(string node_color_map_filename, string edge_color_map_filename, map<int,int>& eid_to_color_map, string active_nodes_filename, string inactive_nodes_filename, string relaxed_nodes_filename, string relaxed_edges_repids_filename, GraphManagerNew* gm, string dis_name) {
    
    // -- added by Sukanya on 8 Feb 2018
    // prints all primary display names of a merged node to a tab separated file
    string node_names_filename = dis_name + "_node_names_filename";
    ofstream names_ofs(node_names_filename.c_str());
    // --
    
    
    
    map<int, color_triple_new> node_color_map, edge_color_map;
    map<int, color_triple_new>::iterator color_itr;
    
    set<int> active_nids;
    set<int> inactive_nids;
    set<int> relaxed_nids;
    set<int> relaxed_eids;

    if (node_color_map_filename != "0") {
        ifstream ifs(node_color_map_filename.c_str());
        string node_id;
        int redValue, greenValue, blueValue;
        if (!ifs.is_open()) {
            cerr << "Error: the color file " + node_color_map_filename + " couldn't be opened. Returning without displaying..." << endl;
            return;
        }
        while (ifs >> node_id) {
            ifs >> redValue;
            ifs >> greenValue;
            ifs >> blueValue;

            color_triple_new color(redValue, greenValue, blueValue);

            string rep_id = get_rep_id_from_id(node_id);
            if (rep_id != "") {
                int nid = get_nid_from_rep_id(rep_id);
                node_color_map.insert(pair<int, color_triple_new>(nid, color));
            }
        }
    }
    
    if (edge_color_map_filename != "0") {
        ifstream ifs(edge_color_map_filename.c_str());
        string src_node_id, tgt_node_id;
        int redValue, greenValue, blueValue;
        if (!ifs.is_open()) {
            cerr << "Error: the color file " + edge_color_map_filename + " couldn't be opened. Returning without displaying..." << endl;
            return;
        }
        while (ifs >> src_node_id) {
            ifs >> tgt_node_id;
            ifs >> redValue;
            ifs >> greenValue;
            ifs >> blueValue;

            color_triple_new color(redValue, greenValue, blueValue);

            string src_rep_id = get_rep_id_from_id(src_node_id);
            string tgt_rep_id = get_rep_id_from_id(tgt_node_id);
            set<int> eids;
            if (src_rep_id != "" && tgt_rep_id != "") {
                int src_nid = get_nid_from_rep_id(src_rep_id);
                int tgt_nid = get_nid_from_rep_id(tgt_rep_id);
                if (src_nid != -1 & tgt_nid != -1) {
                    get_all_eids_between_two_nodes(src_nid, tgt_nid, eids);
                }
                
                  
                for (set<int>::iterator e = eids.begin(); e != eids.end(); e++)
                    edge_color_map.insert(pair<int, color_triple_new>(*e, color));
            }
        }
    }

    if (active_nodes_filename != "0") {
        ifstream ifs(active_nodes_filename.c_str());
        string node_repid;
        
        if (!ifs.is_open()) {
            cerr << "Error: the color file " + active_nodes_filename + " couldn't be opened. Returning without displaying..." << endl;
            return;
        }
        while (ifs >> node_repid) {
            int nid = get_nid_from_rep_id(node_repid);
            if (nid != -1) {
                active_nids.insert(nid);
                
            }
        }
    }
    
    if (inactive_nodes_filename != "0") {
        ifstream ifs(inactive_nodes_filename.c_str());
        string node_repid;
        
        if (!ifs.is_open()) {
            cerr << "Error: the color file " + inactive_nodes_filename + " couldn't be opened. Returning without displaying..." << endl;
            return;
        }
        while (ifs >> node_repid) {
            int nid = get_nid_from_rep_id(node_repid);
            if (nid != -1) {
                inactive_nids.insert(nid);
                
            }
        }
    }
    
    if (relaxed_nodes_filename != "0") {
        ifstream ifs(relaxed_nodes_filename.c_str());
        string node_repid;
        string node_display_name;
        
        if (!ifs.is_open()) {
            cerr << "Error: the color file " + relaxed_nodes_filename + " couldn't be opened. Returning without displaying..." << endl;
            return;
        }
        while (ifs >> node_repid) {
            ifs >> node_display_name;
            int nid = get_nid_from_rep_id(node_repid);
            if (nid != -1) {
                relaxed_nids.insert(nid);
                
            }
        }
    }
    
    if (relaxed_edges_repids_filename != "0") {
        ifstream ifs(relaxed_edges_repids_filename.c_str());
        string src_repid, tgt_repid, types_as_string;
        int eid;
        
        if (!ifs.is_open()) {
            cerr << "Error: the color file " + relaxed_edges_repids_filename + " couldn't be opened. Returning without displaying..." << endl;
            return;
        }
        while (ifs >> src_repid) {
            ifs >> types_as_string;
            ifs >> tgt_repid;
            
            int src_nid = get_nid_from_rep_id(src_repid);
            int tgt_nid = get_nid_from_rep_id(tgt_repid);
            
            vector<int> outlist = get_outlist(src_nid);
            for (auto i = outlist.begin(); i != outlist.end(); i++) {
                int curr_eid = *i;
                int curr_tgt = get_target_node(curr_eid);
                
                if (curr_tgt != tgt_nid)
                    continue;
                
                string curr_eid_types_as_string = concatenate_strings(get_edge_subtypes_of_edge(curr_eid), "_");
                
                if (curr_eid_types_as_string == types_as_string) {
                    relaxed_eids.insert(curr_eid);
                }
            }
           
        }
    }

    string dis_name_dot = dis_name + ".dot";

    ofstream fout(dis_name_dot.c_str());

    if (fout.is_open()) {
        fout << "Digraph G  {\n";
        fout << "label = \"Graph " << this->graph_id << "\";\n";
        fout << "labelloc = top;\n";
        fout << "labeljust = left;\n";
        fout << "labelfontsize = 20.0;\n";
        fout << "edge [style=\"solid\"];\n";

        set<int> drawn_nodes;

        vector<set<int> > undirected_edges;

        for (vector<int>::iterator itr = NIDSg.begin(); itr != NIDSg.end(); itr++) {
            int curr_nid = *itr;
            
            // -- added by Sukanya on 8 Feb 2018
            // prints all primary display names of a merged node to a tab separated file
            vector<string> names_vec = get_all_display_ids_of_node(curr_nid);
            names_ofs <<  names_vec[0];
            for (auto n = names_vec.begin()+1; n != names_vec.end(); n++) {
                names_ofs << "\t" << *n;
            }
            names_ofs << endl;
            // --
            
            set<int>::iterator drawn_nodes_itr = drawn_nodes.find(curr_nid);
            
            if (is_isolated_node(curr_nid))
                continue;

            if (drawn_nodes_itr == drawn_nodes.end()) {//a node not already written
                // get color of node
                color_triple_new color_to_set;
                color_itr = node_color_map.find(curr_nid);
                if (color_itr != node_color_map.end()) {
                    color_to_set.red = (*color_itr).second.red;
                    color_to_set.green = (*color_itr).second.green;
                    color_to_set.blue = (*color_itr).second.blue;
                }
                
                // penwidth and node border color for activation status
                int penwidth = 1;
                string border_color = "#000000";
                string node_style = "solid";
                if (active_nids.find(curr_nid) != active_nids.end()) {
                    penwidth = 10;
                    border_color = "#00FF00";
                }
                else if (inactive_nids.find(curr_nid) != inactive_nids.end()) {
                    penwidth = 10;
                    border_color = "#FF0000";
                }
                
                if (relaxed_nids.find(curr_nid) != relaxed_nids.end()) {
                    node_style = "dashed";
                }
                write_node_to_dot_file_richer(gm, fout, curr_nid, drawn_nodes, color_to_set, node_style, border_color, penwidth);
                
            }
            vector<int> node_out_list = get_outlist(curr_nid);

            if (!node_out_list.empty()) {
                for (vector<int>::iterator out_itr = node_out_list.begin(); out_itr != node_out_list.end(); out_itr++) {
                    int curr_edge_id = *out_itr;
                    
                    int edge_color_index = 0;
                    if (eid_to_color_map.find(curr_edge_id) != eid_to_color_map.end())
                        edge_color_index = eid_to_color_map[curr_edge_id]; 
                    
                    if (relaxed_eids.find(curr_edge_id) != relaxed_eids.end())
                        edge_color_index = 9;
                                        
                    color_triple_new edge_color_to_set;
                    color_itr = edge_color_map.find(curr_edge_id);
                    if (color_itr != edge_color_map.end()) {
                        edge_color_to_set.red = (*color_itr).second.red;
                        edge_color_to_set.green = (*color_itr).second.green;
                        edge_color_to_set.blue = (*color_itr).second.blue;
                    }

                    int target_node_id = get_target_node(curr_edge_id);
                    drawn_nodes_itr = drawn_nodes.find(target_node_id);
                    if (drawn_nodes_itr == drawn_nodes.end()) {

                        // get color of node
                        color_triple_new color_to_set2;
                        color_itr = node_color_map.find(target_node_id);
                        if (color_itr != node_color_map.end()) {
                            color_to_set2.red = (*color_itr).second.red;
                            color_to_set2.green = (*color_itr).second.green;
                            color_to_set2.blue = (*color_itr).second.blue;
                        }
                        
                        // penwidth and node border color for activation status
                        int penwidth = 1;
                        string border_color = "#000000";
                        string node_style = "solid";
                              
                        if (active_nids.find(target_node_id) != active_nids.end()) {
                            penwidth = 10;
                            border_color = "#00FF00";
                        }
                        else if (inactive_nids.find(target_node_id) != inactive_nids.end()) {
                            penwidth = 10;
                            border_color = "#FF0000";
                        }
                        if (relaxed_nids.find(target_node_id) != relaxed_nids.end()) {
                            node_style = "dashed";
                        }
                        write_node_to_dot_file_richer(gm, fout, target_node_id, drawn_nodes, color_to_set2, node_style, border_color, penwidth);

                    }
                    set<int> edge_nodes;
                    edge_nodes.insert(curr_nid);
                    edge_nodes.insert(target_node_id);
                    //undirected edge - so we draw it onle once with no arrow
                    if (find(undirected_edges.begin(), undirected_edges.end(), edge_nodes) == undirected_edges.end()) {
                        fout << "\t" << curr_nid;
                        fout << " -> ";
                        fout << get_target_node(curr_edge_id);

                        string edge_type = get_edge_type(curr_edge_id);
                        vector<string> edge_subtypes = get_edge_subtypes_of_edge(curr_edge_id);
                        vector<string> edge_belongs_to_pathways = get_all_pathways_for_edge(curr_edge_id);

                        string label = " ";
                        string arrowhead, style, color, penwidth;

                        penwidth = "";

                        if (edge_color_index >= 1 && edge_color_index <= NUM_OF_COLORS) {
                            color = COLOR_STR(edge_color_index - 1);
                        } else if (edge_color_index == 8) {
                            color = COLOR_STR(8);
                        } else if (edge_color_index == 9) {
                            color = COLOR_STR(9);
                        } else if (edge_color_map.find(curr_edge_id) != edge_color_map.end()) {
                            color = "#";

                            if (edge_color_to_set.red < 16) {
                                color = color + "0";
                            }
                            //myfile << hex << color.red;
                            std::stringstream stream1;
                            stream1 << std::hex << edge_color_to_set.red;
                            string hex_red(stream1.str());
                            color = color + hex_red;
                            if (edge_color_to_set.green < 16) {
                                color = color + "0";
                            }
                            std::stringstream stream2;
                            stream2 << std::hex << edge_color_to_set.green;
                            string hex_green(stream2.str());
                            color = color + hex_green;
                            //myfile << hex << color.green;
                            if (edge_color_to_set.blue < 16) {
                                color = color + "0";
                            }
                            std::stringstream stream3;
                            stream3 << std::hex << edge_color_to_set.blue;
                            string hex_blue(stream3.str());
                            color = color + hex_blue;
                            //myfile << hex << color.blue;
                            
                            
                            penwidth = "10";
                        }
                        
                        else {
                            color = "";
                        }

                        if (edge_color_index == 1) {
                            penwidth = "15";

                        } else if (edge_color_index == 2) {
                            penwidth = "12";

                        } else if (edge_color_index == 3) {
                            penwidth = "10";

                        } else if (edge_color_index >= 4 && edge_color_index <= NUM_OF_COLORS) {
                            penwidth = "7";
                        } else if (edge_color_index == 8) {
                            penwidth = "10";
                        } else if (edge_color_index == 9) {
                            penwidth = "4";
                        } else if (penwidth == "") {
                            penwidth = "1";
                        }
                        fout << "[";

                        vector<string>::iterator vec_str_itr;

                        for (vec_str_itr = edge_subtypes.begin(); vec_str_itr != edge_subtypes.end(); vec_str_itr++) {
                            if (*vec_str_itr == "association" || *vec_str_itr == "dissociation" || *vec_str_itr == "mapping" || *vec_str_itr == "component") {

                                arrowhead = "none";

                                if (*vec_str_itr == "association") {
                                    label += " assoc";
                                }
                                if (*vec_str_itr == "dissociation") {
                                    label += " dissoc";
                                }
                                if (*vec_str_itr == "mapping") {
                                    label += "map";
                                }
                                if (*vec_str_itr == "component") {
                                    label += " comp";
                                }

                                undirected_edges.push_back(edge_nodes);
                            }

                            if (*vec_str_itr == "inhibition") {
                                arrowhead = "tee";
                                label += "inhb ";
                            }

                            if (*vec_str_itr == "repression") {
                                arrowhead = "tee";
                                label += "repr ";
                            }

                            if (*vec_str_itr == "activation") {
                                label += "actv ";
                            }

                            if (*vec_str_itr == "expression") {
                                label += "expr ";
                            }

                            if (*vec_str_itr == "dephosphorylation") {
                                label += "-p ";
                            }

                            if (*vec_str_itr == "phosphorylation") {
                                label += "+p ";
                            }

                            if (*vec_str_itr == "indirect") {
                                label += "ind";
                                style = "dashed";
                            }

                            if (*vec_str_itr == "PPI") {
                                label += "PPI ";

                            }
                            if (*vec_str_itr == "reaction") {
                                label = "reaction";
                            }
                            if (*vec_str_itr == "mapping") {
                                style = "dashed";
                                color = "blue";

                            }
                        }

                        fout << "arrowhead=\"" << arrowhead << "\", arrowsize=1.3, style=\"" << style << "\", color=\"" << color << "\", penwidth=\"" << penwidth << "\", label=< <TABLE BORDER=\"0\" CELLBORDER=\"0\" CELLSPACING=\"0\">\n ";
                        EdgeNew * edge = get_edge_from_eid(*out_itr);
                        vector<string> all_path_vec = get_all_pathways_for_edge(*out_itr);

                        //fout << "<TR><TD><FONT POINT-SIZE=\"10\" COLOR=\"black\">" << "[" << *out_itr << "] " << label << "</FONT></TD></TR>\n";
                        fout << "<TR><TD><FONT POINT-SIZE=\"10\" COLOR=\"black\">" << label << "</FONT></TD></TR>\n";
                        for (int i = 0; i < all_path_vec.size(); i++) {

                            string curr_path = all_path_vec.at(i);
                            string pathway_name = gm->get_pathway_names_from_path_id(curr_path);
                            if (curr_path.substr(0, 8) == "path:hsa") {
                                fout << "<TR><TD TOOLTIP=\"KEGG:" << pathway_name << "\" HREF=\"http://www.genome.jp/kegg-bin/show_pathway?" << curr_path.substr(5) << "\"><FONT POINT-SIZE=\"10\" COLOR=\"grey\">KEGG:" << curr_path.substr(5) << "</FONT></TD></TR>" << endl;
                            } else if (curr_path.substr(0, 8) == "pathway_") {
                                fout << "<TR><TD TOOLTIP=\"Reactome:" << pathway_name << "\" HREF=\"http://www.reactome.org/content/detail/R-HSA-" << curr_path.substr(8) << "\"><FONT POINT-SIZE=\"10\" COLOR=\"grey\">Reactome:" << curr_path << "</FONT></TD></TR>";

                            } else {
                                fout << "<TR><TD TOOLTIP=\"" << (*out_itr) << "\" ><FONT POINT-SIZE=\"12\" COLOR=\"black\">" << curr_path << "</FONT></TD></TR>" << endl;
                            }

                            //                            else if(curr_id.substr(0,7) == "uniprot"){
                            //                        myfile << "<TR><TD TOOLTIP=\"" << "UniProt: " << curr_id.substr(8) << "\" " << "HREF=\"http://www.uniprot.org/uniprot/" << curr_id.substr(8) << "\"><FONT POINT-SIZE=\"12\" COLOR=\"grey\">" << "UniProt: " << curr_id.substr(8) << "</FONT></TD></TR>" << endl;
                            //                    }
                        }
                        fout << "</TABLE>>" << endl;


                        fout << "]";
                        fout << ";" << "\n";

                    }
                }
            }
        }
        fout << "}";
        fout.close();

        string dot_path_name = DOT_PATH_NAME;
        string systemCommand1 = dot_path_name + "-Tcmapx " + dis_name + ".dot -o " + dis_name + ".cmapx & ";
        system(systemCommand1.c_str());

        string systemCommand2 = dot_path_name + "-Tsvg -Gsize=67! -Goverlap=scale " + dis_name + ".dot -o " + dis_name + ".svg & ";
        //system(systemCommand2.c_str());

        
        names_ofs.close();
    } else {
        //cerr << "\nCouldn't open file for writing: " << dis_name << endl;
    }
}

void GraphNew::group_paths_by_similarity(map<int, vector<string> >& path_id_to_path_map, vector<int>& sorted_path_ids, int similarity_pc, int num_of_colors, map<int, vector<int> >& group_id_to_path_ids_map) {

    if (path_id_to_path_map.empty())
        return;

    assert(num_of_colors > 0);

    int group_id = 1;
    int curr_path_id = *sorted_path_ids.begin();

    vector<int> path_ids_in_curr_group;
    path_ids_in_curr_group.push_back(curr_path_id);

    group_id_to_path_ids_map[group_id] = path_ids_in_curr_group;
    
    vector<int> nids_in_curr_path;
    vector<string> repids_in_curr_path = path_id_to_path_map[curr_path_id];

    for (auto repid_itr = repids_in_curr_path.begin(); repid_itr != repids_in_curr_path.end(); repid_itr++) {
        string curr_repid = *repid_itr;
        int curr_nid = this->get_nid_from_rep_id(curr_repid);
        if (curr_nid == -1)
            continue;

        nids_in_curr_path.push_back(curr_nid);
    }

    int next_path_id;
    for (auto path_itr = sorted_path_ids.begin() + 1; path_itr != sorted_path_ids.end(); path_itr++) {
        next_path_id = *path_itr;
        //cout << "next_path_id " << next_path_id << endl;

        vector<int> nids_in_next_path;
        vector<string> repids_in_next_path = path_id_to_path_map[next_path_id];

        for (auto repid_itr = repids_in_next_path.begin(); repid_itr != repids_in_next_path.end(); repid_itr++) {
            string next_repid = *repid_itr;
            int next_nid = this->get_nid_from_rep_id(next_repid);
            if (next_nid == -1)
                continue;

            nids_in_next_path.push_back(next_nid);
        }

        // set-intersection
        vector<int> nids_intersect;
        set_intersection(nids_in_curr_path.begin(), nids_in_curr_path.end(), nids_in_next_path.begin(), nids_in_next_path.end(), inserter(nids_intersect, nids_intersect.begin()));


        // check similarity
        int similarity_with_next_path = (int) (((float) nids_intersect.size() / (float) nids_in_next_path.size()) * 100);
        cout << "sim " << similarity_with_next_path << endl;
        if (similarity_with_next_path >= similarity_pc) {
            path_ids_in_curr_group.push_back(next_path_id);
        }
        else {
            //group_id_to_path_ids_map.insert(pair<int, vector<int> >(group_id, path_ids_in_curr_group));
            group_id_to_path_ids_map[group_id] = path_ids_in_curr_group;
            path_ids_in_curr_group.clear();
            group_id++;
            if (group_id > num_of_colors)
                break;


            curr_path_id = next_path_id;
            next_path_id = *path_itr;
            nids_in_curr_path = nids_in_next_path;

            vector<int> path_ids_in_next_group;
            path_ids_in_curr_group.push_back(next_path_id);

            nids_in_next_path.clear();
            repids_in_next_path = path_id_to_path_map[next_path_id];

            for (auto repid_itr = repids_in_next_path.begin(); repid_itr != repids_in_next_path.end(); repid_itr++) {
                string next_repid = *repid_itr;
                int next_nid = this->get_nid_from_rep_id(next_repid);
                if (next_nid == -1)
                    continue;

                nids_in_next_path.push_back(next_nid);
            }

        }
        //group_id_to_path_ids_map.insert(pair<int, vector<int> >(group_id, path_ids_in_curr_group));
        group_id_to_path_ids_map[group_id] = path_ids_in_curr_group;

    }

}

void GraphNew::display_gomoryhu_tree(string color_map_filename, GraphManagerNew* gm) {
    map<int, color_triple_new> node_color_map;
    map<int, color_triple_new>::iterator color_itr;

    if (color_map_filename != "0") {
        ifstream ifs(color_map_filename.c_str());
        string node_id;
        int redValue, greenValue, blueValue;
        if (!ifs.is_open()) {
            cerr << "Error: the color file " + color_map_filename + " couldn't be opened. Returning without displaying..." << endl;
            return;
        }
        while (ifs >> node_id) {
            ifs >> redValue;
            ifs >> greenValue;
            ifs >> blueValue;

            color_triple_new color(redValue, greenValue, blueValue);

            string rep_id = get_rep_id_from_id(node_id);
            if (rep_id != "") {
                int nid = get_nid_from_rep_id(rep_id);
                node_color_map.insert(pair<int, color_triple_new>(nid, color));
            }
        }
    }

    std::string dis_name;
    std::cout << "\nEnter a file name for the graph display without .dot extension (e.g. mygraph): ";
    std::cin >> dis_name;

    string dis_name_dot = dis_name + ".dot";

    //std::string dis_name_dot;
    //std::cout << "\nEnter a file name for the graph display with .dot extension (e.g. mygraph): ";
    //std::cin >> dis_name_dot;



    ofstream fout(dis_name_dot.c_str());

    if (fout.is_open()) {
        fout << "Digraph G  {\n";
        fout << "label = \"Graph " << this->graph_id << "\";\n";
        fout << "labelloc = top;\n";
        fout << "labeljust = left;\n";
        fout << "labelfontsize = 30.0;\n";
        fout << "edge [arrowhead=none, color=red, penwidth=3, style=\"solid\"];\n";

        set<int> drawn_nodes;
        //set<int> drawn_edges;

        vector<set<int> > undirected_edges;

        for (vector<int>::iterator itr = NIDSg.begin(); itr != NIDSg.end(); itr++) {
            set<int>::iterator drawn_nodes_itr = drawn_nodes.find(*itr);

            if (drawn_nodes_itr == drawn_nodes.end()) {//a node not already written
                // get color of node
                color_triple_new color_to_set;
                color_itr = node_color_map.find(*itr);
                if (color_itr != node_color_map.end()) {
                    color_to_set.red = (*color_itr).second.red;
                    color_to_set.green = (*color_itr).second.green;
                    color_to_set.blue = (*color_itr).second.blue;
                }
                write_node_to_dot_file_richer(gm, fout, *itr, drawn_nodes, color_to_set, "solid", "#000000", 1);

            }
            vector<int> node_out_list = get_outlist(*itr);

            if (!node_out_list.empty()) {
                for (vector<int>::iterator out_itr = node_out_list.begin(); out_itr != node_out_list.end(); out_itr++) {
                    int target_node_id = get_target_node(*out_itr);
                    drawn_nodes_itr = drawn_nodes.find(target_node_id);
                    if (drawn_nodes_itr == drawn_nodes.end()) {

                        // get color of node
                        color_triple_new color_to_set2;
                        color_itr = node_color_map.find(target_node_id);
                        if (color_itr != node_color_map.end()) {
                            color_to_set2.red = (*color_itr).second.red;
                            color_to_set2.green = (*color_itr).second.green;
                            color_to_set2.blue = (*color_itr).second.blue;
                        }
                        write_node_to_dot_file_richer(gm, fout, target_node_id, drawn_nodes, color_to_set2,  "solid", "#000000", 1);

                    }
                    set<int> edge_nodes;
                    edge_nodes.insert(*itr);
                    edge_nodes.insert(target_node_id);
                    //undirected edge - so we draw it onle once with no arrow
                    if (find(undirected_edges.begin(), undirected_edges.end(), edge_nodes) == undirected_edges.end()) {
                        vector<string> edge_belongs_to_pathways = get_all_pathways_for_edge(*out_itr);
                        vector<string>::iterator vec_str_itr;

                        fout << "\t" << *itr;
                        fout << " -> ";
                        fout << get_target_node(*out_itr);

                        fout << "[";

                        string gh_label = "";
                        EdgeNew * edge = get_edge_from_eid(*out_itr);
                        vector<string> all_path_vec = get_all_pathways_for_edge(*out_itr);
                        int edge_count = 0;
                        for (vector<string>::iterator vec_itr = all_path_vec.begin(); vec_itr != all_path_vec.end(); vec_itr++) {
                            //                            if (edge_count > 30) {
                            //                                gh_label = gh_label + "&#10;" + "etc..";
                            //                                break;
                            //                            }
                            //string pathway_name = gm->get_pathway_names_from_path_id(*vec_itr);
                            gh_label = gh_label + " | " + *vec_itr;
                            edge_count++;
                        }
                        //gh_label = gh_label.substr(5);
                        fout << "label=< <TABLE BORDER=\"0\" CELLBORDER=\"0\" CELLSPACING=\"0\">\n ";
                        fout << "<TR><TD TITLE=\"" << gh_label << "\" HREF=\"#\" ><FONT POINT-SIZE=\"20\" COLOR=\"black\">" << all_path_vec.size() << "</FONT></TD></TR>" << endl;
                        //                        
                        fout << "</TABLE>>" << endl;


                        fout << "]";
                        fout << ";" << "\n";
                        //                        fout << "<TR><TD TOOLTIP=\"" << gh_label<< "\"><FONT POINT-SIZE=\"10\">" << all_path_vec.size() << "</FONT></TD></TR>" << endl;
                        //                        //fout << "arrowsize=0.7, TOOLTIP=\"5\", color=black, label=\"" << all_path_vec.size() << "\"";
                        //                       
                        //                        fout << "]";
                        //                        fout << ";" << "\n";

                    }
                }
            }
        }
        fout << "}";
        fout.close();

        string dot_path_name = DOT_PATH_NAME;
        string systemCommand1 = dot_path_name + "-Tcmapx " + dis_name + ".dot -o " + dis_name + ".cmapx & ";
        system(systemCommand1.c_str());

        //string systemCommand2 = dot_path_name + "-Gsize=50! -Goverlap=scale -Tsvg " + dis_name + ".dot -o " + dis_name + ".svg & ";
        string systemCommand2 = dot_path_name + " -Tsvg " + dis_name + ".dot -o " + dis_name + ".svg & ";
        system(systemCommand2.c_str());

        string systemCommand3 = "firefox " + dis_name + ".svg &";
        system(systemCommand3.c_str());

    } else {
        //cerr << "\nCouldn't open file for writing: " << dis_name << endl;
        cerr << "\nCouldn't open file for writing: " << dis_name_dot << endl;
    }
}

void GraphNew::write_to_xml_file(std::ofstream &fout, bool b_mode, string pathway_name) {
    string pathway;
    if (!b_mode) {
        cout << "Enter the pathway name: " << endl;
        cin >> pathway;
    } else {
        pathway = pathway_name;
    }
    fout << "<?xml version=\"1.0\"?>" << endl;
    fout << "<!DOCTYPE pathway SYSTEM \"http://www.kegg.jp/kegg/xml/KGML_v0.7.1_.dtd\">" << endl;
    fout << "<pathway name=\"" + pathway + "\">" << endl;

    map<int, int> nid_to_xml_node_id_map;

    int xml_node_id = 1;
    for (vector<int>::iterator nid_itr = NIDSg.begin(); nid_itr != NIDSg.end(); ++nid_itr) {
        nid_to_xml_node_id_map[*nid_itr] = xml_node_id;
        ++xml_node_id;
    }

    //write nodes to the xml file
    int count = 0;
    for (vector<int>::iterator nid_itr = NIDSg.begin(); nid_itr != NIDSg.end(); ++nid_itr) {
        write_node_to_xml_file(*nid_itr, nid_to_xml_node_id_map, fout);
        count++;
    }
    cout << count << " nodes written to xml file" << endl;
    //write edges to the xml file
    count = 0;
    for (vector<int>::iterator eid_itr = EIDSg.begin(); eid_itr != EIDSg.end(); ++eid_itr) {
        write_edge_to_xml_file(*eid_itr, nid_to_xml_node_id_map, fout);
        count++;
    }
    cout << count << " edges written to xml file" << endl;
    //close pathway tag
    fout << "</pathway>" << endl;
}

void GraphNew::set_delete_status_for_edge(int eid, bool status) {//added by anjan 22-03-17
    EdgeNew * edge = get_edge_from_eid(eid);
    if (edge == NULL) {
        cerr << "14. Not found edge with id " << eid << endl;
    } else {
        edge->set_edge_deleted_status(status);
    }
}

bool GraphNew::get_delete_status_for_edge(int eid) {//added by anjan 22-03-17
    EdgeNew * edge = get_edge_from_eid(eid);
    if (edge == NULL) {
        cerr << "9. Not found edge with id " << eid << endl;
        return false;
    } else {
        return edge->get_edge_deleted_status();
    }
}


vector<string> GraphManagerNew::tokenize_cmd(string cmd) {
    char *myString = const_cast<char*> (cmd.c_str());
    char *p = strtok(myString, " ");

    vector<string> token_cmd(100);
    int token_cnt = 0;

    cout << "----------------------------" << endl;
    while (p) {
        cout << p << " ";
        token_cmd[token_cnt++] = p;
        p = strtok(NULL, " ");
    }
    cout << endl;
    cout << "----------------------------" << endl;

    return token_cmd;
}

GraphManagerNew::GraphManagerNew(vector<string>& commands, int &cnt_cmd, bool b_mode) {
    //while (true) {



    // read all_id_map
    std::string input_file, line;
    if (!b_mode) {
        std::cout << "\nEnter the file path for name mapping file: ";
        std::cin >> input_file;
    } else {
        input_file = commands[cnt_cmd++];
    }
    //input_file = "all_id_map.txt";
    //input_file = "empty";

    std::ifstream fin;
    fin.open(input_file.c_str(), std::ifstream::in);
    if (fin.is_open()) {
        while (getline(fin, line)) {
            std::stringstream s(line);
            std::string id, repid;
            s >> id >> repid;
            all_id_map[id] = repid;
        }
        fin.close();


    } else {
        std::cerr << "\nUnable to open the file " + input_file << std::endl;
    }



    // read merge exception files
    //        std::string exception_file;
    //	std::cout << "\nEnter exception to merge file: ";
    //        std::cin >> exception_file;
    //	
    //                
    //        std::ifstream ex;
    //        ex.open(exception_file.c_str(), std::ifstream::in);
    //        if (ex.is_open()) {
    //            while (getline(ex, line)) {
    //                std::stringstream s(line);
    //                std::string id;
    //                s >> id;
    //                merge_exception_set.insert(id);
    //            }
    //            ex.close();
    //
    //
    //        }
    //        else{
    //            std::cerr << "\nUnable to open exception file " + exception_file << std::endl;
    //        }

    //        std::string exception_file;
    //	if(ip_file2 == ""){
    //	std::cout << "\nEnter exception to merge file: ";
    //        std::cin >> exception_file;
    //	}else{
    //		input_file = ip_file;
    //	}
    //                
    //        std::ifstream ex;
    //        ex.open(exception_file.c_str(), std::ifstream::in);
    //        if (ex.is_open()) {
    //            while (getline(ex, line)) {
    //                std::stringstream s(line);
    //                std::string id;
    //                s >> id;
    //                merge_exception_set.insert(id);
    //            }
    //            ex.close();
    //
    //
    //        }
    //        else{
    //            std::cerr << "\nUnable to open exception file " + exception_file << std::endl;
    //        }


    vector<string> token_cmd(100);
    int cmd_index = 0;
    if (b_mode)
        token_cmd = tokenize_cmd(commands[cnt_cmd++]);
    std::string exception_filename;
    if (!b_mode) {
        std::cout << "\nEnter exception to merge files (end by -1): ";
        std::cin >> exception_filename;
    } else {
        exception_filename = token_cmd[cmd_index++];
    }

    while (exception_filename != "-1") {
        std::ifstream ex;
        ex.open(exception_filename.c_str(), std::ifstream::in);
        if (ex.is_open()) {
            while (getline(ex, line)) {
                std::stringstream s(line);
                std::string id;
                s >> id;
                merge_exception_set.insert(id);
            }
            ex.close();
        } else {
            std::cout << "\nUnable to open exception file " + exception_filename << std::endl;
        }
        if (!b_mode)
            cin >> exception_filename;
        else
            exception_filename = token_cmd[cmd_index++];

    }

    // read kegg names file
    std::string kegg_map_file, entry;
    if (!b_mode) {
        std::cout << "Enter file path of id to display name map: ";
        std::cin >> kegg_map_file;
//        kegg_map_file = "all_names_new.txt";
    } else {
        kegg_map_file = commands[cnt_cmd++]; //-- don't forget to update the input file
//        kegg_map_file = "all_names_new.txt";

    }
    //kegg_map_file = "empty";

    std::ifstream kegg_in;
    kegg_in.open(kegg_map_file.c_str(), std::ifstream::in);
    if (kegg_in.is_open()) {
        while (getline(kegg_in, entry)) {
            std::stringstream k(entry);
            std::string hsa_id, name;
            k >> hsa_id >> name;
            kegg_hsa_id_to_display_name_map[hsa_id] = name;
        }
        kegg_in.close();
        std::cout << kegg_hsa_id_to_display_name_map.size() << std::endl;

    } else {
        std::cerr << "\nUnable to open file " + kegg_map_file << std::endl;
    }



    // read pathway names file
    std::string pathway_file, entry1;
    if (!b_mode) {
        std::cout << "Enter file path for pathway name map: ";
        std::cin >> pathway_file;
//        pathway_file = "paths.txt";
    } else {
        pathway_file = commands[cnt_cmd];// --don't forget to update the input file
//        pathway_file = "paths.txt";
    }

    std::ifstream path_in;
    path_in.open(pathway_file.c_str(), std::ifstream::in);
    if (path_in.is_open()) {
        while (getline(path_in, entry1)) {
            std::stringstream l(entry1);
            std::string path_id, path_name;
            l >> path_id >> path_name;
            pathway_name_map[path_id] = path_name;
        }
        path_in.close();
        std::cout << pathway_name_map.size() << std::endl;

    } else
        std::cerr << "\nUnable to open file " + pathway_file << std::endl;


}

GraphManagerNew::~GraphManagerNew() {

}

template<typename Key, typename Val>
void GraphManagerNew::add_to_map(std::map<Key, Val>& generic_map, Key k, Val v) {
    generic_map.insert(pair<Key, Val>(k, v));
}

template<typename Key, typename Val>
void GraphManagerNew::delete_from_map(std::map<Key, Val>& generic_map, Key k) {
    generic_map.erase(k);
}

template<typename Key, typename Val>
void GraphManagerNew::print_map(std::map<Key, Val>& generic_map, ofstream& fout) {
    for (typename map<Key, Val>::iterator itr = generic_map.begin(); itr != generic_map.end(); ++itr) {
        fout << itr->first << " ==> " << itr->second << endl;
    }
    fout << endl;
}

template<typename Data>
bool GraphManagerNew::is_subset(std::vector<Data> smaller_set, std::vector<Data> bigger_set) {
    sort(smaller_set.begin(), smaller_set.end());
    sort(bigger_set.begin(), bigger_set.end());
    vector<string> diff_set;
    set_difference(smaller_set.begin(), smaller_set.end(), bigger_set.begin(), bigger_set.end(), inserter(diff_set, diff_set.begin()));
    return diff_set.empty();
}

template<typename Data>
bool GraphManagerNew::intersection_empty(std::vector<Data> left_set, std::vector<Data> right_set) {
    sort(left_set.begin(), left_set.end());
    sort(right_set.begin(), right_set.end());
    vector<string> intersect_set;
    set_intersection(left_set.begin(), left_set.end(), right_set.begin(), right_set.end(), inserter(intersect_set, intersect_set.begin()));
    return intersect_set.empty();
}

void GraphManagerNew::read_edge_type_subtype_map() {
    string mapping_filename;
    cout << "Enter file for edge type/subtype mapping: ";
    cin >> mapping_filename;

    string line, delim, type;
    delim = " ";
    ifstream ifs(mapping_filename.c_str());
    cout << edge_type_subtype_map.size() << endl;
    if (ifs.is_open()) {
        while (getline(ifs, line)) {

            list<string> * tokens = get_list_of_names_from_string(line, delim);
            type = tokens->front();
            tokens->pop_front();
            list<string> subtype_list;
            while (!tokens->empty()) {
                subtype_list.push_back(tokens->front());
                tokens->pop_front();
            }
            edge_type_subtype_map[type] = subtype_list;
        }
        ifs.close();
        cout << edge_type_subtype_map.size() << endl;
    } else
        cerr << "Could not open file " << mapping_filename << endl;

}

inline map<string, list<string> > GraphManagerNew::get_edge_type_subtype_map() {
    return edge_type_subtype_map;
}

void GraphManagerNew::read_naming_map(string filename, unordered_map<string, set<string> > &nmap) {
    std::ifstream fin;
    string line;
    fin.open(filename.c_str(), std::ifstream::in);
    if (fin.is_open()) {
        while (getline(fin, line)) {
            stringstream l(line);
            string entry1, entry2;
            l >> entry1 >> entry2;
            set<string>& value_set1 = nmap[entry1];
            value_set1.insert(entry2);

            set<string>& value_set2 = nmap[entry2];
            value_set2.insert(entry1);

            //nmap[entry1].insert(entry2);
            //nmap[entry2].insert(entry1);
        }
        fin.close();
        //        for (unordered_map<string, set<string> >::iterator itr = nmap.begin(); itr != nmap.end(); itr++) {
        //            cout << (*itr).first << " :";
        //            set<string> value_set = (*itr).second;
        //            for (set<string>::iterator set_itr = value_set.begin(); set_itr != value_set.end(); set_itr++) {
        //                cout << " " << (*set_itr);
        //            }
        //            cout << endl;
        //        }
        cout << filename << " has " << nmap.size() << " entries" << endl;
    } else
        cerr << "\nUnable to open file " << filename << endl;

}

/*std::ifstream fin;
  fin.open(input_file.c_str(), std::ifstream::in);
  if (fin.is_open()) {
  while (getline(fin, line)) {
  std::stringstream s(line);
  std::string id, repid;
  s >> id >> repid;
  all_id_map[id] = repid;
  }
  fin.close();


  }
  else{
  std::cerr << "\nUnable to open the file " + input_file << std::endl;
  }*/

inline GraphNew* GraphManagerNew::get_graph(int gid) {
    std::map<int, GraphNew*>::iterator itr = graph_id_to_graph_map.find(gid);
    if (itr != graph_id_to_graph_map.end()) {
        return itr->second;
    } else {
        return NULL;
    }
}

inline int GraphManagerNew::get_latest_graph_id() {
    return graph_id_to_graph_map.end()->first;
}

void GraphManagerNew::fill_adj_matrix_for_graph(GraphNew * graph_ptr) {
    vector<int> num_of_nodes = graph_ptr->get_node_ids();
    int size = num_of_nodes.size();//; + 1;
    
    vector<int> eids = graph_ptr->get_edge_ids();

    graph_ptr->adj_matrix.resize(size);
    for (int i = 0 ; i < size ; i++ )
        graph_ptr->adj_matrix[i].resize(size, false);
    
    for (auto eid_iter = eids.begin(); eid_iter != eids.end(); eid_iter++) {
        int curr_eid = *eid_iter;
        
        int src_seq_num = GET_NODE_SEQ_NUM(graph_ptr, graph_ptr->get_source_node(curr_eid));
        int tgt_seq_num = GET_NODE_SEQ_NUM(graph_ptr, graph_ptr->get_target_node(curr_eid));
        graph_ptr->add_edge_to_adj_matrix(src_seq_num, tgt_seq_num);
        graph_ptr->adj_matrix[src_seq_num][tgt_seq_num] = true;
    }
    
}

bool GraphManagerNew::get_edge_presence_status_from_adj_matrix(GraphNew * graph_ptr, int i, int j) {
    return graph_ptr->get_edge_presence_status_from_adj_matrix(i, j);
}

inline void GraphManagerNew::add_graph(int gid, GraphNew* g) {
    graph_id_to_graph_map.insert(pair<int, GraphNew*>(gid, g));
}

GraphNew * GraphManagerNew::duplicate_graph(int old_gid) {
    GraphNew * old_graph = get_graph(old_gid);

    GraphNew * new_graph = new GraphNew();
    // creating and adding graph_id
    GraphManagerNew::graph_id_count++;
    int gid = GraphManagerNew::graph_id_count;
    new_graph->set_graph_id(gid);
    graph_id_to_graph_map[gid] = new_graph;

    // get all node ids from the old_graph
    std::vector<int> NIDSg1 = old_graph->get_node_ids();
    std::vector<int>::iterator itr;

    // copy all nodes from old_graph
    //cout << "start duplicating nodes of graph " << graph1->get_graph_id() << endl;
    for (itr = NIDSg1.begin(); itr != NIDSg1.end(); itr++) {
        int new_node_id = duplicate_node(new_graph, old_graph, (*itr));
    }
    // get all edge ids from the old_graph
    std::vector<int> EIDSg1 = old_graph->get_edge_ids();

    // copy all edges from old_graph
    for (itr = EIDSg1.begin(); itr != EIDSg1.end(); itr++) {
        int new_edge_id = duplicate_edge(new_graph, old_graph, (*itr));
    }


    // adding genesis information
    std::list<int> glist;
    glist.push_back(old_graph->get_graph_id());
    int result_gid = new_graph->get_graph_id();
    add_graph_genesis(result_gid, "Duplicated graph", glist);

    return new_graph;

}

int GraphManagerNew::convert_to_undirected_graph(int gid) {
    int new_gid = -1;

    GraphNew * old_graph_ptr = get_graph(gid);
    if (old_graph_ptr == NULL) {
        cerr << "Error: there is no graph for id " << gid << endl;
        return -1;
    }

    //new id for the new graph
    GraphNew* new_graph_ptr = new GraphNew;
    new_gid = ++GraphManagerNew::graph_id_count;
    new_graph_ptr->set_graph_id(new_gid);
    add_graph(new_gid, new_graph_ptr);


    // iterate and duplicate edges from original graph
    vector<int> eids = old_graph_ptr->get_edge_ids();
    vector<int>::iterator vec_itr;
    for (vec_itr = eids.begin(); vec_itr != eids.end(); vec_itr++) {
        int curr_eid = *vec_itr;
        int new_eid = -1;
        EdgeNew * curr_edge = old_graph_ptr->get_edge_from_eid(curr_eid);
        int curr_edge_src = old_graph_ptr->get_source_node(curr_eid);

        // if it is an undirected edge - no need to create the reverse edge, it will already exist
        if ((curr_edge->has_subtype("association")) || (curr_edge->has_subtype("dissociation")) || (curr_edge->has_subtype("mapping"))) {
            new_eid = duplicate_edge(new_graph_ptr, old_graph_ptr, curr_eid);

            new_graph_ptr->set_other_value1_in_edge(new_eid, curr_eid); // added by sukanya on 12 Nov 2016
            // keeps eid of original graph
        }            // if not an undirected edge
        else {
            // duplicate this edge
            new_eid = duplicate_edge(new_graph_ptr, old_graph_ptr, curr_eid);
            new_graph_ptr->set_other_value1_in_edge(new_eid, curr_eid); // added by sukanya on 12 Nov 2016
            // keeps eid of original graph

            // check if reverse edge is present in original graph
            int curr_edge_tgt = curr_edge->get_target();
            vector<int> outlist_of_tgt = old_graph_ptr->get_outlist(curr_edge_tgt);
            vector<int>::iterator vec_itr2;

            bool rev_edge_exists = false;
            for (vec_itr2 = outlist_of_tgt.begin(); vec_itr2 != outlist_of_tgt.end(); vec_itr2++) {
                if (old_graph_ptr->get_target_node(*vec_itr2) == curr_edge_src) {
                    rev_edge_exists = true;
                }
            }

            // if not present, create rev edge
            if (rev_edge_exists == false) {
                int rev_eid = new_graph_ptr->create_new_edge();
                if (rev_eid == -1) {
                    cerr << "Problem creating reverse edge" << endl;
                }
                new_graph_ptr->set_other_value1_in_edge(rev_eid, curr_eid); // added by sukanya on 12 Nov 2016
                // keeps eid of original graph
                new_graph_ptr->add_edge_id(rev_eid);
                add_edge_id_graph_id(rev_eid, new_graph_ptr->get_graph_id());
                new_graph_ptr->add_edge_type(rev_eid, new_graph_ptr->get_edge_type(new_eid));
                new_graph_ptr->add_edge_to_outlist_of_node(new_graph_ptr->get_target_node(new_eid), rev_eid);
                new_graph_ptr->add_edge_to_inlist_of_node(new_graph_ptr->get_source_node(new_eid), rev_eid);
                new_graph_ptr->add_source_node(rev_eid, new_graph_ptr->get_target_node(new_eid));
                new_graph_ptr->add_target_node(rev_eid, new_graph_ptr->get_source_node(new_eid));
                new_graph_ptr->add_subtype_for_edge(rev_eid, "dummy_d_to_u");
                new_graph_ptr->add_pathway_for_edge(rev_eid, "dummy_d_to_u");
                
                new_graph_ptr->set_edge_weight(rev_eid, old_graph_ptr->get_edge_weight(curr_eid)); // added by sukanya on 10 Apr 2017
                //new_graph_ptr->set_edge_weight(rev_eid, 0); // added by sukanya on 10 Apr 2017
                
            }

        }
    }


    
    // populate adjacency matrix
    //////fill_adj_matrix_for_graph(new_graph_ptr);

    //for genesis
    string oper = "create undirected graph from ";
    list<int> gid_list;
    gid_list.push_back(new_gid);
    add_graph_genesis(new_gid, oper, gid_list);
    return new_gid;
}

int GraphManagerNew::get_subgraph_edges_removed(int gid, set<int>& eids_to_remove) {
    int new_gid = -1;

    GraphNew * old_graph_ptr = get_graph(gid);
    if (old_graph_ptr == NULL) {
        cerr << "Error: there is no graph for id " << gid << endl;
        return -1;
    }

    //new id for the new graph
    GraphNew* new_graph_ptr = new GraphNew;
    new_gid = ++GraphManagerNew::graph_id_count;
    new_graph_ptr->set_graph_id(new_gid);
    add_graph(new_gid, new_graph_ptr);


    // populate adjacency matrix
    //fill_adj_matrix_for_graph(new_graph_ptr);
    
    // duplicate nodes - to make sure isolated nodes also get considered
    //    vector<int> nids = old_graph_ptr->get_node_ids();
    //    vector<int>::iterator vec_itr;
    //    for (vec_itr = nids.begin(); vec_itr != nids.end(); vec_itr++) {
    //
    //        int curr_nid = *vec_itr;
    //        int new_nid = -1;
    //        
    //        new_nid = duplicate_node(new_graph_ptr, old_graph_ptr, curr_nid);
    //    }
    //        
    //    assert(old_graph_ptr->get_node_ids().size() == new_graph_ptr->get_node_ids().size());


    // iterate and duplicate edges from original graph
    vector<int> eids = old_graph_ptr->get_edge_ids();
    for (auto vec_itr = eids.begin(); vec_itr != eids.end(); vec_itr++) {

        int curr_eid = *vec_itr;
        int new_eid = -1;


        if (eids_to_remove.find(curr_eid) != eids_to_remove.end()) {
            //cout << "Removing edge between " << old_graph_ptr->get_all_display_ids_of_node(old_graph_ptr->get_source_node(curr_eid))[0] << " and " 
            //        << old_graph_ptr->get_all_display_ids_of_node(old_graph_ptr->get_target_node(curr_eid))[0] << endl;
            continue;
        }

        if (old_graph_ptr->edge_has_subtype(curr_eid, "dummy_d_to_u")) {
            //if (old_graph_ptr->edge_has_subtype(curr_eid, "dummy_d_to_u") || old_graph_ptr->edge_has_subtype(curr_eid, "dummy_u_to_d")) {
            //cout << "Removing dummy edge" << endl;
            continue;
        }
#ifdef ONLY_INTERAC_EDGES_FOR_MINCUT
        if (NOT_INTERAC_EDGE(old_graph_ptr, curr_eid)) {
            continue;
        }
#endif 

        new_eid = duplicate_edge(new_graph_ptr, old_graph_ptr, curr_eid);


    }



    //for genesis
    string oper = "create undirected graph from ";
    list<int> gid_list;
    gid_list.push_back(new_gid);
    add_graph_genesis(new_gid, oper, gid_list);
    return new_gid;
}

void GraphManagerNew::add_graph_genesis(int gid, std::string oper, std::list<int> oper_graph_ids) {
    graph_genesis_new *gen = new graph_genesis_new(oper, oper_graph_ids);
    std::map<int, graph_genesis_new>::iterator itr = graph_id_to_genesis_map.find(gid);
    if (itr != graph_id_to_genesis_map.end()) {
        graph_id_to_genesis_map.erase(itr);
    }
    graph_id_to_genesis_map.insert(pair<int, graph_genesis_new>(gid, *gen));

}

void GraphManagerNew::print_genesis_new(int gid, std::ostream &fout) {
    fout << "Graph " << gid << ": ";
    std::map<int, graph_genesis_new>::iterator gen_itr = graph_id_to_genesis_map.find(gid);
    if (gen_itr != graph_id_to_genesis_map.end()) {
        fout << (*gen_itr).second.oper << " ";
        list<int> oper_graph_ids = (*gen_itr).second.operand_graph_ids;
        list<int>::iterator itr;
        for (itr = oper_graph_ids.begin(); itr != oper_graph_ids.end(); itr++) {
            fout << " " << (*itr);
        }
        fout << endl;
    } else
        fout << "No genesis info for graph " << gid << endl;
}

inline void GraphManagerNew::delete_graph_id_graph(int gid) {
    GraphNew* graph_to_delete = get_graph(gid);
    if (graph_to_delete == NULL) {
        cerr << "Error: graph with id " << gid << " doesn't exist ..., so the question of its deletion doesn't arise" << endl;
        return;
    }
    delete_from_map(graph_id_to_graph_map, gid);
    delete graph_to_delete;

}


inline int GraphManagerNew::get_graph_id_for_node(int nid) {
    std::map<int, int>::iterator itr = node_id_to_graph_id.find(nid);
    if (itr != node_id_to_graph_id.end()) {
        return itr->second;
    } else {
        return -1;
    }
}

inline int GraphManagerNew::get_graph_id_for_edge(int eid) {
    std::map<int, int>::iterator itr = edge_id_to_graph_id.find(eid);
    if (itr != edge_id_to_graph_id.end()) {
        return itr->second;
    } else {
        return -1;
    }
}

inline void GraphManagerNew::add_node_id_graph_id(int nid, int gid) {
    node_id_to_graph_id.insert(pair<int, int>(nid, gid));
}

inline void GraphManagerNew::delete_node_id_graph_id(int nid) {
    delete_from_map(node_id_to_graph_id, nid);
}

inline void GraphManagerNew::add_edge_id_graph_id(int eid, int gid) {
    edge_id_to_graph_id.insert(pair<int, int>(eid, gid));
}

inline void GraphManagerNew::delete_edge_id_graph_id(int eid) {
    delete_from_map(edge_id_to_graph_id, eid);
}

inline std::string GraphManagerNew::get_rep_id_for_id(std::string id) {
    std::map<std::string, std::string>::iterator itr = all_id_map.find(id);
    if (itr != all_id_map.end()) {
        return itr->second;
    } else {
        return "";
    }
}

void GraphManagerNew::add_rep_id_for_id(std::string id, std::string repid) {
    //add_to_map(all_id_map, id, repid);
    all_id_map[id] = repid;
}

std::vector<std::string> GraphManagerNew::get_all_ids_for_rep_id(std::string rep_id) {
    std::vector<std::string> all_ids_for_repid;
    std::map<std::string, std::string>::iterator itr;
    for (itr = all_id_map.begin(); itr != all_id_map.end(); ++itr) {
        if (itr->second == rep_id) {
            all_ids_for_repid.push_back(itr->first);
        }
    }
    return all_ids_for_repid;
}

string GraphManagerNew::get_display_names_of_all_ids_of_node(GraphNew * graph, int nid) {
    NodeNew * node = graph->get_node_from_nid(nid);
    string s = "";
    if (node == NULL)
        return s;
    
    
    vector<string> vec_all_ids = graph->get_all_ids_of_node(nid);
    vector<string> vec_all_disp;
    
    for (auto iter = vec_all_ids.begin(); iter != vec_all_ids.end(); iter++) {
        string name = kegg_hsa_id_to_display_name_map[*iter];
        if (name == "")
            name = *iter;
        vec_all_disp.push_back(name);
    }
    return concatenate_strings(vec_all_disp, ",");
    
}

std::string GraphManagerNew::get_identifier(std::string key) {
    std::map<std::string, std::string>::iterator map_iter = identifier_map.find(key);
    if (map_iter == identifier_map.end()) {
        return "";
    } else {
        return (*map_iter).second;
    }

}

inline std::string GraphManagerNew::get_display_names_from_rep_id(std::string rep_id) {
    std::map<std::string, std::string>::iterator map_iter = kegg_hsa_id_to_display_name_map.find(rep_id);
    if (map_iter == kegg_hsa_id_to_display_name_map.end()) {
        //cout << "Rep id " << rep_id << " not found in KEGG map" << endl;
        return rep_id;
    } else {
        return (*map_iter).second;
    }

}

inline std::string GraphManagerNew::get_pathway_names_from_path_id(std::string path_id) {
    std::map<std::string, std::string>::iterator map_iter = pathway_name_map.find(path_id);
    if (map_iter == pathway_name_map.end()) {
        return path_id;
    } else {
        return (*map_iter).second;
    }

}
//int GraphManagerNew::check_if_node_already_created(GraphNew * new_graph, std::string rep_id) {
//        // get all node ids from new graph
//        std::vector<int> all_nids = new_graph->get_node_ids();
//        std::vector<int>::iterator all_nid_itr;
//        
//        // for each node in new graph
//        for (all_nid_itr = all_nids.begin(); all_nid_itr != all_nids.end(); all_nid_itr++) {
//            // if node with same rep_id present in new graph, return that node
//            if (new_graph->get_rep_id_from_nid(*all_nid_itr) == rep_id) {
//            
//                 return (*all_nid_itr);
//            }
//        }
//        
//        return -1;
//        
//}

//int GraphManagerNew::check_if_edge_already_created(GraphNew * new_graph, int new_source_nid, int new_target_nid, std::string edge_type, std::vector<std::string> edge_subtypes) {
//        // get all edge ids from new graph
//        std::vector<int> all_eids = new_graph->get_edge_ids();
//        std::vector<int>::iterator all_eid_itr;
//        
//        // for each edge in new graph
//        for (all_eid_itr = all_eids.begin(); all_eid_itr != all_eids.end(); all_eid_itr++) {
//            // if source, target and edge type and subtypes match return that edge id -- not considering belongs to pathways
//            if(new_graph->get_source_node(*all_eid_itr) == new_source_nid &&
//               new_graph->get_target_node(*all_eid_itr) == new_target_nid &&
//               new_graph->get_edge_type(*all_eid_itr) == edge_type &&
//               new_graph->get_edge_subtypes_of_edge(*all_eid_itr) == edge_subtypes) {
//                        
//                return (*all_eid_itr);
//            }
//        }
//        return -1;
//}

int GraphManagerNew::duplicate_node(GraphNew * new_graph, GraphNew * old_graph, int nid, bool duplicate_check_flag) {

    if (new_graph == NULL || old_graph == NULL) {
        cerr << "Error in node duplication: the graphs are NULL" << endl;
        return -1;
    }
    if (get_graph_id_for_node(nid) != old_graph->get_graph_id()) {
        cerr << "Error in node duplication: nid vs graph mismatch:" << get_graph_id_for_node(nid) << " vs " << old_graph->get_graph_id() << endl;
        return -1;
    }

    // get node info from old graph
    std::string node_type = old_graph->get_node_type(nid);
    std::string rep_id = old_graph->get_rep_id_from_nid(nid); //
    std::vector<std::string> all_ids = old_graph->get_all_ids_of_node(nid);
    std::vector<std::string> disp_names = old_graph->get_all_display_ids_of_node(nid);
    std::vector<int> comp_ids = old_graph->get_component_ids_of_node(nid);

    // check if node with same rep_id already created
    int nid_to_check = (!duplicate_check_flag) ? -1 : new_graph->check_if_node_already_created(rep_id);
    if (nid_to_check != -1) {
        // return existing node id
        return nid_to_check;

    }
    ////    // check if node with same rep_id already created
    ////    vector<string> all_ids_of_new_node = old_graph->get_all_ids_for_rep_id(rep_id);
    ////    for(vector<string>::iterator vec_itr = all_ids_of_new_node.begin(); vec_itr != all_ids_of_new_node.end(); vec_itr++) {
    ////        string rep_id1 = new_graph->get_rep_id_from_id(*vec_itr);
    ////        if (rep_id1 != "") {
    ////            int nid_to_check = (!duplicate_check_flag) ? -1 : new_graph->check_if_node_already_created(rep_id1);
    ////            if (nid_to_check != -1) {
    ////                // return existing node id
    ////                cout << "Found node with rep_id " << rep_id1 << endl;
    ////                return nid_to_check;
    ////                
    ////            }
    ////        }
    ////    }



    // create new node
    //GraphManagerNew::node_id_count++;
    //int new_nid = GraphManagerNew::node_id_count;   // created id of new node
    int new_nid = new_graph->create_new_node();
    if (new_nid == -1) {
        cerr << "Error in creating new node" << endl;
    }

    int new_graph_id = new_graph->get_graph_id();
    add_node_id_graph_id(new_nid, new_graph_id);
    new_graph->add_node_id(new_nid);
    new_graph->add_rep_id_for_node(new_nid, rep_id); // added by sukanya

    // add node info on new node
    new_graph->add_node_type(new_nid, node_type);

    // fill the map id to rep id
    std::vector<std::string>::iterator itr;
    for (itr = all_ids.begin(); itr != all_ids.end(); itr++) {
        new_graph->add_id_rep_id((*itr), rep_id); //
    }

    new_graph->set_all_ids_for_node(new_nid, all_ids);

    for (itr = disp_names.begin(); itr != disp_names.end(); itr++) {
        // -- added by sukanya on 3rd July 2016
        string disp = (*itr);
        std::size_t found = disp.find_last_of(",");
        disp = disp.substr(0, found);
        new_graph->add_display_id_for_node(new_nid, disp);
        // --
        //new_graph->add_display_id_for_node(new_nid, (*itr));
    }
    new_graph->set_all_display_id_for_node(new_nid, disp_names);
    string desc = old_graph->get_description_for_node(nid);
    new_graph->add_description_for_node(new_nid, desc);
    new_graph->add_other_value1_to_node(new_nid, nid);
    // components
    if (node_type == "group") {
        std::vector<int>::iterator comp_it;
        for (comp_it = comp_ids.begin(); comp_it != comp_ids.end(); comp_it++) {

#ifdef DUP_CHECK_FLAG_SET
            int new_comp_node_id = duplicate_node(new_graph, old_graph, (*comp_it), duplicate_check_flag);
#else
            int new_comp_node_id = duplicate_node(new_graph, old_graph, (*comp_it));
#endif                    

            new_graph->add_component_id_for_node(new_nid, new_comp_node_id);
            
        }
    }

    return new_nid;
}


int GraphManagerNew::duplicate_node_without_splitting(GraphNew * new_graph, GraphNew * old_graph, int nid, bool duplicate_check_flag) {

    if (new_graph == NULL || old_graph == NULL) {
        cerr << "Error in node duplication: the graphs are NULL" << endl;
        return -1;
    }
    if (get_graph_id_for_node(nid) != old_graph->get_graph_id()) {
        cerr << "Error in node duplication: nid vs graph mismatch:" << get_graph_id_for_node(nid) << " vs " << old_graph->get_graph_id() << endl;
        return -1;
    }

    // get node info from old graph
    std::string node_type = old_graph->get_node_type(nid);
    std::string rep_id = old_graph->get_rep_id_from_nid(nid); //
    std::vector<std::string> all_ids = old_graph->get_all_ids_of_node(nid);
    std::vector<std::string> disp_names = old_graph->get_all_display_ids_of_node(nid);
    std::vector<int> comp_ids = old_graph->get_component_ids_of_node(nid);

    // check if node with same rep_id already created
    int nid_to_check = (!duplicate_check_flag) ? -1 : new_graph->check_if_node_already_created(rep_id);
    if (nid_to_check != -1) {
        // return existing node id
        return nid_to_check;

    }
    ////    // check if node with same rep_id already created
    ////    vector<string> all_ids_of_new_node = old_graph->get_all_ids_for_rep_id(rep_id);
    ////    for(vector<string>::iterator vec_itr = all_ids_of_new_node.begin(); vec_itr != all_ids_of_new_node.end(); vec_itr++) {
    ////        string rep_id1 = new_graph->get_rep_id_from_id(*vec_itr);
    ////        if (rep_id1 != "") {
    ////            int nid_to_check = (!duplicate_check_flag) ? -1 : new_graph->check_if_node_already_created(rep_id1);
    ////            if (nid_to_check != -1) {
    ////                // return existing node id
    ////                cout << "Found node with rep_id " << rep_id1 << endl;
    ////                return nid_to_check;
    ////                
    ////            }
    ////        }
    ////    }



    // create new node
    //GraphManagerNew::node_id_count++;
    //int new_nid = GraphManagerNew::node_id_count;   // created id of new node
    int new_nid = new_graph->create_new_node();
    if (new_nid == -1) {
        cerr << "Error in creating new node" << endl;
    }

    int new_graph_id = new_graph->get_graph_id();
    add_node_id_graph_id(new_nid, new_graph_id);
    new_graph->add_node_id(new_nid);
    new_graph->add_rep_id_for_node(new_nid, rep_id); // added by sukanya

    // add node info on new node
    new_graph->add_node_type(new_nid, node_type);

    // fill the map id to rep id
    std::vector<std::string>::iterator itr;
    for (itr = all_ids.begin(); itr != all_ids.end(); itr++) {
        new_graph->add_id_rep_id((*itr), rep_id); //
    }

    new_graph->set_all_ids_for_node(new_nid, all_ids);

    for (itr = disp_names.begin(); itr != disp_names.end(); itr++) {
        // -- added by sukanya on 3rd July 2016
        string disp = (*itr);
        std::size_t found = disp.find_last_of(",");
        disp = disp.substr(0, found);
        new_graph->add_display_id_for_node(new_nid, disp);
        // --
        //new_graph->add_display_id_for_node(new_nid, (*itr));
    }
    new_graph->set_all_display_id_for_node(new_nid, disp_names);
    string desc = old_graph->get_description_for_node(nid);
    new_graph->add_description_for_node(new_nid, desc);
    new_graph->add_other_value1_to_node(new_nid, nid);
    // components
//    if (node_type == "group") {
//        std::vector<int>::iterator comp_it;
//        for (comp_it = comp_ids.begin(); comp_it != comp_ids.end(); comp_it++) {
//
//#ifdef DUP_CHECK_FLAG_SET
//            int new_comp_node_id = duplicate_node(new_graph, old_graph, (*comp_it), duplicate_check_flag);
//#else
//            int new_comp_node_id = duplicate_node(new_graph, old_graph, (*comp_it));
//#endif                    
//
//            new_graph->add_component_id_for_node(new_nid, new_comp_node_id);
//            
//        }
//    }

    return new_nid;
}

int GraphManagerNew::duplicate_edge(GraphNew * new_graph, GraphNew * old_graph, int eid, bool duplicate_check_flag) {
    if (new_graph == NULL || old_graph == NULL) {
        cerr << "Error in edge duplication: the graphs are NULL" << endl;
        return -1;
    }
    if (get_graph_id_for_edge(eid) != old_graph->get_graph_id()) {
        cerr << "Error in edge duplication: eid vs graph mismatch" << endl;
        return -1;
    }

    // get corresponding source and target nodes in the new graph
    int old_source_nid = old_graph->get_source_node(eid);
    int old_target_nid = old_graph->get_target_node(eid);
    int new_source_nid = new_graph->get_nid_from_rep_id(old_graph->get_rep_id_from_nid(old_source_nid));
    if (new_source_nid == -1) {//the node is not there in the new graph

#ifdef DUP_CHECK_FLAG_SET
        new_source_nid = duplicate_node(new_graph, old_graph, old_source_nid, duplicate_check_flag);
#else
        new_source_nid = duplicate_node(new_graph, old_graph, old_source_nid);
#endif            

    }
    int new_target_nid = new_graph->get_nid_from_rep_id(old_graph->get_rep_id_from_nid(old_target_nid));
    if (new_target_nid == -1) {//the node is not there in the new graph
#ifdef DUP_CHECK_FLAG_SET
        new_target_nid = duplicate_node(new_graph, old_graph, old_target_nid, duplicate_check_flag);
#else
        new_target_nid = duplicate_node(new_graph, old_graph, old_target_nid);
#endif            

    }
    // get edge info from old graph
    //cout << "getting type of edge from old graph" << endl;
    std::string edge_type = old_graph->get_edge_type(eid);
    //cout << "getting subtypes from old graph" << endl;
    std::vector<std::string> edge_subtypes = old_graph->get_edge_subtypes_of_edge(eid);
    //cout << "getting belong pathways from old graph" << endl;
    std::vector<std::string> edge_belongs_to_pathways = old_graph->get_all_pathways_for_edge(eid);

    // check if edge between source and target exist with same labels
    int eid_to_check = (!duplicate_check_flag) ? -1 : new_graph->check_if_edge_already_created(new_source_nid, new_target_nid, edge_type, edge_subtypes);

#ifdef DUMMY_EDGE_FLAG                       
    if (eid_to_check == -1) {
        vector<string> subtype_copy = edge_subtypes;
        subtype_copy.push_back("dummy_u_to_d");
        eid_to_check = new_graph->check_if_edge_already_created(new_source_nid, new_target_nid, edge_type, subtype_copy);
    }
#endif    

    if (eid_to_check != -1) {
        // add pathway info for existing edge
        std::vector<std::string>::iterator path_itr;
        for (path_itr = edge_belongs_to_pathways.begin(); path_itr != edge_belongs_to_pathways.end(); path_itr++) {
            std::string path = *path_itr;
            if (!new_graph->edge_belongs_to_pathway(eid_to_check, path)) {
                new_graph->add_pathway_for_edge(eid_to_check, path);
            }
        }
        // return existing edge id
        return eid_to_check;
    }

    // create new edge
    //GraphManagerNew::edge_id_count++;
    //int new_eid = GraphManagerNew::edge_id_count;
    int new_eid = new_graph->create_new_edge();
    if (new_eid == -1) {
        cerr << "Error in creating new edge" << endl;
    }

    int new_graph_id = new_graph->get_graph_id();
    add_edge_id_graph_id(new_eid, new_graph_id);
    new_graph->add_edge_id(new_eid);

    // add edge info on new edge
    new_graph->add_source_node(new_eid, new_source_nid);
    new_graph->add_target_node(new_eid, new_target_nid);
    new_graph->add_edge_type(new_eid, edge_type);
    std::vector<std::string>::iterator itr;
    for (itr = edge_subtypes.begin(); itr != edge_subtypes.end(); itr++) {
        new_graph->add_subtype_for_edge(new_eid, (*itr));
    }
    for (itr = edge_belongs_to_pathways.begin(); itr != edge_belongs_to_pathways.end(); itr++) {
        new_graph->add_pathway_for_edge(new_eid, (*itr));
    }

    //insert new edge in outlist of source and inlist of target nodes
    new_graph->add_edge_to_outlist_of_node(new_source_nid, new_eid);
    new_graph->add_edge_to_inlist_of_node(new_target_nid, new_eid);
    
    new_graph->set_edge_weight(new_eid, old_graph->get_edge_weight(eid)); // added by sukanya on 10 Apr 2017
    new_graph->set_edge_weight_float(new_eid, old_graph->get_edge_weight_float(eid));
    new_graph->set_weight_tuple_for_edge(new_eid, old_graph->get_weight_tuple_for_edge(eid));
    
    new_graph->add_other_value1_to_node(new_source_nid, old_source_nid);
    new_graph->add_other_value1_to_node(new_target_nid, old_target_nid);
       
    return new_eid;
}

int GraphManagerNew::duplicate_edge_without_splitting_nodes(GraphNew * new_graph, GraphNew * old_graph, int eid, bool duplicate_check_flag) {
    if (new_graph == NULL || old_graph == NULL) {
        cerr << "Error in edge duplication: the graphs are NULL" << endl;
        return -1;
    }
    if (get_graph_id_for_edge(eid) != old_graph->get_graph_id()) {
        cerr << "Error in edge duplication: eid vs graph mismatch" << endl;
        return -1;
    }

    // get corresponding source and target nodes in the new graph
    int old_source_nid = old_graph->get_source_node(eid);
    int old_target_nid = old_graph->get_target_node(eid);
    int new_source_nid = new_graph->get_nid_from_rep_id(old_graph->get_rep_id_from_nid(old_source_nid));
    if (new_source_nid == -1) {//the node is not there in the new graph

#ifdef DUP_CHECK_FLAG_SET
        new_source_nid = duplicate_node_without_splitting(new_graph, old_graph, old_source_nid, duplicate_check_flag);
#else
        new_source_nid = duplicate_node(new_graph, old_graph, old_source_nid);
#endif            

    }
    int new_target_nid = new_graph->get_nid_from_rep_id(old_graph->get_rep_id_from_nid(old_target_nid));
    if (new_target_nid == -1) {//the node is not there in the new graph
#ifdef DUP_CHECK_FLAG_SET
        new_target_nid = duplicate_node_without_splitting(new_graph, old_graph, old_target_nid, duplicate_check_flag);
#else
        new_target_nid = duplicate_node(new_graph, old_graph, old_target_nid);
#endif            

    }
    // get edge info from old graph
    //cout << "getting type of edge from old graph" << endl;
    std::string edge_type = old_graph->get_edge_type(eid);
    //cout << "getting subtypes from old graph" << endl;
    std::vector<std::string> edge_subtypes = old_graph->get_edge_subtypes_of_edge(eid);
    //cout << "getting belong pathways from old graph" << endl;
    std::vector<std::string> edge_belongs_to_pathways = old_graph->get_all_pathways_for_edge(eid);

    // check if edge between source and target exist with same labels
    int eid_to_check = (!duplicate_check_flag) ? -1 : new_graph->check_if_edge_already_created(new_source_nid, new_target_nid, edge_type, edge_subtypes);
    if (eid_to_check != -1) {
        // add pathway info for existing edge
        std::vector<std::string>::iterator path_itr;
        for (path_itr = edge_belongs_to_pathways.begin(); path_itr != edge_belongs_to_pathways.end(); path_itr++) {
            std::string path = *path_itr;
            if (!new_graph->edge_belongs_to_pathway(eid_to_check, path)) {
                new_graph->add_pathway_for_edge(eid_to_check, path);
            }
        }
        // return existing edge id
        return eid_to_check;
    }

    // create new edge
    //GraphManagerNew::edge_id_count++;
    //int new_eid = GraphManagerNew::edge_id_count;
    int new_eid = new_graph->create_new_edge();
    if (new_eid == -1) {
        cerr << "Error in creating new edge" << endl;
    }

    int new_graph_id = new_graph->get_graph_id();
    add_edge_id_graph_id(new_eid, new_graph_id);
    new_graph->add_edge_id(new_eid);

    // add edge info on new edge
    new_graph->add_source_node(new_eid, new_source_nid);
    new_graph->add_target_node(new_eid, new_target_nid);
    new_graph->add_edge_type(new_eid, edge_type);
    std::vector<std::string>::iterator itr;
    for (itr = edge_subtypes.begin(); itr != edge_subtypes.end(); itr++) {
        new_graph->add_subtype_for_edge(new_eid, (*itr));
    }
    for (itr = edge_belongs_to_pathways.begin(); itr != edge_belongs_to_pathways.end(); itr++) {
        new_graph->add_pathway_for_edge(new_eid, (*itr));
    }

    //insert new edge in outlist of source and inlist of target nodes
    new_graph->add_edge_to_outlist_of_node(new_source_nid, new_eid);
    new_graph->add_edge_to_inlist_of_node(new_target_nid, new_eid);

    new_graph->set_edge_weight(new_eid, old_graph->get_edge_weight(eid)); // added by sukanya on 10 Apr 2017
    new_graph->set_edge_weight_float(new_eid, old_graph->get_edge_weight_float(eid));
    new_graph->set_weight_tuple_for_edge(new_eid, old_graph->get_weight_tuple_for_edge(eid));
    
    new_graph->add_other_value1_to_node(new_source_nid, old_source_nid);
    new_graph->add_other_value1_to_node(new_target_nid, old_target_nid);
     
    return new_eid;
}


//
//GraphNew * GraphManagerNew::merge_two_graphs(GraphNew * graph1, GraphNew * graph2, list<unordered_map<string, set<string> > >& map_list) {
//    
//    set<string> all_ids_in_graph;
//    set<string>::iterator all_ids_in_graph_iter;
//    
//    GraphNew * new_graph = new GraphNew();
//        // creating and adding graph_id
//        GraphManagerNew::graph_id_count++;
//        int gid = GraphManagerNew::graph_id_count;
//        new_graph->set_graph_id(gid);
//        graph_id_to_graph_map[gid] = new_graph;
//    
//        // get all node ids from the two graphs to merge
//        int nid;
//        std::vector<int> NIDSg1 = graph1->get_node_ids();
//        std::vector<int> NIDSg2 = graph2->get_node_ids();
//        std::vector<int>::iterator itr;
//        
//        // copy all nodes from graph1
//        //cout << "start duplicating nodes of graph " << graph1->get_graph_id() << endl;
//        
//        for(itr = NIDSg1.begin(); itr != NIDSg1.end(); itr++) {
//            int new_node_id = duplicate_node(new_graph, graph1, (*itr));
//            vector<string> all_id_of_node = new_graph->get_all_ids_of_node(new_node_id);
//            vector<string>::iterator all_id_node_iter;
//            for(all_id_node_iter = all_id_of_node.begin(); all_id_node_iter != all_id_of_node.end(); all_id_node_iter++) {
//                all_ids_in_graph.insert(*all_id_node_iter);
//            }
//        }
//        
//        // copy all nodes from graph2
//        for(itr = NIDSg2.begin(); itr != NIDSg2.end(); itr++) {
//            
//            // check for conflicting types
//            string type_in_graph1 = "";
//            int nid_in_graph1 = graph1->get_nid_from_rep_id(graph2->get_rep_id_from_nid(*itr));
//            if (nid_in_graph1 != -1){ // found node in graph1
//                type_in_graph1 = graph1->get_node_type(nid_in_graph1);
//            }
//            //string type_in_graph1 = graph1->get_node_type(graph1->get_nid_from_rep_id(graph2->get_rep_id_from_nid(*itr)));
//            if(type_in_graph1 != "" && type_in_graph1 != graph2->get_node_type(*itr)) {
//                //cerr << "Node types do not match for node " << graph2->get_rep_id_from_nid(*itr) << " which is " << graph2->get_node_type(*itr) <<  " in graph " << graph2->get_graph_id() << " and " << type_if_graph1 << " in prev graphs. ";
//                cerr << "Warning: Node types do not match for node " << graph2->get_rep_id_from_nid(*itr) << ". Not merging graph " << graph2->get_graph_id() << "." << endl;
//                GraphManagerNew::graph_id_count--;
//                destroy_graph(new_graph);
//                return graph1;
//                
//            }
//            
//            int new_node_id = duplicate_node(new_graph, graph2, (*itr));
//            vector<string> all_id_of_node = new_graph->get_all_ids_of_node(new_node_id);
//            vector<string>::iterator all_id_node_iter;
//            for(all_id_node_iter = all_id_of_node.begin(); all_id_node_iter != all_id_of_node.end(); all_id_node_iter++) {
//                all_ids_in_graph.insert(*all_id_node_iter);
//            }
//        }
//        
//        
//        // get all edge ids from the two graphs to merge
//        std::vector<int> EIDSg1 = graph1->get_edge_ids();
//        std::vector<int> EIDSg2 = graph2->get_edge_ids();
//        
//        // copy all edges from graph1
//        for(itr = EIDSg1.begin(); itr != EIDSg1.end(); itr++) {
//            int new_edge_id = duplicate_edge(new_graph, graph1, (*itr));
//        }
//        
//        // copy all edges from graph2
//        for(itr = EIDSg2.begin(); itr != EIDSg2.end(); itr++) {
//            int new_edge_id = duplicate_edge(new_graph, graph2, (*itr));
//        }
//        
//
//        
//
//    
//        // adding genesis information
//        std::list<int> glist;
//        glist.push_back(graph1->get_graph_id());
//        glist.push_back(graph2->get_graph_id());
//        int result_gid = new_graph->get_graph_id();
//        add_graph_genesis(result_gid, "Merged graphs", glist);
//        
//        return new_graph;
//}

GraphNew * GraphManagerNew::merge_two_graphs(GraphNew * graph1, GraphNew * graph2, list<unordered_map<string, set<string> > >& map_list) {

    set<string> all_ids_in_graph;
    set<string>::iterator all_ids_in_graph_iter;

    GraphNew * new_graph = new GraphNew();
    // creating and adding graph_id
    GraphManagerNew::graph_id_count++;
    int gid = GraphManagerNew::graph_id_count;
    new_graph->set_graph_id(gid);
    graph_id_to_graph_map[gid] = new_graph;

    // get all node ids from the two graphs to merge
    int nid;
    std::vector<int> NIDSg1 = graph1->get_node_ids();
    std::vector<int> NIDSg2 = graph2->get_node_ids();
    std::vector<int>::iterator itr;

    // copy all nodes from graph1
    //cout << "start duplicating nodes of graph " << graph1->get_graph_id() << endl;

    for (itr = NIDSg1.begin(); itr != NIDSg1.end(); itr++) {
        int new_node_id = duplicate_node(new_graph, graph1, (*itr));
        vector<string> all_id_of_node = new_graph->get_all_ids_of_node(new_node_id);
        vector<string>::iterator all_id_node_iter;
        for (all_id_node_iter = all_id_of_node.begin(); all_id_node_iter != all_id_of_node.end(); all_id_node_iter++) {
            all_ids_in_graph.insert(*all_id_node_iter);
        }
    }

    // copy all nodes from graph2
    for (itr = NIDSg2.begin(); itr != NIDSg2.end(); itr++) {

        // check for conflicting types
        string type_in_graph1 = "";
        int nid_in_graph1 = graph1->get_nid_from_rep_id(graph2->get_rep_id_from_nid(*itr));
        if (nid_in_graph1 != -1) { // found node in graph1
            type_in_graph1 = graph1->get_node_type(nid_in_graph1);
        }
        //string type_in_graph1 = graph1->get_node_type(graph1->get_nid_from_rep_id(graph2->get_rep_id_from_nid(*itr)));
        if (type_in_graph1 != "" && type_in_graph1 != graph2->get_node_type(*itr)) {
            //cerr << "Node types do not match for node " << graph2->get_rep_id_from_nid(*itr) << " which is " << graph2->get_node_type(*itr) <<  " in graph " << graph2->get_graph_id() << " and " << type_if_graph1 << " in prev graphs. ";
            cerr << "Warning: Node types do not match for node " << graph2->get_rep_id_from_nid(*itr) << ". Not merging graph " << graph2->get_graph_id() << "." << endl;
            GraphManagerNew::graph_id_count--;
            destroy_graph(new_graph);
            return graph1;

        }

        int new_node_id = duplicate_node(new_graph, graph2, (*itr));
        vector<string> all_id_of_node = new_graph->get_all_ids_of_node(new_node_id);
        vector<string>::iterator all_id_node_iter;
        for (all_id_node_iter = all_id_of_node.begin(); all_id_node_iter != all_id_of_node.end(); all_id_node_iter++) {
            all_ids_in_graph.insert(*all_id_node_iter);
        }
    }


    // get all edge ids from the two graphs to merge
    std::vector<int> EIDSg1 = graph1->get_edge_ids();
    std::vector<int> EIDSg2 = graph2->get_edge_ids();

    // copy all edges from graph1
    for (itr = EIDSg1.begin(); itr != EIDSg1.end(); itr++) {
        int new_edge_id = duplicate_edge(new_graph, graph1, (*itr));
    }

    // copy all edges from graph2
    for (itr = EIDSg2.begin(); itr != EIDSg2.end(); itr++) {
        int new_edge_id = duplicate_edge(new_graph, graph2, (*itr));
    }





    // adding genesis information
    std::list<int> glist;
    glist.push_back(graph1->get_graph_id());
    glist.push_back(graph2->get_graph_id());
    int result_gid = new_graph->get_graph_id();
    add_graph_genesis(result_gid, "Merged graphs", glist);

    return new_graph;
}

GraphNew * GraphManagerNew::merge_two_graphs_without_splitting_nodes(GraphNew * graph1, GraphNew * graph2, list<unordered_map<string, set<string> > >& map_list) {



    set<string> all_ids_in_graph;
    set<string>::iterator all_ids_in_graph_iter;

    GraphNew * new_graph = new GraphNew();
    // creating and adding graph_id
    GraphManagerNew::graph_id_count++;
    int gid = GraphManagerNew::graph_id_count;
    new_graph->set_graph_id(gid);
    graph_id_to_graph_map[gid] = new_graph;

    // get all node ids from the two graphs to merge
    int nid;
    std::vector<int> NIDSg1 = graph1->get_node_ids();
    std::vector<int> NIDSg2 = graph2->get_node_ids();
    std::vector<int>::iterator itr;

    // get id-to-rep-id info of graphs
    map<string, string> id_to_rep_id_graph3;

    for (vector<int>::iterator nid_itr = NIDSg1.begin(); nid_itr != NIDSg1.end(); nid_itr++) {
        nid = *nid_itr;
        string rep_id = graph1->get_rep_id_from_nid(nid);
        //if (id_to_rep_id_graph3.find(rep_id) == id_to_rep_id_graph3.end()) {
        vector<string> all_id = graph1->get_all_ids_of_node(nid);
        for (vector<string>::iterator all_id_itr = all_id.begin(); all_id_itr != all_id.end(); all_id_itr++) {
            id_to_rep_id_graph3[*all_id_itr] = rep_id;
        }
        id_to_rep_id_graph3[rep_id] = rep_id;
        //}
    }
    //        for(vector<int>::iterator nid_itr = NIDSg2.begin(); nid_itr != NIDSg2.end(); nid_itr++) {
    //            nid = *nid_itr;
    //            string rep_id = graph2->get_rep_id_from_nid(nid);
    //            if (id_to_rep_id_graph3.find(rep_id) == id_to_rep_id_graph3.end()) {
    //                vector<string> all_id = graph2->get_all_ids_of_node(nid);
    //                for (vector<string>::iterator all_id_itr = all_id.begin(); all_id_itr != all_id.end(); all_id_itr++) {
    //                    id_to_rep_id_graph3[*all_id_itr] = rep_id;
    //                }
    //            }
    //        }

    for (vector<int>::iterator nid_itr = NIDSg2.begin(); nid_itr != NIDSg2.end(); nid_itr++) {
        nid = *nid_itr;
        vector<string> all_ids_of_node = graph2->get_all_ids_of_node(nid);
        set<string>set_all_ids_of_node_in_g2;
        for (vector<string>::iterator all_ids_itr = all_ids_of_node.begin(); all_ids_itr != all_ids_of_node.end(); all_ids_itr++) {

            vector<string> temp_vec = graph2->get_all_ids_for_rep_id(graph2->get_rep_id_from_id(*all_ids_itr));
            for (vector<string>::iterator temp_itr = temp_vec.begin(); temp_itr != temp_vec.end(); temp_itr++) {
                set_all_ids_of_node_in_g2.insert(*temp_itr);

            }

        }


        /////string rep_id = graph1->get_rep_id_from_id(*set_all_ids_of_node_in_g2.begin());
        string rep_id = id_to_rep_id_graph3[*set_all_ids_of_node_in_g2.begin()];
        for (set<string>::iterator set_itr = set_all_ids_of_node_in_g2.begin(); set_itr != set_all_ids_of_node_in_g2.end(); set_itr++) {
            //string rep_id = graph1->get_rep_id_from_id(*set_itr);

            if (rep_id != "") {

                id_to_rep_id_graph3[*set_itr] = rep_id;
                //cout << *set_itr << "->" << rep_id << endl;
                vector<string> vec_str = graph1->get_all_ids_for_rep_id(graph1->get_rep_id_from_id(rep_id));
                for (vector<string>::iterator vec_str_itr = vec_str.begin(); vec_str_itr != vec_str.end(); vec_str_itr++) {

                    id_to_rep_id_graph3[*vec_str_itr] = rep_id;
                    //cout << *vec_str_itr << "-->" << rep_id << endl;
                }

                string rep_id2 = graph2->get_rep_id_from_id(rep_id);
                if (rep_id2 != "") {
                    vector<string> vec_str2 = graph2->get_all_ids_for_rep_id(rep_id2);
                    for (vector<string>::iterator vec_str_itr = vec_str2.begin(); vec_str_itr != vec_str2.end(); vec_str_itr++) {

                        id_to_rep_id_graph3[*vec_str_itr] = rep_id;
                        //cout << *vec_str_itr << "--->" << rep_id << endl;
                    }
                }
                id_to_rep_id_graph3[rep_id] = rep_id;
            } else {
                id_to_rep_id_graph3[*set_itr] = *set_itr;
            }
            //id_to_rep_id_graph3[rep_id] = rep_id;
        }

    }


    // change rep-ids of complexes
    // graph 1
    for (vector<int>::iterator nid_itr = NIDSg1.begin(); nid_itr != NIDSg1.end(); nid_itr++) {
        nid = *nid_itr;
        string rep_id = graph1->get_rep_id_from_nid(nid);
        set<string> new_comp_rep_ids_set;

        if (graph1->get_node_type(nid) == "group") {
            vector<int> comp_ids_of_nid = graph1->get_component_ids_of_node(nid);
            for (vector<int>::iterator comp_ids_of_nid_iter = comp_ids_of_nid.begin(); comp_ids_of_nid_iter != comp_ids_of_nid.end(); comp_ids_of_nid_iter++) {
                string curr_comp_rep_id = graph1->get_rep_id_from_nid(*comp_ids_of_nid_iter);
                //                    string temp_rep_id = curr_comp_rep_id;
                //                    string temp_rep_id2 = id_to_rep_id_graph3[curr_comp_rep_id];
                //                    while (temp_rep_id != temp_rep_id2) {
                //                        temp_rep_id = temp_rep_id2;
                //                        temp_rep_id2 = id_to_rep_id_graph3[temp_rep_id];
                //
                //                    }
                //                    //string rep_id = temp_rep_id;
                //                    string new_comp_rep_id = id_to_rep_id_graph3[temp_rep_id];
                string new_comp_rep_id = id_to_rep_id_graph3[curr_comp_rep_id];
                new_comp_rep_ids_set.insert(new_comp_rep_id);
            }
            string complex_id = "c_s_";
            for (set<string>::iterator new_comp_rep_ids_set_iter = new_comp_rep_ids_set.begin(); new_comp_rep_ids_set_iter != new_comp_rep_ids_set.end(); new_comp_rep_ids_set_iter++) {
                complex_id = complex_id + *new_comp_rep_ids_set_iter + "_";
            }
            complex_id = complex_id + "c_e";
            id_to_rep_id_graph3[rep_id] = complex_id;
            id_to_rep_id_graph3[complex_id] = complex_id;
        }

    }

    // graph 2
    for (vector<int>::iterator nid_itr = NIDSg2.begin(); nid_itr != NIDSg2.end(); nid_itr++) {
        nid = *nid_itr;
        string rep_id = graph2->get_rep_id_from_nid(nid);
        set<string> new_comp_rep_ids_set;

        if (graph2->get_node_type(nid) == "group") {
            vector<int> comp_ids_of_nid = graph2->get_component_ids_of_node(nid);
            for (vector<int>::iterator comp_ids_of_nid_iter = comp_ids_of_nid.begin(); comp_ids_of_nid_iter != comp_ids_of_nid.end(); comp_ids_of_nid_iter++) {
                string curr_comp_rep_id = graph2->get_rep_id_from_nid(*comp_ids_of_nid_iter);
                //                    string temp_rep_id = curr_comp_rep_id;
                //                    string temp_rep_id2 = id_to_rep_id_graph3[curr_comp_rep_id];
                //                    while (temp_rep_id != temp_rep_id2) {
                //                        temp_rep_id = temp_rep_id2;
                //                        temp_rep_id2 = id_to_rep_id_graph3[temp_rep_id];
                //
                //                    }
                //                    //string rep_id = temp_rep_id;
                //                    string new_comp_rep_id = id_to_rep_id_graph3[temp_rep_id];
                string new_comp_rep_id = id_to_rep_id_graph3[curr_comp_rep_id];
                new_comp_rep_ids_set.insert(new_comp_rep_id);
            }
            string complex_id = "c_s_";
            for (set<string>::iterator new_comp_rep_ids_set_iter = new_comp_rep_ids_set.begin(); new_comp_rep_ids_set_iter != new_comp_rep_ids_set.end(); new_comp_rep_ids_set_iter++) {
                complex_id = complex_id + *new_comp_rep_ids_set_iter + "_";
            }
            complex_id = complex_id + "c_e";
            id_to_rep_id_graph3[rep_id] = complex_id;
            id_to_rep_id_graph3[complex_id] = complex_id;
        }

    }

    //        cout << "---------------------" << endl;
    //        for(map<string,string>::iterator map_itr = id_to_rep_id_graph3.begin(); map_itr != id_to_rep_id_graph3.end(); map_itr++) {
    //            cout << (*map_itr).first << " -- " << (*map_itr).second << endl;
    //        }
    //        cout << "---------------------" << endl;

    // copy nodes from graph1
    for (itr = NIDSg1.begin(); itr != NIDSg1.end(); itr++) {
        string node_type = graph1->get_node_type(*itr);
        vector<string> dis_names = graph1->get_all_display_ids_of_node(*itr); // commented by sukanya on 5 Feb 2018
        //vector<string> dis_names; // added by sukanya on 5 Feb 2018
        vector<string> all_id = graph1->get_all_ids_of_node(*itr);
        for (vector<string>::iterator all_id_itr = all_id.begin(); all_id_itr != all_id.end(); all_id_itr++) {
            
            //dis_names.push_back(kegg_hsa_id_to_display_name_map[*all_id_itr]); // added by sukanya on 5 Feb 2018
            // --
            string temp_rep_id = *all_id_itr;
            string temp_rep_id2 = id_to_rep_id_graph3[*all_id_itr];
            while (temp_rep_id != temp_rep_id2) {
                temp_rep_id = temp_rep_id2;
                temp_rep_id2 = id_to_rep_id_graph3[temp_rep_id];

            }
            string rep_id = temp_rep_id;
            //string rep_id = id_to_rep_id_graph3[*all_id_itr];
            // --


            int new_nid = new_graph->get_nid_from_rep_id(new_graph->get_rep_id_from_id(rep_id));
            if (new_nid == -1) {
                // create new node

                // components
                if (node_type == "group") {

                    new_nid = new_graph->create_new_node();
                    new_graph->add_node_id(new_nid);
                    add_node_id_graph_id(new_nid, new_graph->get_graph_id());

                    ////                        //string complex_id = new_graph->concatenate_sorted_rep_ids(*vec_set_itr, "_");
                    ////                        //complex_id = "c_s_" + complex_id + "_c_e";
                    ////                        string complex_id = graph1->get_rep_id_from_nid(*itr);
                    ////                        
                    ////                        add_rep_id_for_id(complex_id, complex_id);
                    ////                        new_graph->add_id_for_node(new_nid, complex_id);
                    ////                        new_graph->add_rep_id_for_node(new_nid, complex_id);
                    ////                        new_graph->add_id_rep_id(complex_id, complex_id);
                    ////                        new_graph->add_node_type(new_nid, node_type);
                    ////                        
                    ////                        //new_graph->add_display_id_for_node(new_nid, complex_id);
                    ////                        new_graph->set_all_display_id_for_node(new_nid, dis_names);


                    vector<int> comp_ids = graph1->get_component_ids_of_node(*itr);
                    set<int> new_comp_nids;
                    vector<int>::iterator comp_it;
                    for (comp_it = comp_ids.begin(); comp_it != comp_ids.end(); comp_it++) {
                        int new_comp_node_id;
                        // check if some node has component node id
                        vector<string> all_ids_of_comp_node = graph1->get_all_ids_of_node(*comp_it);
                        for (vector<string>::iterator comp_node_id_itr = all_ids_of_comp_node.begin(); comp_node_id_itr != all_ids_of_comp_node.end(); comp_node_id_itr++) {
                            new_comp_node_id = new_graph->get_nid_from_rep_id(id_to_rep_id_graph3[*comp_node_id_itr]);
                        }
                        if (new_comp_node_id == -1) {
                            new_comp_node_id = duplicate_node(new_graph, graph1, (*comp_it));
                        }
                        new_graph->add_component_id_for_node(new_nid, new_comp_node_id);
                        new_comp_nids.insert(new_comp_node_id);
                    }

                    ////string complex_id = new_graph->concatenate_sorted_rep_ids(new_comp_nids, "_");
                    ////complex_id = "c_s_" + complex_id + "_c_e";
                    string complex_id = rep_id;
                    //string complex_id = graph1->get_rep_id_from_nid(*itr);

                    add_rep_id_for_id(complex_id, complex_id);
                    new_graph->add_id_for_node(new_nid, complex_id);
                    new_graph->add_rep_id_for_node(new_nid, complex_id);
                    new_graph->add_id_rep_id(complex_id, complex_id);
                    new_graph->add_node_type(new_nid, node_type);

                    //new_graph->add_display_id_for_node(new_nid, complex_id);
                    new_graph->set_all_display_id_for_node(new_nid, dis_names);

                }                    // not a complex
                else {

                    new_nid = duplicate_node(new_graph, graph1, (*itr));
                    //cout << "Created new node " << new_graph->get_rep_id_from_nid(new_nid) << endl;
                    new_graph->add_rep_id_for_node(new_nid, rep_id);
                    new_graph->add_id_rep_id(rep_id, rep_id);

                    new_graph->add_id_rep_id(*all_id_itr, rep_id); //
                }
            }

            if (!new_graph->node_has_id(new_nid, *all_id_itr)) {
                // add id to node
                new_graph->add_id_for_node(new_nid, *all_id_itr);
            }
            for (vector<string>::iterator dis_itr = dis_names.begin(); dis_itr != dis_names.end(); dis_itr++) {
                if (!new_graph->node_has_display_id(new_nid, *dis_itr)) {
                    new_graph->add_display_id_for_node(new_nid, *dis_itr);
                }
            }

        }
    }

    // copy nodes from graph2
    for (itr = NIDSg2.begin(); itr != NIDSg2.end(); itr++) {
        string node_type = graph2->get_node_type(*itr);
        // check for conflicting types
        string type_in_graph1 = "";
        //int nid_in_graph1 = graph1->get_nid_from_rep_id(graph2->get_rep_id_from_nid(*itr));
        int nid_in_graph1 = graph1->get_nid_from_rep_id(graph1->get_rep_id_from_id(graph2->get_rep_id_from_nid(*itr)));
        if (nid_in_graph1 != -1) { // found node in graph1
            type_in_graph1 = graph1->get_node_type(nid_in_graph1);
        }
        //string type_in_graph1 = graph1->get_node_type(graph1->get_nid_from_rep_id(graph2->get_rep_id_from_nid(*itr)));
        if (type_in_graph1 != "" && type_in_graph1 != graph2->get_node_type(*itr)) {
            //cerr << "Node types do not match for node " << graph2->get_rep_id_from_nid(*itr) << " which is " << graph2->get_node_type(*itr) <<  " in graph " << graph2->get_graph_id() << " and " << type_if_graph1 << " in prev graphs. ";
            cerr << "Warning: Node types do not match for node " << graph2->get_rep_id_from_nid(*itr) << ". Not merging graph " << graph2->get_graph_id() << "." << endl;
            GraphManagerNew::graph_id_count--;
            destroy_graph(new_graph);
            return graph1;

        }
        vector<string> dis_names = graph2->get_all_display_ids_of_node(*itr);  // commented by sukanya on 5 Feb 2018
        //vector<string> dis_names; // added by sukanya on 5 Feb 2018
        
        // create node
        vector<string> all_id = graph2->get_all_ids_of_node(*itr);
        for (vector<string>::iterator all_id_itr = all_id.begin(); all_id_itr != all_id.end(); all_id_itr++) {
            
            //dis_names.push_back(kegg_hsa_id_to_display_name_map[*all_id_itr]); // added by sukanya on 5 Feb 2018
            // --

            string temp_rep_id = *all_id_itr;
            string temp_rep_id2 = id_to_rep_id_graph3[*all_id_itr];

            while (temp_rep_id != temp_rep_id2) {
                temp_rep_id = temp_rep_id2;
                temp_rep_id2 = id_to_rep_id_graph3[temp_rep_id];

            }
            //string rep_id = temp_rep_id;
            string rep_id = id_to_rep_id_graph3[temp_rep_id];

            //cout << rep_id << endl;
            //string rep_id = id_to_rep_id_graph3[*all_id_itr];
            // --

            //int new_nid = new_graph->get_nid_from_rep_id(rep_id);
            //int new_nid = new_graph->get_nid_from_rep_id(new_graph->get_rep_id_from_id(rep_id));
            int new_nid = new_graph->get_nid_from_rep_id(rep_id);
            if (new_nid == -1) {
                // create new node

                // components
                if (node_type == "group") {

                    new_nid = new_graph->create_new_node();
                    new_graph->add_node_id(new_nid);
                    add_node_id_graph_id(new_nid, new_graph->get_graph_id());

                    ////                        //string complex_id = new_graph->concatenate_sorted_rep_ids(*vec_set_itr, "_");
                    ////                        //complex_id = "c_s_" + complex_id + "_c_e";
                    ////                        string complex_id = graph2->get_rep_id_from_nid(*itr);
                    ////                        
                    ////                        add_rep_id_for_id(complex_id, complex_id);
                    ////                        new_graph->add_id_for_node(new_nid, complex_id);
                    ////                        new_graph->add_rep_id_for_node(new_nid, complex_id);
                    ////                        new_graph->add_id_rep_id(complex_id, complex_id);
                    ////                        new_graph->add_node_type(new_nid, node_type);
                    ////                        //new_graph->add_display_id_for_node(new_nid, complex_id);
                    ////                        new_graph->set_all_display_id_for_node(new_nid, dis_names);

                    vector<int> comp_ids = graph2->get_component_ids_of_node(*itr);
                    set<int> new_comp_nids;
                    vector<int>::iterator comp_it;
                    for (comp_it = comp_ids.begin(); comp_it != comp_ids.end(); comp_it++) {
                        int new_comp_node_id;
                        // check if some node has component node id
                        vector<string> all_ids_of_comp_node = graph2->get_all_ids_of_node(*comp_it);
                        for (vector<string>::iterator comp_node_id_itr = all_ids_of_comp_node.begin(); comp_node_id_itr != all_ids_of_comp_node.end(); comp_node_id_itr++) {
                            new_comp_node_id = new_graph->get_nid_from_rep_id(id_to_rep_id_graph3[*comp_node_id_itr]);
                        }
                        if (new_comp_node_id == -1) {
                            new_comp_node_id = duplicate_node(new_graph, graph2, (*comp_it));
                        }
                        new_graph->add_component_id_for_node(new_nid, new_comp_node_id);
                        new_comp_nids.insert(new_comp_node_id);
                    }

                    ////string complex_id = new_graph->concatenate_sorted_rep_ids(new_comp_nids, "_");
                    ////complex_id = "c_s_" + complex_id + "_c_e";
                    string complex_id = rep_id;
                    //string complex_id = graph2->get_rep_id_from_nid(*itr);

                    add_rep_id_for_id(complex_id, complex_id);
                    new_graph->add_id_for_node(new_nid, complex_id);
                    new_graph->add_rep_id_for_node(new_nid, complex_id);
                    new_graph->add_id_rep_id(complex_id, complex_id);
                    new_graph->add_node_type(new_nid, node_type);
                    //new_graph->add_display_id_for_node(new_nid, complex_id);
                    new_graph->set_all_display_id_for_node(new_nid, dis_names);

                }                    // not a complex
                else {

                    new_nid = duplicate_node(new_graph, graph2, (*itr));
                    //cout << "New node " << new_graph->get_rep_id_from_nid(new_nid) << endl;
                    new_graph->add_rep_id_for_node(new_nid, rep_id);
                    new_graph->add_id_rep_id(rep_id, rep_id);

                    new_graph->add_id_rep_id(*all_id_itr, rep_id); //
                }

            }

            if (!new_graph->node_has_id(new_nid, *all_id_itr)) {
                // add id to node
                new_graph->add_id_for_node(new_nid, *all_id_itr);
            }
            for (vector<string>::iterator dis_itr = dis_names.begin(); dis_itr != dis_names.end(); dis_itr++) {
                if (!new_graph->node_has_display_id(new_nid, *dis_itr)) {
                    new_graph->add_display_id_for_node(new_nid, *dis_itr);
                }
            }

        }


    }

    // get all edge ids from the two graphs to merge
    std::vector<int> EIDSg1 = graph1->get_edge_ids();
    std::vector<int> EIDSg2 = graph2->get_edge_ids();
    
    //new_graph->merged_eid_to_construction_eids_map = graph1->merged_eid_to_construction_eids_map;
    
    

    // edges from graph1
    for (itr = EIDSg1.begin(); itr != EIDSg1.end(); itr++) {
        int curr_eid = *itr;

        string src_rep_id = graph1->get_rep_id_from_nid(graph1->get_source_node(curr_eid));
        string tgt_rep_id = graph1->get_rep_id_from_nid(graph1->get_target_node(curr_eid));

        assert(src_rep_id != "");
        assert(tgt_rep_id != "");

        //string new_src_rep_id = new_graph->get_rep_id_from_id(src_rep_id);
        //string new_tgt_rep_id = new_graph->get_rep_id_from_id(tgt_rep_id);
        string new_src_rep_id = id_to_rep_id_graph3[src_rep_id];
        string new_tgt_rep_id = id_to_rep_id_graph3[tgt_rep_id];


        assert(new_src_rep_id != "");
        assert(new_tgt_rep_id != "");

        int new_source_nid = new_graph->get_nid_from_rep_id(new_graph->get_rep_id_from_id(new_src_rep_id));
        int new_target_nid = new_graph->get_nid_from_rep_id(new_graph->get_rep_id_from_id(new_tgt_rep_id));

        assert(new_source_nid != -1);
        assert(new_target_nid != -1);



        // get edge info from old graph
        string edge_type = graph1->get_edge_type(curr_eid);
        vector<string> edge_subtypes = graph1->get_edge_subtypes_of_edge(curr_eid);
        vector<string> edge_belongs_to_pathways = graph1->get_all_pathways_for_edge(curr_eid);

        // check if edge between source and target exist with same labels
        int eid_to_check = new_graph->check_if_edge_already_created(new_source_nid, new_target_nid, edge_type, edge_subtypes);
#ifdef DUMMY_EDGE_FLAG                       
        if (eid_to_check == -1) {
            vector<string> subtype_copy = edge_subtypes;
            subtype_copy.push_back("dummy_u_to_d");
            eid_to_check = new_graph->check_if_edge_already_created(new_source_nid, new_target_nid, edge_type, subtype_copy);
        }
#endif            
        if (eid_to_check != -1) {
            // add pathway info for existing edge
            std::vector<std::string>::iterator path_itr;
            for (path_itr = edge_belongs_to_pathways.begin(); path_itr != edge_belongs_to_pathways.end(); path_itr++) {
                std::string path = *path_itr;
                if (!new_graph->edge_belongs_to_pathway(eid_to_check, path)) {
                    new_graph->add_pathway_for_edge(eid_to_check, path);
                }
            }
            //new_graph->merged_eid_to_construction_info_map[eid_to_check].push_back(std::make_pair(get_graph_id_for_edge(curr_eid), curr_eid));
            set<int> eids_in_curr_eid = graph1->merged_eid_to_construction_eids_map[curr_eid];
            for (auto i_eids = eids_in_curr_eid.begin(); i_eids != eids_in_curr_eid.end(); i_eids++) {
                new_graph->merged_eid_to_construction_eids_map[eid_to_check].insert(*i_eids);
            }
            continue;
        }


        // create new edge
        int new_eid = new_graph->create_new_edge();
        if (new_eid == -1) {
            cerr << "Error in creating new edge" << endl;
        }

        int new_graph_id = new_graph->get_graph_id();
        add_edge_id_graph_id(new_eid, new_graph_id);
        new_graph->add_edge_id(new_eid);

        // add edge info on new edge
        new_graph->add_source_node(new_eid, new_source_nid);
        new_graph->add_target_node(new_eid, new_target_nid);
        new_graph->add_edge_type(new_eid, edge_type);
        vector<string>::iterator itr;
        for (itr = edge_subtypes.begin(); itr != edge_subtypes.end(); itr++) {
            new_graph->add_subtype_for_edge(new_eid, (*itr));
        }
        for (itr = edge_belongs_to_pathways.begin(); itr != edge_belongs_to_pathways.end(); itr++) {
            new_graph->add_pathway_for_edge(new_eid, (*itr));
        }

        //insert new edge in outlist of source and inlist of target nodes
        new_graph->add_edge_to_outlist_of_node(new_source_nid, new_eid);
        new_graph->add_edge_to_inlist_of_node(new_target_nid, new_eid);


        // update construction info of edge
//        if (merged_eid_to_construction_info_map.find(new_eid) == merged_eid_to_construction_info_map.end(new_eid)) {
//            merged_eid_to_construction_info_map[new_eid] = (std::make_pair(graph1->get_graph_id(),curr_eid));
//        }
//        else {
            set<int> eids_in_curr_eid = graph1->merged_eid_to_construction_eids_map[curr_eid];
            for (auto i_eids = eids_in_curr_eid.begin(); i_eids != eids_in_curr_eid.end(); i_eids++) {
                new_graph->merged_eid_to_construction_eids_map[new_eid].insert(*i_eids);
            }
            //new_graph->merged_eid_to_construction_eids_map[new_eid].push_back(curr_eid);
//        }
    }

    

    // edges from graph2
    for (itr = EIDSg2.begin(); itr != EIDSg2.end(); itr++) {
        int curr_eid = *itr;

        string src_rep_id = graph2->get_rep_id_from_nid(graph2->get_source_node(curr_eid));
        string tgt_rep_id = graph2->get_rep_id_from_nid(graph2->get_target_node(curr_eid));

        string new_src_rep_id = id_to_rep_id_graph3[src_rep_id];
        string new_tgt_rep_id = id_to_rep_id_graph3[tgt_rep_id];

        int new_source_nid = new_graph->get_nid_from_rep_id(new_graph->get_rep_id_from_id(new_src_rep_id));
        int new_target_nid = new_graph->get_nid_from_rep_id(new_graph->get_rep_id_from_id(new_tgt_rep_id));

        //cout << new_src_rep_id << " --- " << new_tgt_rep_id << endl;

        assert(new_source_nid != -1);
        assert(new_target_nid != -1);



        // get edge info from old graph
        string edge_type = graph2->get_edge_type(curr_eid);
        vector<string> edge_subtypes = graph2->get_edge_subtypes_of_edge(curr_eid);
        vector<string> edge_belongs_to_pathways = graph2->get_all_pathways_for_edge(curr_eid);

        // check if edge between source and target exist with same labels
        int eid_to_check = new_graph->check_if_edge_already_created(new_source_nid, new_target_nid, edge_type, edge_subtypes);
#ifdef DUMMY_EDGE_FLAG                       
        if (eid_to_check == -1) {
            vector<string> subtype_copy = edge_subtypes;
            subtype_copy.push_back("dummy_u_to_d");
            eid_to_check = new_graph->check_if_edge_already_created(new_source_nid, new_target_nid, edge_type, subtype_copy);
        }
#endif            
        if (eid_to_check != -1) {
            // add pathway info for existing edge
            std::vector<std::string>::iterator path_itr;
            for (path_itr = edge_belongs_to_pathways.begin(); path_itr != edge_belongs_to_pathways.end(); path_itr++) {
                std::string path = *path_itr;
                if (!new_graph->edge_belongs_to_pathway(eid_to_check, path)) {
                    new_graph->add_pathway_for_edge(eid_to_check, path);                    
                }
                
            }
            new_graph->merged_eid_to_construction_eids_map[eid_to_check].insert(curr_eid);
            continue;
        }


        // create new edge
        int new_eid = new_graph->create_new_edge();
        if (new_eid == -1) {
            cerr << "Error in creating new edge" << endl;
        }

        int new_graph_id = new_graph->get_graph_id();
        add_edge_id_graph_id(new_eid, new_graph_id);
        new_graph->add_edge_id(new_eid);

        // add edge info on new edge
        new_graph->add_source_node(new_eid, new_source_nid);
        new_graph->add_target_node(new_eid, new_target_nid);
        new_graph->add_edge_type(new_eid, edge_type);
        vector<string>::iterator itr;
        for (itr = edge_subtypes.begin(); itr != edge_subtypes.end(); itr++) {
            new_graph->add_subtype_for_edge(new_eid, (*itr));
        }
        for (itr = edge_belongs_to_pathways.begin(); itr != edge_belongs_to_pathways.end(); itr++) {
            new_graph->add_pathway_for_edge(new_eid, (*itr));
        }

        //insert new edge in outlist of source and inlist of target nodes
        new_graph->add_edge_to_outlist_of_node(new_source_nid, new_eid);
        new_graph->add_edge_to_inlist_of_node(new_target_nid, new_eid);


        new_graph->merged_eid_to_construction_eids_map[new_eid].insert(curr_eid);
        
    }



    // adding genesis information
    std::list<int> glist;
    glist.push_back(graph1->get_graph_id());
    glist.push_back(graph2->get_graph_id());
    int result_gid = new_graph->get_graph_id();
    add_graph_genesis(result_gid, "Merged graphs", glist);

    return new_graph;
}


//returns -1 if the graph couldn't be merged

/*
   int GraphManagerNew::merge_graphs_divide_and_conquer(std::vector<int> gid_vec) {
   int n = gid_vec.size();

//if list is empty report error and return -1
if (n == 0) {
cerr << "Error: No graphs to merge" << endl;
return -1;
}

//if the list is of size 1 return the same graph if it is a valid graph or return -1 if it is not a valid graph
if (n == 1) {
int gid = *gid_vec.begin();
GraphNew* graph_new = get_graph(gid);
if (graph_new == NULL) {
return -1;
}
return gid;
}

//if size is more than one then split it into two almost equal non-empty parts and call merge_two graphs on the two returned graphs
int mid = (n - 1) / 2;

std::vector<int>gid_list_left(gid_vec.begin(), gid_vec.begin() + mid + 1);
std::vector<int>gid_list_right(gid_vec.begin() + mid + 1, gid_vec.end());

int gid_left_merged = merge_graphs_divide_and_conquer(gid_list_left);
int gid_right_merged = merge_graphs_divide_and_conquer(gid_list_right);

if (gid_left_merged == -1 && gid_right_merged == -1) {
return -1;
}
if (gid_left_merged == -1 && gid_right_merged != -1) {
return gid_right_merged;
}
if (gid_left_merged != -1 && gid_right_merged == -1) {
return gid_left_merged;
}

GraphNew* graph_left = get_graph(gid_left_merged);
GraphNew* graph_right = get_graph(gid_right_merged);

if (graph_left == NULL || graph_right == NULL) {
cerr << "Bug: a graph must be there for a graph id obtained by merging graphs" << endl;
}
cout << " merging graphs: " << gid_left_merged << " and " << gid_right_merged << endl;
GraphNew* merged_graph = merge_two_graphs(graph_left, graph_right);
cout << "got merged graph: " << merged_graph->get_graph_id() << endl;

return merged_graph->get_graph_id();

}*/

int GraphManagerNew::merge_graphs(std::list<int> gid_list, list<unordered_map<string, set<string> > >& map_list, vector<string>& MAPK_merged_ids, map<string, set<string> >& MAPK_node_to_pathway_id_map) {
    GraphNew * merged_graph;
    //time_t time1, time2;
    std::list<int>::iterator itr;
    std::list<GraphNew *> graph_list;
    std::list<int> glist_merged;
    for (itr = gid_list.begin(); itr != gid_list.end(); itr++) {
        GraphNew * graph = get_graph(*itr);
        if (graph != NULL) {
            graph_list.push_back(graph);
        } else {
            cerr << "Warning: Invalid graph with id " << (*itr) << endl;
        }
    }
    if (graph_list.empty()) {
        cerr << "No valid graphs to merge" << endl;
        return -1;
    }

    if (graph_list.size() == 1) {
        cout << "Only one graph. Returning same." << endl;
        return gid_list.front();
    }
    

    GraphNew * graph1 = graph_list.front();
    glist_merged.push_back(graph1->get_graph_id());

    
    

    // -- For counting occurrences, added by Sukanya on 23 Jan 2018   
    map<string, int> node_repid_to_occurrence_map;
    map<string, int> edge_repstr_to_occurrence_map;
    
    vector<int> curr_graph_nids;
    vector<int> curr_graph_eids;
    
    curr_graph_nids = graph1->get_node_ids();
    for (auto i = curr_graph_nids.begin(); i != curr_graph_nids.end(); i++) {
        string curr_repid = graph1->get_rep_id_from_nid(*i);
        
        if (node_repid_to_occurrence_map.find(curr_repid) == node_repid_to_occurrence_map.end())
            node_repid_to_occurrence_map.insert(pair<string, int>(curr_repid, 0));
        else
            node_repid_to_occurrence_map[curr_repid]++;
    }
    int g1 = graph1->get_graph_id();
    curr_graph_eids = graph1->get_edge_ids();
    for (auto i = curr_graph_eids.begin(); i != curr_graph_eids.end(); i++) {
        int curr_eid = *i;
        string curr_src_repid = graph1->get_rep_id_from_nid(graph1->get_source_node(curr_eid));
        string curr_tgt_repid = graph1->get_rep_id_from_nid(graph1->get_target_node(curr_eid));
        string curr_edge_subtypes_as_string = concatenate_strings(graph1->get_edge_subtypes_of_edge(curr_eid), "-");
        string curr_edge_repstr = curr_src_repid + "_" + curr_edge_subtypes_as_string + "_" + curr_tgt_repid;
        string curr_edge_repstr_readable = curr_src_repid + " " + curr_edge_subtypes_as_string + " " + curr_tgt_repid;
        
        if (edge_repstr_to_occurrence_map.find(curr_edge_repstr) == edge_repstr_to_occurrence_map.end())
            edge_repstr_to_occurrence_map.insert(pair<string, int>(curr_edge_repstr, 0));
        else
            edge_repstr_to_occurrence_map[curr_edge_repstr]++;
        
        graph1->merged_eid_to_construction_eids_map[curr_eid].insert(curr_eid);
    }
    // --



    
    
    
    
    
    
    
    
    cout << endl;
    graph_list.pop_front();
    while (!graph_list.empty()) {
        GraphNew * graph2 = graph_list.front();
        graph_list.pop_front();
        cout << " merging graphs: " << graph1->get_graph_id() << " and " << graph2->get_graph_id() << endl;
        
        //merged_graph = merge_two_graphs(graph1, graph2, map_list);
        //merged_graph = merge_two_graphs_without_splitting_nodes(graph1, graph2, map_list);
        merged_graph = merge_two_graphs_without_splitting_nodes(graph1, graph2, map_list);
        
       
        
        // -- For counting occurrences, added by Sukanya on 23 Jan 2018   
        curr_graph_nids.clear();
        curr_graph_eids.clear();

        curr_graph_nids = graph2->get_node_ids();
        for (auto i = curr_graph_nids.begin(); i != curr_graph_nids.end(); i++) {
            string curr_repid = graph2->get_rep_id_from_nid(*i);

            if (node_repid_to_occurrence_map.find(curr_repid) == node_repid_to_occurrence_map.end())
                node_repid_to_occurrence_map.insert(pair<string, int>(curr_repid, 0));
            else
                node_repid_to_occurrence_map[curr_repid]++;
        }

        curr_graph_eids = graph2->get_edge_ids();
        for (auto i = curr_graph_eids.begin(); i != curr_graph_eids.end(); i++) {
            int curr_eid = *i;
            string curr_src_repid = graph2->get_rep_id_from_nid(graph2->get_source_node(curr_eid));
            string curr_tgt_repid = graph2->get_rep_id_from_nid(graph2->get_target_node(curr_eid));
            string curr_edge_subtypes_as_string = concatenate_strings(graph2->get_edge_subtypes_of_edge(curr_eid), "-");
            string curr_edge_repstr = curr_src_repid + "_" + curr_edge_subtypes_as_string + "_" + curr_tgt_repid;
            string curr_edge_repstr_readable = curr_src_repid + " " + curr_edge_subtypes_as_string + " " + curr_tgt_repid;

            if (edge_repstr_to_occurrence_map.find(curr_edge_repstr) == edge_repstr_to_occurrence_map.end())
                edge_repstr_to_occurrence_map.insert(pair<string, int>(curr_edge_repstr, 0));
            else
                edge_repstr_to_occurrence_map[curr_edge_repstr]++;
        }
        // --

                
        if (graph1->get_graph_id() != merged_graph->get_graph_id()) {
            glist_merged.push_back(graph2->get_graph_id());
        }

        graph1 = merged_graph;
        //merged_graph->merged_eid_to_construction_info_map = graph1->merged_eid_to_construction_info_map;
    }
    
   

    set<string> all_ids_in_graph;
    vector<int> all_nids_in_graph = merged_graph->get_node_ids();
    set<string>::iterator all_ids_in_graph_iter;
    for (vector<int>::iterator all_nids_in_graph_iter = all_nids_in_graph.begin(); all_nids_in_graph_iter != all_nids_in_graph.end(); all_nids_in_graph_iter++) {
        vector<string> all_id_of_node = merged_graph->get_all_ids_of_node(*all_nids_in_graph_iter);
        vector<string>::iterator all_id_node_iter;
        for (all_id_node_iter = all_id_of_node.begin(); all_id_node_iter != all_id_of_node.end(); all_id_node_iter++) {
            all_ids_in_graph.insert(*all_id_node_iter);
        }
    }
    int nid;


    set<string> intermed_nodes_created;
    // iterate over the maps
    list<unordered_map<string, set<string> > >::iterator map_list_iter;
    int edges_before = merged_graph->get_edge_ids().size();
    cout << "Edges before: " << edges_before << endl;
    int edges_after = 0;
    while (edges_before != edges_after) {

        for (map_list_iter = map_list.begin(); map_list_iter != map_list.end(); map_list_iter++) {
            //cout << "Reading map with " << (*map_list_iter).size() << " entries" << endl;

            unordered_map<string, set<string> > current_map = (*map_list_iter);

            for (all_ids_in_graph_iter = all_ids_in_graph.begin(); all_ids_in_graph_iter != all_ids_in_graph.end(); all_ids_in_graph_iter++) {

                unordered_map<string, set<string> >::iterator found_in_map = current_map.find(*all_ids_in_graph_iter);
                if (found_in_map == current_map.end()) {
                    continue;
                }
                // create key node if not created
                string key = (*found_in_map).first;
                string repid_for_map_entry = get_rep_id_for_id(key);
                if (repid_for_map_entry == "")
                    repid_for_map_entry = key;

                if (intermed_nodes_created.find(repid_for_map_entry) != intermed_nodes_created.end())
                    continue;
                if (merged_graph->check_if_node_already_created(repid_for_map_entry) == -1) {
                    nid = merged_graph->create_new_node();
                    merged_graph->add_node_id(nid);
                    merged_graph->add_rep_id_for_node(nid, repid_for_map_entry);
                    add_node_id_graph_id(nid, merged_graph->get_graph_id());
                    vector<string> all_id_for_rid = get_all_ids_for_rep_id(repid_for_map_entry);
                    all_id_for_rid.push_back(repid_for_map_entry); // specially for this node
                    for (vector<string>::iterator all_id_for_rid_itr = all_id_for_rid.begin(); all_id_for_rid_itr != all_id_for_rid.end(); all_id_for_rid_itr++) {
                        merged_graph->add_id_for_node(nid, *all_id_for_rid_itr);
                        merged_graph->add_id_rep_id(*all_id_for_rid_itr, repid_for_map_entry);

                    }
                    merged_graph->add_node_type(nid, "protein"); // will this be a protein?
                    merged_graph->add_display_id_for_node(nid, get_display_names_from_rep_id(repid_for_map_entry));

                    intermed_nodes_created.insert(repid_for_map_entry);
                } else {
                    nid = merged_graph->get_nid_from_rep_id(repid_for_map_entry);
                }

                // create value nodes if not already created
                set<string> value_list = (*found_in_map).second;
                set<string>::iterator value_list_iter;
                for (value_list_iter = value_list.begin(); value_list_iter != value_list.end(); value_list_iter++) {
                    string repid_for_map_entry = get_rep_id_for_id(*value_list_iter);
                    if (repid_for_map_entry == "")
                        repid_for_map_entry = *value_list_iter;
                    if (intermed_nodes_created.find(repid_for_map_entry) != intermed_nodes_created.end())
                        continue;
                    if (merged_graph->check_if_node_already_created(repid_for_map_entry) == -1) {
                        nid = merged_graph->create_new_node();
                        merged_graph->add_node_id(nid);
                        merged_graph->add_rep_id_for_node(nid, repid_for_map_entry);
                        add_node_id_graph_id(nid, merged_graph->get_graph_id());
                        vector<string> all_id_for_rid = get_all_ids_for_rep_id(repid_for_map_entry);
                        all_id_for_rid.push_back(repid_for_map_entry); // specially for this node
                        for (vector<string>::iterator all_id_for_rid_itr = all_id_for_rid.begin(); all_id_for_rid_itr != all_id_for_rid.end(); all_id_for_rid_itr++) {
                            merged_graph->add_id_for_node(nid, *all_id_for_rid_itr);
                            merged_graph->add_id_rep_id(*all_id_for_rid_itr, repid_for_map_entry); // commented out by sukanya
                        }
                        merged_graph->add_node_type(nid, "protein"); // will this be a protein?
                        merged_graph->add_display_id_for_node(nid, get_display_names_from_rep_id(repid_for_map_entry));

                        intermed_nodes_created.insert(repid_for_map_entry);
                    } else {
                        nid = merged_graph->get_nid_from_rep_id(repid_for_map_entry);
                    }

                    // create new edge to/from intermediate node
                    string src_repid = get_rep_id_for_id(key);
                    if (src_repid == "")
                        src_repid = key;
                    string tgt_repid = repid_for_map_entry;
                    int source_node_id = merged_graph->get_nid_from_rep_id(src_repid);
                    int target_node_id = merged_graph->get_nid_from_rep_id(tgt_repid);
                    vector<string> map_subtype;
                    map_subtype.push_back("mapping");
                    int eid = merged_graph->check_if_edge_already_created(source_node_id, target_node_id, "mapping", map_subtype);
                    if (eid == -1) {
                        eid = merged_graph->create_new_edge(); // creates a new edge -- added by sukanya
                        merged_graph->add_edge_id(eid); // added by sukanya
                        add_edge_id_graph_id(eid, merged_graph->get_graph_id());
                        merged_graph->add_edge_type(eid, "mapping");
                        merged_graph->add_edge_to_outlist_of_node(source_node_id, eid);
                        merged_graph->add_edge_to_inlist_of_node(target_node_id, eid);
                        merged_graph->add_source_node(eid, source_node_id);
                        merged_graph->add_target_node(eid, target_node_id);
                        merged_graph->add_subtype_for_edge(eid, "mapping");
                        merged_graph->add_pathway_for_edge(eid, " ");
                    }


                    eid = merged_graph->check_if_edge_already_created(target_node_id, source_node_id, "mapping", map_subtype);
                    if (eid == -1) {
                        eid = merged_graph->create_new_edge(); // creates a new edge -- added by sukanya
                        merged_graph->add_edge_id(eid); // added by sukanya
                        add_edge_id_graph_id(eid, merged_graph->get_graph_id());
                        merged_graph->add_edge_type(eid, "mapping");
                        merged_graph->add_edge_to_outlist_of_node(target_node_id, eid);
                        merged_graph->add_edge_to_inlist_of_node(source_node_id, eid);
                        merged_graph->add_source_node(eid, target_node_id);
                        merged_graph->add_target_node(eid, source_node_id);
                        merged_graph->add_subtype_for_edge(eid, "mapping");
                        merged_graph->add_pathway_for_edge(eid, " ");
                    }

                }
            }

        }

        all_ids_in_graph = intermed_nodes_created;
        intermed_nodes_created.clear();
        edges_before = edges_after;
        edges_after = merged_graph->get_edge_ids().size();
        cout << "Edges after: " << edges_after << endl;
    }

    // -- For counting occurrences, added by Sukanya on 23 Jan 2018 
    vector<pair<int, int> > nid_to_occurrence;
    vector<pair<int, int> > eid_to_occurrence;
    
//    if (!node_repid_to_occurrence_map.empty()) {
//        for (auto rep_iter =)
//    }
    
    /*vector <pair<int, int> > nid_weight_pairs;

    if (nid_to_expr_value_map.empty())
        return;

    for (auto temp = nid_to_expr_value_map.begin(); temp != nid_to_expr_value_map.end(); temp++) {
        nid_weight_pairs.push_back(pair<int, int>(temp->first, temp->second));
    }

    sort(nid_weight_pairs.begin(), nid_weight_pairs.end(), compare_pair_on_second_descending);*/
    string node_occurrence_filename = "node_occurrence";
    string edge_occurrence_filename = "edge_coourrence";
//    map<string, int> node_repid_to_occurrence_map;
//    map<string, int> edge_repstr_to_occurrence_map;
    
    
    
    int result_gid = graph1->get_graph_id();
    
    
    // -- prints all primary edges of a merged graph to a tab separated file
    string edges_merged_filename = "edges_merged_filename";
    ofstream medges_ofs(edges_merged_filename.c_str());
    merged_graph = get_graph(result_gid);
    vector<int> merged_graph_eids = merged_graph->get_edge_ids();
    for (auto e = merged_graph_eids.begin(); e != merged_graph_eids.end(); e++) {
        int curr_eid = *e;
        string merged_source_name = get_display_names_of_all_ids_of_node(merged_graph, merged_graph->get_source_node(curr_eid));
        string merged_target_name = get_display_names_of_all_ids_of_node(merged_graph, merged_graph->get_target_node(curr_eid));
        string merged_edge_types = concatenate_strings2(merged_graph->get_edge_subtypes_of_edge(curr_eid), ",");
        medges_ofs << merged_source_name << "\t" << merged_edge_types << "\t" << merged_target_name;
        set<int> edges_merged_into_curr_eid = merged_graph->merged_eid_to_construction_eids_map[curr_eid];
        
        int curr_e = *edges_merged_into_curr_eid.begin();
        int gid_of_curr_e = get_graph_id_for_edge(curr_e);
        GraphNew * curr_g = get_graph(gid_of_curr_e);

        string source_name = get_display_names_of_all_ids_of_node(curr_g, curr_g->get_source_node(curr_e));
        string target_name = get_display_names_of_all_ids_of_node(curr_g, curr_g->get_target_node(curr_e));
        string edge_types = concatenate_strings2(curr_g->get_edge_subtypes_of_edge(curr_e), ",");
        vector<string> all_path_vec = curr_g->get_all_pathways_for_edge(curr_e);
        medges_ofs << "\t" << source_name << "\t" << edge_types << "\t" << target_name << "\t" << get_pathway_names_from_path_id(all_path_vec[0]);
        for (auto pw_iter = all_path_vec.begin()+1; pw_iter != all_path_vec.end(); pw_iter++) {
            medges_ofs << "\t" << get_pathway_names_from_path_id(*pw_iter);
        }
        medges_ofs << endl;
        
        for (auto em = std::next(edges_merged_into_curr_eid.begin(),1); em != edges_merged_into_curr_eid.end(); em++) {
            curr_e = *em;
            gid_of_curr_e = get_graph_id_for_edge(curr_e);
            curr_g = get_graph(gid_of_curr_e);
            
            source_name = get_display_names_of_all_ids_of_node(curr_g, curr_g->get_source_node(curr_e));
            target_name = get_display_names_of_all_ids_of_node(curr_g, curr_g->get_target_node(curr_e));
            edge_types = concatenate_strings2(curr_g->get_edge_subtypes_of_edge(curr_e), ",");
            all_path_vec = curr_g->get_all_pathways_for_edge(curr_e);
            medges_ofs << "\t\t\t" << source_name << "\t" << edge_types << "\t" << target_name << "\t" << get_pathway_names_from_path_id(all_path_vec[0]);
            for (auto pw_iter = all_path_vec.begin()+1; pw_iter != all_path_vec.end(); pw_iter++) {
                medges_ofs << "\t" << get_pathway_names_from_path_id(*pw_iter);
            }
            medges_ofs << endl;
            
        }
        
        
    }
    medges_ofs.close();
    // --
    
    add_graph_genesis(result_gid, "Merged graphs", glist_merged);
    return result_gid;
}

void GraphManagerNew::get_nodes_on_path_from_i_to_j_dummy(GraphNew * original_graph, int i, int j, set<int>& result_nodes,
        map<int, set<int> >& frwd_bfs_results, map<int, set<int> >& bkwd_bfs_results) {

}

void GraphManagerNew::get_nodes_on_path_from_i_to_j(GraphNew * original_graph, int i, int j, set<int>& result_nodes,
        map<int, set<int> >& frwd_bfs_results, map<int, set<int> >& bkwd_bfs_results) {

    set<int> set_nodes_frwd_reachable_from_i;
    set<int> set_nodes_frwd_reachable_from_j;
    set<int> set_nodes_bkwd_reachable_from_i;
    set<int> set_nodes_bkwd_reachable_from_j;
    set<int> set_nodes_frwd_reachable_from_i_until_j;
    set<int> set_nodes_bkwd_reachable_from_j_until_i;

    // forward bfs from i
    if (frwd_bfs_results.find(i) == frwd_bfs_results.end()) {
        original_graph->get_bfs_nodes(i, set_nodes_frwd_reachable_from_i, FORWARD);
        frwd_bfs_results.insert(pair<int, set<int> >(i, set_nodes_frwd_reachable_from_i));
    } else {
        set_nodes_frwd_reachable_from_i = frwd_bfs_results[i];

    }


    // forward bfs from j
    if (frwd_bfs_results.find(j) == frwd_bfs_results.end()) {
        original_graph->get_bfs_nodes(j, set_nodes_frwd_reachable_from_j, FORWARD);
        frwd_bfs_results.insert(pair<int, set<int> >(j, set_nodes_frwd_reachable_from_j));
    } else {
        set_nodes_frwd_reachable_from_j = frwd_bfs_results[j];
    }


    // backward bfs from i
    if (bkwd_bfs_results.find(i) == bkwd_bfs_results.end()) {
        original_graph->get_bfs_nodes(i, set_nodes_bkwd_reachable_from_i, BACKWARD);
        bkwd_bfs_results.insert(pair<int, set<int> >(i, set_nodes_bkwd_reachable_from_i));
    } else {
        set_nodes_bkwd_reachable_from_i = bkwd_bfs_results[i];
    }


    // backward bfs from j
    if (bkwd_bfs_results.find(j) == bkwd_bfs_results.end()) {
        original_graph->get_bfs_nodes(j, set_nodes_bkwd_reachable_from_j, BACKWARD);
        bkwd_bfs_results.insert(pair<int, set<int> >(j, set_nodes_bkwd_reachable_from_j));
    } else {
        set_nodes_bkwd_reachable_from_j = bkwd_bfs_results[j];
    }



    // forward bfs from i until j
    set_intersection(set_nodes_frwd_reachable_from_i.begin(), set_nodes_frwd_reachable_from_i.end(),
            set_nodes_bkwd_reachable_from_j.begin(), set_nodes_bkwd_reachable_from_j.end(),
            inserter(set_nodes_frwd_reachable_from_i_until_j, set_nodes_frwd_reachable_from_i_until_j.begin()));





    // backward bfs from j until i
    set_intersection(set_nodes_frwd_reachable_from_j.begin(), set_nodes_frwd_reachable_from_j.end(),
            set_nodes_bkwd_reachable_from_i.begin(), set_nodes_bkwd_reachable_from_i.end(),
            inserter(set_nodes_bkwd_reachable_from_j_until_i, set_nodes_bkwd_reachable_from_j_until_i.begin()));


    // nodes_on_path_from_i_to_j
    set_union(set_nodes_frwd_reachable_from_i_until_j.begin(), set_nodes_frwd_reachable_from_i_until_j.end(),
            set_nodes_bkwd_reachable_from_j_until_i.begin(), set_nodes_bkwd_reachable_from_j_until_i.end(), inserter(result_nodes, result_nodes.begin()));

}

int GraphManagerNew::bcc_internal(GraphNew * graph, int source, vector<int>& discovery, vector<int>& low_values, list<int>& edge_list, set<int>& node_set, vector<int>&parent, int& count) {

    static int time = 0;

    discovery[source] = low_values[source] = ++time;
    int children = 0;

    vector<int>::iterator i;
    vector<int> outlist = graph->get_outlist(GET_NODE_ID(graph, source));
    for (i = outlist.begin(); i != outlist.end(); i++) {
        int target = GET_NODE_SEQ_NUM(graph, graph->get_target_node(*i));

        if (discovery[target] == 0) {
            children++;
            parent[target] = source;
            edge_list.push_back(*i);
            bcc_internal(graph, target, discovery, low_values, edge_list, node_set, parent, count);

            low_values[source] = min(low_values[source], low_values[target]);

            if ((discovery[source] == 1 && children > 1) || (discovery[source] > 1 && low_values[target] >= discovery[source])) {

                while (GET_NODE_SEQ_NUM(graph, graph->get_source_node(edge_list.back())) != source || GET_NODE_SEQ_NUM(graph, graph->get_target_node(edge_list.back())) != target) {
                    node_set.insert(GET_NODE_SEQ_NUM(graph, graph->get_source_node(edge_list.back())));
                    node_set.insert(GET_NODE_SEQ_NUM(graph, graph->get_target_node(edge_list.back())));
                    //cout << GET_NODE_SEQ_NUM(graph, graph->get_source_node(edge_list.back())) << "--" << GET_NODE_SEQ_NUM(graph, graph->get_target_node(edge_list.back())) << " ";
                    cout << graph->get_source_node(edge_list.back()) << "--" << graph->get_target_node(edge_list.back()) << " ";
                    edge_list.pop_back();
                }
                node_set.insert(GET_NODE_SEQ_NUM(graph, graph->get_source_node(edge_list.back())));
                node_set.insert(GET_NODE_SEQ_NUM(graph, graph->get_target_node(edge_list.back())));
                //cout << GET_NODE_SEQ_NUM(graph, graph->get_source_node(edge_list.back())) << "--" << GET_NODE_SEQ_NUM(graph, graph->get_target_node(edge_list.back()));
                cout << graph->get_source_node(edge_list.back()) << "--" << graph->get_target_node(edge_list.back());
                edge_list.pop_back();
                cout << endl;
                //cout << node_set.size() << " ";
                node_set.clear();
                count++;
            }
        } else if (target != parent[source] && discovery[target] < low_values[source]) {
            low_values[source] = min(low_values[source], discovery[target]);
            edge_list.push_back(*i);
        }

    }

    return count;
}

int GraphManagerNew::bcc(GraphNew * graph) {
    int count = 0;
    int V = graph->get_node_ids().size();

    vector<int> discovery(V, 0);
    vector<int> low_values(V, 0);
    vector<int> parents(V, 0);
    list<int> edge_list;
    set<int> node_set;

    for (int i = 0; i < V; i++) {
        if (discovery[i] == 0) {
            bcc_internal(graph, i, discovery, low_values, edge_list, node_set, parents, count);
        }

        int j = 0;

        while (edge_list.size() > 0) {
            j = 1;
            node_set.insert(GET_NODE_SEQ_NUM(graph, graph->get_source_node(edge_list.back())));
            node_set.insert(GET_NODE_SEQ_NUM(graph, graph->get_target_node(edge_list.back())));
            //cout << GET_NODE_SEQ_NUM(graph, graph->get_source_node(edge_list.back())) << " -- " << GET_NODE_SEQ_NUM(graph, graph->get_target_node(edge_list.back())) << " ";
            cout << graph->get_source_node(edge_list.back()) << " -- " << graph->get_target_node(edge_list.back()) << " ";
            edge_list.pop_back();
        }

        if (j == 1) {
            //cout << node_set.size() << endl;
            node_set.clear();
            cout << endl;
            count++;
        }
    }
    return count;
}

void GraphManagerNew::get_nodes_on_simple_path_internal(GraphNew * graph, int s, int t, int source, vector<int>& discovery, vector<int>& low_values,
        list<int>& edge_list, set<int>& node_set, set<int>& set_nodes_on_simple_path, vector<int>&parent) {
    int source_nid = GET_NODE_ID(graph, source);
    int target_nid, target;
    static int time = 0;

    discovery[source] = low_values[source] = ++time;
    int children = 0;

    vector<int>::iterator i;
    vector<int> outlist = graph->get_outlist(GET_NODE_ID(graph, source));
    //    cout << source << ": ";
    //    for (i = outlist.begin(); i != outlist.end(); i++)
    //        cout << "[" << (*i) << "]";
    //    cout << endl;
    for (i = outlist.begin(); i != outlist.end(); i++) {

        target_nid = graph->get_target_node(*i);
        target = GET_NODE_SEQ_NUM(graph, target_nid);

        if (discovery[target] == 0) {
            children++;
            parent[target] = source;
            edge_list.push_back(*i);


            get_nodes_on_simple_path_internal(graph, s, t, target, discovery, low_values, edge_list, node_set, set_nodes_on_simple_path, parent);

            low_values[source] = min(low_values[source], low_values[target]);

            if ((discovery[source] == 1 && children > 1) || (discovery[source] > 1 && low_values[target] >= discovery[source])) {

                while (GET_NODE_SEQ_NUM(graph, graph->get_source_node(edge_list.back())) != source || GET_NODE_SEQ_NUM(graph, graph->get_target_node(edge_list.back())) != target) {

                    //cout << GET_NODE_SEQ_NUM(graph, graph->get_source_node(edge_list.back())) << "--" << GET_NODE_SEQ_NUM(graph, graph->get_target_node(edge_list.back())) << " ";
                    node_set.insert(GET_NODE_SEQ_NUM(graph, graph->get_source_node(edge_list.back())));
                    node_set.insert(GET_NODE_SEQ_NUM(graph, graph->get_target_node(edge_list.back())));
                    edge_list.pop_back();
                }
                //cout << GET_NODE_SEQ_NUM(graph, graph->get_source_node(edge_list.back())) << "--" << GET_NODE_SEQ_NUM(graph, graph->get_target_node(edge_list.back()));
                node_set.insert(GET_NODE_SEQ_NUM(graph, graph->get_source_node(edge_list.back())));
                node_set.insert(GET_NODE_SEQ_NUM(graph, graph->get_target_node(edge_list.back())));
                edge_list.pop_back();
                //cout << endl;

                //cout << node_set.size() << endl;
                if (node_set.find(s) != node_set.end() && node_set.find(t) != node_set.end()) {
                    for (set<int>::iterator set_itr = node_set.begin(); set_itr != node_set.end(); set_itr++) {
                        set_nodes_on_simple_path.insert(GET_NODE_ID(graph, *set_itr));
                    }
                }
                node_set.clear();
            }
        } else if (target != parent[source] && discovery[target] < low_values[source]) {
            low_values[source] = min(low_values[source], discovery[target]);
            edge_list.push_back(*i);
        }

    }



}

void GraphManagerNew::get_nodes_on_simple_path(GraphNew * graph, int source, int target, set<int>& set_nodes_on_simple_path) {

    int source_nid = GET_NODE_ID(graph, source);
    int target_nid = GET_NODE_ID(graph, target);

    // add temporary edge between i and j
    int temp_edge_eid = graph->create_new_edge();
    graph->add_source_node(temp_edge_eid, source_nid);
    graph->add_target_node(temp_edge_eid, target_nid);
    graph->add_edge_to_outlist_of_node(source_nid, temp_edge_eid);

    int temp_rev_edge_eid = graph->create_new_edge();
    graph->add_source_node(temp_rev_edge_eid, target_nid);
    graph->add_target_node(temp_rev_edge_eid, source_nid);
    graph->add_edge_to_outlist_of_node(target_nid, temp_rev_edge_eid);


    // get biconnected component involving this edge
    int V = graph->get_node_ids().size();

    vector<int> discovery(V, 0);
    vector<int> low_values(V, 0);
    vector<int> parents(V, 0);
    list<int> edge_list;
    set<int> node_set;

    for (int i = 0; i < V; i++) {
        if (discovery[i] == 0) {
            get_nodes_on_simple_path_internal(graph, source, target, i, discovery, low_values, edge_list, node_set, set_nodes_on_simple_path, parents);
        }


        int k = 0;
        while (edge_list.size() > 0) {
            k = 1;
            //cout << GET_NODE_SEQ_NUM(graph, graph->get_source_node(edge_list.back())) << " -- " << GET_NODE_SEQ_NUM(graph, graph->get_target_node(edge_list.back())) << " ";
            node_set.insert(GET_NODE_SEQ_NUM(graph, graph->get_source_node(edge_list.back())));
            node_set.insert(GET_NODE_SEQ_NUM(graph, graph->get_target_node(edge_list.back())));
            edge_list.pop_back();

        }

        if (k == 1) {
            //cout << endl;
            //cout << node_set.size() << endl;
            if (node_set.find(source) != node_set.end() && node_set.find(target) != node_set.end()) {
                for (set<int>::iterator set_itr = node_set.begin(); set_itr != node_set.end(); set_itr++) {
                    set_nodes_on_simple_path.insert(GET_NODE_ID(graph, *set_itr));

                }

            }
            node_set.clear();
        }



    }


    // delete temp edges
    EdgeNew * edge = graph->get_edge_from_eid(temp_edge_eid);
    EdgeNew * rev_edge = graph->get_edge_from_eid(temp_rev_edge_eid);

    graph->get_node_from_nid(graph->get_source_node(temp_edge_eid))->remove_from_outlist(temp_edge_eid);
    graph->get_node_from_nid(graph->get_source_node(temp_rev_edge_eid))->remove_from_outlist(temp_rev_edge_eid);

    delete edge;
    delete rev_edge;

    //graph->remove_edge(temp_edge_eid);
    //graph->remove_edge(temp_rev_edge_eid);

}

//// Implements the relabel-to-front algorithm
//void GraphManagerNew::compute_min_cut_for_ghtree_relabel_to_front(GraphNew * original_graph, int i, int j, set<int>& cut_edges, set<int>& set_s) {
//    
//    cout << "Mincut " << i << endl;
//    
//#ifdef DEBUG_FLAG
//    debug_log << "Mincut iteration " << i << endl;
//    debug_log << "-------------------------------" << endl;
//    
//    debug_log << "between " << i << " and " << j << endl;
//
//#endif
//            
//    static int num_of_nodes, new_gid;
//    static int num_of_edges;
//    static map<int, int> map_nseq_to_res_graph_nid;
//    
//    static GraphNew * residual_graph;
//    
//    int curr_height, curr_excess;
//    int relabel_count = 0;
//    
//    static set<int> set_seq_with_outgoing_edges_explored;
//    set<int>::iterator set_itr;
//    
//    vector<int> outlist;
//    vector<int>::iterator vec_itr;
//    
//    set<int> set_t;
//    
//    // this maps store the index of the neighboring node under consideration -- used for discharge
//    map<int, int> nid_to_outlist_index;
//    int new_nid, itr=0;
//    
//#ifdef OPT_GAP_HEUR_FLAG    
//    int N = original_graph->get_node_ids().size();
//    vector<int> count_height(2*N+1);
//    
//    count_height[N] = 1;
//    count_height[0] = N-1;
//#endif 
//    
//#ifdef OPT_MIN_DEGREE_FLAG    
//    int sink_sat = 0;
//    int sink_in = original_graph->get_inlist(GET_NODE_ID(original_graph, j)).size();
//    int src_out = original_graph->get_outlist(GET_NODE_ID(original_graph, i)).size();
//    bool need_exploration = true;
//#endif    
//   
//
//#ifdef OPT_SIMPLE_PATH_FLAG
//    set<int> set_nodes_on_simple_path;
//    get_nodes_on_simple_path(original_graph, i, j, set_nodes_on_simple_path);
////    cout << i << " and " << j << ": ";
////    for (set<int>::iterator set_itr = set_nodes_on_simple_path.begin(); set_itr != set_nodes_on_simple_path.end(); set_itr++) {
////        cout << *set_itr << " ";
////    }
////    cout << endl;    
//#endif
//    
//    
//
//    static vector<vector<bool>> edge_exist(N+1,vector<bool>(N+1));
//    static unordered_map<string, long int> map_src_tgt_to_eid;
//
//
//    if (i == 1) { // creates residual graph only if this is the first iteration of the mincut code ,ie., i == 1
//            residual_graph = new GraphNew;
//            num_of_nodes = original_graph->get_node_ids().size();
//            num_of_edges = original_graph->get_edge_ids().size();
//            new_gid = ++GraphManagerNew::graph_id_count;
//            residual_graph->set_graph_id(new_gid);
//            add_graph(new_gid, residual_graph);
//#ifdef DEBUG_FLAG
//            debug_log << "Created residual graph once. Graph id is " << new_gid << endl;
//            debug_log << endl;
//#endif
//                 
//    }
//    
//
//    // creating the node for i      
//    if (map_nseq_to_res_graph_nid.find(i) == map_nseq_to_res_graph_nid.end()) {
//            new_nid = residual_graph->create_new_node();
//            
//            residual_graph->add_node_id(new_nid);
//            add_node_id_graph_id(new_nid, residual_graph->get_graph_id());
//            
//            residual_graph->add_component_id_for_node(new_nid, i); // nseq in original graph
//            residual_graph->add_component_id_for_node(new_nid, i); // identifier of mincut call
//            residual_graph->add_component_id_for_node(new_nid, num_of_nodes); // height
//            residual_graph->add_component_id_for_node(new_nid, original_graph->get_outlist(GET_NODE_ID(original_graph, i)).size()); // excess
//            
//            map_nseq_to_res_graph_nid.insert(pair<int, int>(i, new_nid));
//            nid_to_outlist_index.insert(pair<int,int>(new_nid, 0));
//            
//            
//#ifdef DEBUG_FLAG
//            debug_log << "Created new node " << new_nid << " - nseq " << i << endl;
//#endif          
//            
//    }
//    else {
//            new_nid = map_nseq_to_res_graph_nid[i];
//            residual_graph->update_component_of_node_at_index(new_nid, 1, i);         // updating identifier of mincut call
//            residual_graph->update_component_of_node_at_index(new_nid, 2, num_of_nodes); // updating height
//            residual_graph->update_component_of_node_at_index(new_nid, 3, original_graph->get_outlist(GET_NODE_ID(original_graph, i)).size()); // updating excess
//           
//            nid_to_outlist_index.insert(pair<int,int>(new_nid, 0));
//    }
//    
//    set_s.insert(i);
//    
//    list<int> nodes_list;
//    list<int>::iterator nodes_list_iter;
//    
//    nodes_list.push_back(new_nid);
//
//
//    //while (nodes_list_iter != nodes_list.end()) {
//    for (nodes_list_iter = nodes_list.begin(); nodes_list_iter != nodes_list.end(); nodes_list_iter++) {
//    
//
//#ifdef OPT_MIN_DEGREE_FLAG        
//	if (need_exploration == false)
//		break;
//#endif
//        int curr_nid_in_res_graph = *nodes_list_iter;
//        int curr_nseq_in_orig_graph = residual_graph->get_component_ids_of_node(curr_nid_in_res_graph)[0];
//        
//        int curr_excess = residual_graph->get_component_ids_of_node(curr_nid_in_res_graph)[3];
//
//	itr++;
//        
//        if (curr_excess == 0)
//            continue;
//        
//        if (itr > 1 && (curr_nseq_in_orig_graph==i||curr_nseq_in_orig_graph==j))
//            continue;
//	//if((itr>1&&(curr_nseq_in_orig_graph==i||curr_nseq_in_orig_graph==j)) || curr_excess == 0)
//	//	continue;
//
////        if(curr_excess == 0) {
////            //nodes_list_iter++;
////            continue;
////        }
//        int curr_height = residual_graph->get_component_ids_of_node(curr_nid_in_res_graph)[2];
//      
//        // if outlist is not already explored add out-edges to residual graph
//        if (set_seq_with_outgoing_edges_explored.find(curr_nseq_in_orig_graph) == set_seq_with_outgoing_edges_explored.end()) {
//            int nid = GET_NODE_ID(original_graph, curr_nseq_in_orig_graph);
//            
//            outlist = original_graph->get_outlist(nid);
//            
//            for(vec_itr = outlist.begin(); vec_itr != outlist.end(); vec_itr++) {
//                
//                int succ_node_id = original_graph->get_target_node(*vec_itr);
//#ifdef OPT_SIMPLE_PATH_FLAG
//                if (set_nodes_on_simple_path.find(succ_node_id) == set_nodes_on_simple_path.end())
//                    continue;
//#endif
//                
//		//cout<<nid<<"("<<*vec_itr<<")"<<succ_node_id<<endl;
//
//                if(succ_node_id == nid) {
//                    //nodes_list_iter++;
//                    continue;
//                }
//                
//                int succ_node_seq = GET_NODE_SEQ_NUM(original_graph, succ_node_id);
//                
//                bool create_new_edge = false;
//                
//                // create target node if not already created -- set height and excess to zero
//                if (map_nseq_to_res_graph_nid.find(succ_node_seq) == map_nseq_to_res_graph_nid.end()) {
//                    int new_nid_in_res_graph = residual_graph->create_new_node();
//                    
//                    residual_graph->add_node_id(new_nid_in_res_graph);
//                    add_node_id_graph_id(new_nid_in_res_graph, residual_graph->get_graph_id());
//            
//                    residual_graph->add_component_id_for_node(new_nid_in_res_graph, succ_node_seq); // nseq in original graph
//                    residual_graph->add_component_id_for_node(new_nid_in_res_graph, i); // identifier for mincut call
//                    residual_graph->add_component_id_for_node(new_nid_in_res_graph, 0); // height
//                    residual_graph->add_component_id_for_node(new_nid_in_res_graph, 0); // excess
//                    
//                    map_nseq_to_res_graph_nid.insert(pair<int, int>(succ_node_seq, new_nid_in_res_graph));
//                    nid_to_outlist_index.insert(pair<int,int>(new_nid_in_res_graph, 0)); 
//                    if (std::find(nodes_list.begin(), nodes_list.end(), new_nid_in_res_graph) == nodes_list.end()) {
//                        nodes_list.push_back(new_nid_in_res_graph);
//                    }
//                    
//#ifdef DEBUG_FLAG
//                    debug_log << "Created new node " << new_nid_in_res_graph << " - nseq " << succ_node_seq << endl;
//#endif                    
//                        
//                    int new_eid_in_res_graph = residual_graph->create_new_edge();
//                    residual_graph->add_edge_id(new_eid_in_res_graph);
//                    add_edge_id_graph_id(new_eid_in_res_graph, residual_graph->get_graph_id());
//                    residual_graph->add_source_node(new_eid_in_res_graph, curr_nid_in_res_graph);
//                    residual_graph->add_target_node(new_eid_in_res_graph, new_nid_in_res_graph);
//                    residual_graph->add_edge_to_outlist_of_node(curr_nid_in_res_graph, new_eid_in_res_graph);
//                    residual_graph->add_edge_to_inlist_of_node(new_nid_in_res_graph, new_eid_in_res_graph);
//                    residual_graph->set_other_value1_in_edge(new_eid_in_res_graph, i); // identifier of mincut call
//                    residual_graph->set_other_value2_in_edge(new_eid_in_res_graph, 1); // capacity
//                    residual_graph->set_other_value4_in_edge(new_eid_in_res_graph, *vec_itr); // eid in original graph
//                    residual_graph->add_edge_type(new_eid_in_res_graph, "original");
//                    
//                    // reverse edge
//                    int rev_eid_in_res_graph = residual_graph->create_new_edge();
//                    residual_graph->add_edge_id(rev_eid_in_res_graph);
//                    add_edge_id_graph_id(rev_eid_in_res_graph, residual_graph->get_graph_id());
//                    residual_graph->add_target_node(rev_eid_in_res_graph, curr_nid_in_res_graph);
//                    residual_graph->add_source_node(rev_eid_in_res_graph, new_nid_in_res_graph);
//                    residual_graph->add_edge_to_inlist_of_node(curr_nid_in_res_graph, rev_eid_in_res_graph);
//                    residual_graph->add_edge_to_outlist_of_node(new_nid_in_res_graph, rev_eid_in_res_graph);
//                    residual_graph->set_other_value1_in_edge(rev_eid_in_res_graph, i); // identifier of mincut call
//                    
//                    int rev_eid_in_orig_graph = -1;
//                    bool orig_edge = false;
//                    vector<int> outlist2 = original_graph->get_outlist(succ_node_id);
//                    for (vector<int>::iterator out_itr = outlist2.begin(); out_itr != outlist2.end(); out_itr++) {
//                            if (original_graph->get_target_node(*out_itr) == nid) {
//                                    orig_edge = true;
//                                    rev_eid_in_orig_graph = *out_itr;
//                                    break;
//                            }
//                            
//                    }
//                    
//                    if(orig_edge) {
//                            residual_graph->set_other_value2_in_edge(rev_eid_in_res_graph, 1); // capacity
//                            residual_graph->add_edge_type(rev_eid_in_res_graph, "original");
//                            
//                    }
//                    else {
//                            residual_graph->set_other_value2_in_edge(rev_eid_in_res_graph, 0); // capacity
//                            residual_graph->add_edge_type(rev_eid_in_res_graph, "not_original");
//                            
//                    }
//                    residual_graph->set_other_value3_in_edge(rev_eid_in_res_graph, new_eid_in_res_graph); // eid of paired reverse edge
//                    residual_graph->set_other_value3_in_edge(new_eid_in_res_graph, rev_eid_in_res_graph); // eid of paired reverse edge
//                    residual_graph->set_other_value4_in_edge(rev_eid_in_res_graph, rev_eid_in_orig_graph); // eid in original graph
//
//		    //anjan
//		    edge_exist[curr_nseq_in_orig_graph][succ_node_seq] = edge_exist[succ_node_seq][curr_nseq_in_orig_graph] = true;
//		    stringstream ss1, ss2;
//		    ss1<<curr_nid_in_res_graph<<":"<<new_nid_in_res_graph;
//		    ss2<<new_nid_in_res_graph<<":"<<curr_nid_in_res_graph;
//		    map_src_tgt_to_eid.insert(pair<string,long int>(ss1.str(), new_eid_in_res_graph));
//		    map_src_tgt_to_eid.insert(pair<string,long int>(ss2.str(), rev_eid_in_res_graph));
//
//                }
//                
//                // target node is already created -- update height and excess to zero for i-th iteration of mincut
//                else {
//                        int succ_nid_in_res_graph = map_nseq_to_res_graph_nid[succ_node_seq];
//                        assert(succ_nid_in_res_graph != curr_nid_in_res_graph);
//                        
//                        if(residual_graph->get_component_ids_of_node(succ_nid_in_res_graph)[1]!=i) {
//                        
//                            residual_graph->update_component_of_node_at_index(succ_nid_in_res_graph, 1, i); // updating identifier of mincut call
//                            residual_graph->update_component_of_node_at_index(succ_nid_in_res_graph, 2, 0); // updating height
//                            residual_graph->update_component_of_node_at_index(succ_nid_in_res_graph, 3, 0); // updating excess
//                        }
//                      //need optimization -- matrix is needed. edge_exist[curr_node_id][succ_node_id]  
//                       /* int res_eid;
//                        bool res_edge = false;
//                        vector<int> outlist3 = residual_graph->get_outlist(curr_nid_in_res_graph);
//                        for (vector<int>::iterator out_itr = outlist3.begin(); out_itr != outlist3.end(); out_itr++) {
//                            res_eid = *out_itr;    
//                            
//                            if (residual_graph->get_target_node(res_eid) == succ_nid_in_res_graph) {
//                                    res_edge = true;
//                                    break;
//                            }
//                            
//                        }*/
//
//                       // if (res_edge) {
//                          if(edge_exist[curr_nseq_in_orig_graph][succ_node_seq]) {
//			   int res_eid;
//			   stringstream ss;
//			   ss<<curr_nid_in_res_graph<<":"<<succ_nid_in_res_graph;
//  			   res_eid = map_src_tgt_to_eid[ss.str()];
//			   if(residual_graph->get_other_value1_in_edge(res_eid)!=i){
//                                residual_graph->set_other_value1_in_edge(res_eid, i); // identifier of mincut call
//                                assert(residual_graph->get_edge_type(res_eid) == "original");
//                                residual_graph->set_other_value2_in_edge(res_eid, 1); // capacity
//			    }
//                                int rev_res_eid = residual_graph->get_other_value3_in_edge(res_eid); // eid of paired reverse edge
//                            if(residual_graph->get_other_value1_in_edge(rev_res_eid)!=i){    
//                                residual_graph->set_other_value1_in_edge(rev_res_eid, i); // identifier of mincut call
//                                if (residual_graph->get_edge_type(rev_res_eid) == "original") {
//                                        residual_graph->set_other_value2_in_edge(rev_res_eid, 1); // capacity
//                                }
//                                else {
//                                        residual_graph->set_other_value2_in_edge(rev_res_eid, 0); // capacity
//                                }
//			    }
//                        }
//                        else {
//                                    int new_eid_in_res_graph = residual_graph->create_new_edge();
//                                    residual_graph->add_edge_id(new_eid_in_res_graph);
//                                    add_edge_id_graph_id(new_eid_in_res_graph, residual_graph->get_graph_id());
//                                    residual_graph->add_source_node(new_eid_in_res_graph, curr_nid_in_res_graph);
//                                    residual_graph->add_target_node(new_eid_in_res_graph, succ_nid_in_res_graph);
//                                    residual_graph->add_edge_to_outlist_of_node(curr_nid_in_res_graph, new_eid_in_res_graph);
//                                    residual_graph->add_edge_to_inlist_of_node(succ_nid_in_res_graph, new_eid_in_res_graph);
//                                    residual_graph->set_other_value1_in_edge(new_eid_in_res_graph, i); // identifier of mincut call
//                                    residual_graph->set_other_value2_in_edge(new_eid_in_res_graph, 1); // capacity
//                                    residual_graph->set_other_value4_in_edge(new_eid_in_res_graph, *vec_itr);  // eid in original graph
//                                    residual_graph->add_edge_type(new_eid_in_res_graph, "original");
//
//                                    // reverse edge
//                                    int rev_eid_in_res_graph = residual_graph->create_new_edge();
//                                    residual_graph->add_edge_id(rev_eid_in_res_graph);
//                                    add_edge_id_graph_id(rev_eid_in_res_graph, residual_graph->get_graph_id());
//                                    residual_graph->add_target_node(rev_eid_in_res_graph, curr_nid_in_res_graph);
//                                    residual_graph->add_source_node(rev_eid_in_res_graph, succ_nid_in_res_graph);
//                                    residual_graph->add_edge_to_inlist_of_node(curr_nid_in_res_graph, rev_eid_in_res_graph);
//                                    residual_graph->add_edge_to_outlist_of_node(succ_nid_in_res_graph, rev_eid_in_res_graph);
//                                    residual_graph->set_other_value1_in_edge(rev_eid_in_res_graph, i); // identifier of mincut call
//
//                                    int rev_eid_in_orig_graph = -1;
//                                    bool orig_edge = false;
//                                    vector<int> outlist2 = original_graph->get_outlist(succ_node_id);
//                                    for (vector<int>::iterator out_itr = outlist2.begin(); out_itr != outlist2.end(); out_itr++) {
//                                            if (original_graph->get_target_node(*out_itr) == nid) {
//                                                    rev_eid_in_orig_graph = *out_itr;
//                                                    orig_edge = true;
//                                                    break;
//                                            }
//
//                                    }
//
//                                    if(orig_edge) {
//                                            residual_graph->set_other_value2_in_edge(rev_eid_in_res_graph, 1); // capacity
//                                            residual_graph->add_edge_type(rev_eid_in_res_graph, "original");
//                                    }
//                                    else {
//                                            residual_graph->set_other_value2_in_edge(rev_eid_in_res_graph, 0); // capacity
//                                            residual_graph->add_edge_type(rev_eid_in_res_graph, "not_original");
//                                    }
//                                    residual_graph->set_other_value3_in_edge(rev_eid_in_res_graph, new_eid_in_res_graph); // eid of paired reverse edge
//                                    residual_graph->set_other_value3_in_edge(new_eid_in_res_graph, rev_eid_in_res_graph); // eid of paired reverse edge
//                                    residual_graph->set_other_value4_in_edge(rev_eid_in_res_graph, rev_eid_in_orig_graph);  // eid in original graph
//
//				    //anjan
//				    edge_exist[curr_nseq_in_orig_graph][succ_node_seq] = edge_exist[succ_node_seq][curr_nseq_in_orig_graph] = true;
//		   		    stringstream ss1, ss2;
//		    		    ss1<<curr_nid_in_res_graph<<":"<<succ_nid_in_res_graph;
//		    		    ss2<<succ_nid_in_res_graph<<":"<<curr_nid_in_res_graph;
//		    		    map_src_tgt_to_eid.insert(pair<string,long int>(ss1.str(), new_eid_in_res_graph));
//		    		    map_src_tgt_to_eid.insert(pair<string,long int>(ss2.str(), rev_eid_in_res_graph));
//
//                        }
//                }
//            }
//              
//            set_seq_with_outgoing_edges_explored.insert(curr_nseq_in_orig_graph);
//            
//  
//        }
//        
//        
//        set<int> set_eids_to_tgt_nodes_with_min_height;
//        int min_height_tgt_node_in_res_graph;
//        int cum_flow_thru_edges_to_min_height_neighbr;
//        
//
//        int old_height = residual_graph->get_component_ids_of_node(curr_nid_in_res_graph)[2];
//
//
//        // reset height, excess, capacities in residual graph for the current mincut call
//        vector<int> outlist5 = residual_graph->get_outlist(curr_nid_in_res_graph);
//        vector<int>::iterator out_itr;
//        for (vector<int>::iterator out_itr = outlist5.begin(); out_itr != outlist5.end(); out_itr++) {
//
//            int res_eid = *out_itr;
//            int res_eid_tgt = residual_graph->get_target_node(res_eid);
//            
////#ifdef OPT_SIMPLE_PATH_FLAG
////            int tgt_nid_in_orig_graph = GET_NODE_ID(original_graph, residual_graph->get_component_ids_of_node(res_eid_tgt)[0]);
////            if (set_nodes_on_simple_path.find(tgt_nid_in_orig_graph) == set_nodes_on_simple_path.end())
////                    continue;
////#endif            
//
//            if (residual_graph->get_other_value1_in_edge(res_eid) != i) { //edge created in a previous mincut call
//
//                    if (residual_graph->get_component_ids_of_node(res_eid_tgt)[1] != i) {
//
//                        residual_graph->update_component_of_node_at_index(res_eid_tgt, 1, i); // updating identifier of mincut call
//                        residual_graph->update_component_of_node_at_index(res_eid_tgt, 2, 0); // updating height
//                        residual_graph->update_component_of_node_at_index(res_eid_tgt, 3, 0); // updating excess
//
//
//                    }
//                    residual_graph->set_other_value1_in_edge(res_eid, i);
//                    if (residual_graph->get_edge_type(res_eid) == "original") {
//                            residual_graph->set_other_value2_in_edge(res_eid, 1); // capacity
//                    }
//                    else {
//                            residual_graph->set_other_value2_in_edge(res_eid, 0); // capacity
//                    }
//
//                    // since edge with id res_eid was created in a prev mincut call,
//                    // then the corresponding rev edge with id rev_res_eid 
//                    // should also have been created in the prev mincut call
//                    int rev_res_eid = residual_graph->get_other_value3_in_edge(res_eid);
//                    assert(residual_graph->get_other_value1_in_edge(rev_res_eid) != i);
//
//                    residual_graph->set_other_value1_in_edge(rev_res_eid, i);
//                    if (residual_graph->get_edge_type(rev_res_eid) == "original") {
//                            residual_graph->set_other_value2_in_edge(rev_res_eid, 1); // capacity
//                    }
//                    else {
//                            residual_graph->set_other_value2_in_edge(rev_res_eid, 0); // capacity
//                    }
//            }
//        }
//
//        // discharge begins
//        int count = 0;
//        while (curr_excess > 0) {
//            
//            if (residual_graph->get_component_ids_of_node(curr_nid_in_res_graph)[0] == j) {
//                //nodes_list_iter++;
//                break;
//            }
//            int curr_outlist_index = nid_to_outlist_index[curr_nid_in_res_graph];
//            
//            if (curr_outlist_index == (outlist5.size())) {
//                if (residual_graph->get_component_ids_of_node(curr_nid_in_res_graph)[0] == i) {
//                    //nodes_list_iter++;
//                    break;
//                }
//                
//#ifdef OPT_GAP_HEUR_FLAG               
//                // Gap heuristic
//                if(count_height[curr_height]==1){
//		
//                        int height_v;
//                        cout<<"+++node = "<<curr_nid_in_res_graph<<"("<<curr_nseq_in_orig_graph<<")"<<"height = "<<curr_height<<endl;
//			vector<int> res_nids = residual_graph->get_node_ids();
//			for (vector<int>::iterator iter = res_nids.begin(); iter != res_nids.end(); iter++) {
//			//for (int v = 0; v <N; v++) {
//				//if (map_nseq_to_res_graph_nid.find(v) != map_nseq_to_res_graph_nid.end()){
//					int v_in_res  = *iter;
//					//int v_in_res  = map_nseq_to_res_graph_nid[v];
//      	    				height_v = residual_graph->get_component_ids_of_node(v_in_res)[2];
//					if (height_v < curr_height || residual_graph->get_component_ids_of_node(v_in_res)[1] != i) 
//						continue;
//					count_height[height_v]--;
//					height_v = max(height_v, N+1);
//                                        residual_graph->update_component_of_node_at_index(v_in_res, 2, height_v); //update height
//                                        count_height[height_v]++;
//				//}
//			}
////                        //if (height_v >= N) {
////                        if (height_v >= residual_graph->get_node_ids().size()) {  // -- CHECK
////                            set_s.insert(curr_nseq_in_orig_graph);
////                            
////                        }
//		}else{
//#endif
//                    // relabel
//                
//              	  int min_neighbr_height = inf;
//              	  int neighbr_height;
//            	  for (out_itr = outlist5.begin(); out_itr != outlist5.end(); out_itr++) {
//                    int tgt_node = residual_graph->get_target_node(*out_itr);
//		    int edge_cap = residual_graph->get_other_value2_in_edge(*out_itr);
//                    neighbr_height = residual_graph->get_component_ids_of_node(tgt_node)[2];
//                    if ((neighbr_height < min_neighbr_height)&&edge_cap>0) {
//                        min_neighbr_height = neighbr_height;
//                    }
//                    
//                  }
//
//#ifdef OPT_GAP_HEUR_FLAG
//		  count_height[curr_height]--;
//#endif
//
//             	  residual_graph->update_component_of_node_at_index(curr_nid_in_res_graph, 2, min_neighbr_height+1);
//                  curr_height = min_neighbr_height+1;
////                  if (i == 1)
////                    cout << "height increased " << curr_nseq_in_orig_graph << ": " << curr_height << endl;
//                  relabel_count++;
////                  if (curr_height >= num_of_nodes) {
////                  //if (curr_height >= residual_graph->get_node_ids().size()) { // -- CHECK
////                    set_s.insert(residual_graph->get_component_ids_of_node(curr_nid_in_res_graph)[0]);
////                    //cout << "inserting " << residual_graph->get_component_ids_of_node(curr_nid_in_res_graph)[0] << endl;
////                    
////                  }
//#ifdef OPT_GAP_HEUR_FLAG                  
//           	  count_height[curr_height]++;
//                  }
//#endif  
//             	 
//		 nid_to_outlist_index[curr_nid_in_res_graph] = 0;  
//            }
//            
//            else {
//                
//                int curr_outlist_edge = outlist5[curr_outlist_index];
//                int curr_outlist_edge_capacity = residual_graph->get_other_value2_in_edge(curr_outlist_edge);
//                int curr_node_height = residual_graph->get_component_ids_of_node(curr_nid_in_res_graph)[2];
//                int curr_tgt_node_height = residual_graph->get_component_ids_of_node(residual_graph->get_target_node(curr_outlist_edge))[2];
//                
//                if ((curr_outlist_edge_capacity > 0) && ((map_nseq_to_res_graph_nid[i] == curr_nid_in_res_graph) || (curr_node_height == curr_tgt_node_height + 1))) {
//                    
//                    // push
//                    int tgt_node_in_res_graph = residual_graph->get_target_node(curr_outlist_edge);
//		    int tgt_nseq_in_orig_graph = residual_graph->get_component_ids_of_node(tgt_node_in_res_graph)[0];
//                    int curr_edge_capacity = residual_graph->get_other_value2_in_edge(curr_outlist_edge);
//                    // update flow
//                    int flow = (curr_excess < curr_edge_capacity) ? curr_excess : curr_edge_capacity;
//                    residual_graph->update_component_of_node_at_index(curr_nid_in_res_graph, 3, curr_excess-flow);
//                    int tgt_excess = residual_graph->get_component_ids_of_node(tgt_node_in_res_graph)[3];
//                    residual_graph->update_component_of_node_at_index(tgt_node_in_res_graph, 3, tgt_excess+flow);
//                    
//                    
//                    if ((tgt_nseq_in_orig_graph != i) && (tgt_nseq_in_orig_graph != j)) {
//                    
//                        
//                        if (std::find(nodes_list.begin(), nodes_list.end(), tgt_node_in_res_graph) == nodes_list.end()) {
//                                nodes_list.push_back(tgt_node_in_res_graph);
//                        }
//                        
//                    }
//
//                    // update capacity
//                    residual_graph->set_other_value2_in_edge(curr_outlist_edge, curr_edge_capacity-flow);
//                    int rev_edge_id = residual_graph->get_other_value3_in_edge(curr_outlist_edge);
//                    int rev_edge_capacity = residual_graph->get_other_value2_in_edge(rev_edge_id);
//                    residual_graph->set_other_value2_in_edge(rev_edge_id, rev_edge_capacity+flow);
//                    
//                    curr_excess = curr_excess - flow;    
//
//                    
//#ifdef OPT_MIN_DEGREE_FLAG                    
//                    //anjan -- optimization if maxflow(s,t) == min(|source_outlist|, |sink_inlist|)
//		    if(tgt_nseq_in_orig_graph == j){
//			++sink_sat;
//		    }
//
//		    if(sink_sat == min(sink_in, src_out)){			
//		    	need_exploration = false;
//			break;
//		    }
//#endif                    
//                    
//                }
//                
//                else {
//                    nid_to_outlist_index[curr_nid_in_res_graph] = curr_outlist_index + 1;
//                }
//            } 
//            
//            
//            count++;
//        }
//        //cout << "loop count = " << count << endl;
//        // discharge ends
//
//        // if node's height is increased, move node to front of nodes_list
//        if (curr_height > old_height) {
//            
//            list<int>::iterator element = nodes_list_iter;
//            if (element != nodes_list.begin()) {
//                nodes_list.splice(nodes_list.begin(), nodes_list, element, std::next(element));
//                
//            }
//            
//        }
//        
////        if (i == 1) {
////        cout << "\nNodes list ";
////        for (list<int>::iterator it = nodes_list.begin(); it != nodes_list.end(); it++) {
////            cout << residual_graph->get_component_ids_of_node(*it)[0] << " ";
////        }
////        cout << endl;
////        }
//      
//        //nodes_list_iter++;
//        
//    }
//
//    set<int> set_nodes_frwd_reachable_from_i;
//    set<int> set_nodes_bkwd_reachable_from_j;
//    set<int> set_frwd_edges_from_i_with_zero_capacity;
//    set<int> set_bkwd_edges_from_j_with_zero_capacity;
//    
//    set_nodes_frwd_reachable_from_i.insert(i);
//    set_nodes_bkwd_reachable_from_j.insert(j);
//#ifdef OPT_MIN_DEGREE_FLAG    
//    if(need_exploration){
//#endif    
//	//set<int> set_t;
////	set_difference(set_seq_with_outgoing_edges_explored.begin(), set_seq_with_outgoing_edges_explored.end(), 
////			set_s.begin(), set_s.end(), inserter(set_t, set_t.begin()));
//	
//
//        
//        
////	set<int> set_nodes_frwd_reachable_from_i;
////	set<int> set_nodes_bkwd_reachable_from_j;
////	set<int> set_frwd_edges_from_i_with_zero_capacity;
////	set<int> set_bkwd_edges_from_j_with_zero_capacity;
//
//	set<int> visited;
//	list<int> bfs_queue;
//
//	// find forward reachable nodes and edges from i
//	bfs_queue.push_back(i);
//	//bfs_queue.push_back(map_nseq_to_res_graph_nid[i]);
//
//	while (!bfs_queue.empty()) {
//
//		int curr_node = bfs_queue.front();
//
//		bfs_queue.pop_front();
//
//		if (visited.find(curr_node) == visited.end()) {
//			set_nodes_frwd_reachable_from_i.insert(curr_node); // takes node seq num
//			            //cout << "frwd rchble from i " << curr_node << endl;
//			            if (curr_node > i){
//			                set_s.insert(curr_node);  // takes node seq num
//			            }
//			visited.insert(curr_node);
//			// traverse outlist
//			vector<int> outlist_of_i_side_node = residual_graph->get_outlist(map_nseq_to_res_graph_nid[curr_node]);
//			for (vector<int>::iterator outlist_of_i_itr = outlist_of_i_side_node.begin(); outlist_of_i_itr != outlist_of_i_side_node.end(); outlist_of_i_itr++) {
//				int curr_edge = (*outlist_of_i_itr);
//
//
//				if (residual_graph->get_other_value2_in_edge(curr_edge) == 0) { // stop at zero capacity edge
//					set_frwd_edges_from_i_with_zero_capacity.insert(curr_edge);
//
//
//				}
//
//				else {
//					int target_nid = residual_graph->get_target_node(curr_edge);
//					bfs_queue.push_back(residual_graph->get_component_ids_of_node(target_nid)[0]);
//
//				}
//
//			}
//		}
//
//	}
//
//	assert(bfs_queue.empty());
//	visited.clear();
//
//	// find backward reachable nodes and edges from j
//	bfs_queue.push_back(j);
//	//bfs_queue.push_back(map_nseq_to_res_graph_nid[j]);
//
//	while (!bfs_queue.empty()) {
//		int curr_node = bfs_queue.front();
//		//int source_nid;
//		bfs_queue.pop_front();
//
//		if (visited.find(curr_node) == visited.end()) {
//			//           cout << "bkwd rchble from j " << curr_node << endl;
//			set_nodes_bkwd_reachable_from_j.insert(curr_node); // takes node seq num
//			visited.insert(curr_node);
//			// traverse inlist
//
//			vector<int> inlist_of_j_side_node = residual_graph->get_inlist(map_nseq_to_res_graph_nid[curr_node]);
//			for (vector<int>::iterator inlist_of_j_itr = inlist_of_j_side_node.begin(); inlist_of_j_itr != inlist_of_j_side_node.end(); inlist_of_j_itr++) {
//				int curr_edge = (*inlist_of_j_itr);
//
//				//anjan
//				if(residual_graph->get_edge_type(curr_edge) == "original"){
//					if ((residual_graph->get_other_value2_in_edge(curr_edge) == 0)&&(set_frwd_edges_from_i_with_zero_capacity.find(curr_edge)!=set_frwd_edges_from_i_with_zero_capacity.end())) { // stop at zero capacity edge
//						//anjan
//						set_bkwd_edges_from_j_with_zero_capacity.insert(curr_edge);
//						//cut_edges.insert(curr_edge); // commented out by sukanya
//					}
//
//					else {//anjan
//						if(residual_graph->get_other_value2_in_edge(curr_edge) == 0)
//							set_bkwd_edges_from_j_with_zero_capacity.insert(curr_edge);
//						//bfs_queue.push_back(residual_graph->get_source_node(curr_edge)); // changed by sukanya
//						int source_nid = residual_graph->get_source_node(curr_edge);
//						bfs_queue.push_back(residual_graph->get_component_ids_of_node(source_nid)[0]);
//					}
//				}
//
//
//				//                if (residual_graph->get_edge_type(curr_edge) == "original") {
//				//                    int source_nid = residual_graph->get_source_node(curr_edge);
//				//                    if (set_nodes_frwd_reachable_from_i.find(residual_graph->get_component_ids_of_node(source_nid)[0]) == set_nodes_frwd_reachable_from_i.end()) {
//				//                            set_bkwd_edges_from_j_with_zero_capacity.insert(curr_edge);
//				//                            bfs_queue.push_back(residual_graph->get_component_ids_of_node(source_nid)[0]);
//				//                    }
//				//                   
//				//                }
//
//
//
//			}
//		}
//
//	}
//	set<int> undirected_cut_edges;
//
//	for (set<int>::iterator set_itr2 = set_frwd_edges_from_i_with_zero_capacity.begin(); set_itr2 != set_frwd_edges_from_i_with_zero_capacity.end(); set_itr2++) {
//		int curr_tgt = residual_graph->get_component_ids_of_node(residual_graph->get_target_node(*set_itr2))[0];
//		if (set_nodes_bkwd_reachable_from_j.find(curr_tgt) != set_nodes_bkwd_reachable_from_j.end()) {
//			undirected_cut_edges.insert(residual_graph->get_other_value4_in_edge(*set_itr2));
//			int rev_eid_in_res_graph = residual_graph->get_other_value3_in_edge(*set_itr2);
//			undirected_cut_edges.insert(residual_graph->get_other_value4_in_edge(rev_eid_in_res_graph));
//		}
//
//	}
//
//	//    set_intersection(set_frwd_edges_from_i_with_zero_capacity.begin(), set_frwd_edges_from_i_with_zero_capacity.end(), 
//	//            set_bkwd_edges_from_j_with_zero_capacity.begin(), set_bkwd_edges_from_j_with_zero_capacity.end(), inserter(undirected_cut_edges, undirected_cut_edges.begin()));
//
//	set<int>::iterator cut_edges_itr;
//	for (cut_edges_itr = undirected_cut_edges.begin(); cut_edges_itr != undirected_cut_edges.end(); cut_edges_itr++) {
//		//int eid_in_orig_graph = residual_graph->get_other_value4_in_edge(*cut_edges_itr);
//		int eid_in_orig_graph = *cut_edges_itr;
//		if (eid_in_orig_graph != -1) {
//			cut_edges.insert(eid_in_orig_graph);
//		}
//	}
//       
//
//#ifdef OPT_MIN_DEGREE_FLAG
//    }else{// for maxflow(s,t) == min(src_outlist, sink_inlist) optimization
//	vector<int> inlist, outlist, all_org_nids;
//	set_s.clear();
//	if(sink_sat == sink_in){
//		//get the edges of source
//		 int j_id = GET_NODE_ID(original_graph, j);
//		 inlist = original_graph->get_inlist(j_id);
//		 outlist = original_graph->get_outlist(j_id);
//
//		//populate set_s
//		all_org_nids = original_graph->get_node_ids();
//		for (vector<int>::iterator node_itr = all_org_nids.begin(); node_itr != all_org_nids.end(); node_itr++){
//		    if(GET_NODE_SEQ_NUM(original_graph, *node_itr) >= i)
//			set_s.insert(GET_NODE_SEQ_NUM(original_graph, *node_itr)); 
//		}
//		set_s.erase(j); 
//		
//		 
//	}else{
//		//get the outlist of source
//		 int i_id = GET_NODE_ID(original_graph, i);
//		 inlist = original_graph->get_inlist(i_id);
//		 outlist = original_graph->get_outlist(i_id);
//
//		//populate set_s
//		set_s.insert(i);
//		
//	}
//	//push them into cut-edge
//	for (vector<int>::iterator in_itr = inlist.begin(); in_itr != inlist.end(); in_itr++){
//		int eid_in_orig_graph = *in_itr;
//		if (eid_in_orig_graph != -1)
//			cut_edges.insert(eid_in_orig_graph);
//		//cout<<eid_in_orig_graph<<" ";
//	}
//	for (vector<int>::iterator out_itr = outlist.begin(); out_itr != outlist.end(); out_itr++){
//		int eid_in_orig_graph = *out_itr;
//		if (eid_in_orig_graph != -1)
//				cut_edges.insert(eid_in_orig_graph);
//		//cout<<eid_in_orig_graph<<" ";
//			
//	}
//
//	
//    }
//#endif        
//       
////#ifdef DEBUG_FLAG        
////        debug_log << "Node sets" << " s: " << set_nodes_frwd_reachable_from_i.size() << " t: " << set_nodes_bkwd_reachable_from_j.size() << endl;
////        debug_log << "S: ";
////        for (set<int>::iterator iter = set_nodes_frwd_reachable_from_i.begin(); iter != set_nodes_frwd_reachable_from_i.end(); iter++) {
////            debug_log << *iter << " - " << residual_graph->get_component_ids_of_node(map_nseq_to_res_graph_nid[*iter])[2] << " | ";
////        }
////        debug_log << endl;
////
////        debug_log << "T: ";
////        for (set<int>::iterator iter = set_nodes_bkwd_reachable_from_j.begin(); iter != set_nodes_bkwd_reachable_from_j.end(); iter++) {
////            debug_log << *iter << " - " << residual_graph->get_component_ids_of_node(map_nseq_to_res_graph_nid[*iter])[2] << " | ";
////        }
////        debug_log << endl;
////#endif     
//
//#ifdef DEBUG_FLAG
//        debug_log << "Node sets" << " s: " << set_nodes_frwd_reachable_from_i.size() << " t: " << set_nodes_bkwd_reachable_from_j.size() << endl;
//	debug_log << "cut_edges: ";
//	for (set<int>::iterator set_itr2 = cut_edges.begin(); set_itr2 != cut_edges.end(); set_itr2++) {
//		debug_log << *set_itr2 << " ";
//	}
//	debug_log << endl;
//
//#endif     
//   
//        assert (residual_graph->get_edge_ids().size() <= num_of_edges);
//        
//#ifdef DEBUG_FLAG
//    debug_log << "Total relabels " << relabel_count << endl;
//    debug_log << endl;
//#endif    
//
//}

// Implements the relabel-to-front algorithm

void GraphManagerNew::compute_min_cut_for_ghtree_relabel_to_front(GraphNew * original_graph, vector<int>& non_isolated_node_ids, int i, int j, set<int>& cut_edges, set<int>& set_s) {

    //cout << "Mincut " << i << endl;

#ifdef DEBUG_FLAG
    debug_log << "Mincut iteration " << i << endl;
    debug_log << "-------------------------------" << endl;

    //debug_log << "between " << i << " and " << j << endl;
    debug_log << "between " << "nseq " << i << "[nid " << original_graph->get_rep_id_from_nid(GET_NODE_ID(original_graph, i)) << "] " << " and nseq " << j << "[nid " << original_graph->get_rep_id_from_nid(GET_NODE_ID(original_graph, j)) << "] " << endl;

#endif

    static int num_of_nodes;
    static int new_gid;
    static int num_of_edges;
    static map<int, int> map_nseq_to_res_graph_nid;

    static GraphNew * residual_graph;

    int curr_height, curr_excess;
    float float_curr_excess;
    
    int relabel_count = 0;

    static set<int> set_seq_with_outgoing_edges_explored;
    set<int>::iterator set_itr;

    vector<int> outlist;
    vector<int>::iterator vec_itr;

    set<int> set_t;

    // this maps store the index of the neighboring node under consideration -- used for discharge
    map<int, int> nid_to_outlist_index;
    int new_nid, itr = 0;

    //int N = original_graph->get_node_ids().size();
    int N = non_isolated_node_ids.size();
    vector<bool> src_side_nodes(N + 1, 0);

#ifdef OPT_GAP_HEUR_FLAG    

    vector<int> count_height(2 * N + 1);

    count_height[N] = 1;
    count_height[0] = N - 1;
#endif 

#ifdef OPT_MIN_DEGREE_FLAG    
    int sink_sat = 0;
    int sink_in = original_graph->get_inlist(GET_NODE_ID(original_graph, j)).size();
    int src_out = original_graph->get_outlist(GET_NODE_ID(original_graph, i)).size();
    bool need_exploration = true;
#endif    


#ifdef OPT_SIMPLE_PATH_FLAG
    set<int> set_nodes_on_simple_path;
    get_nodes_on_simple_path(original_graph, i, j, set_nodes_on_simple_path);
#ifdef DEBUG_FLAG    
    debug_log << i << " and " << j << ": ";
    for (set<int>::iterator set_itr = set_nodes_on_simple_path.begin(); set_itr != set_nodes_on_simple_path.end(); set_itr++) {
        debug_log << *set_itr << " ";
    }
    debug_log << endl;
#endif

#endif



    static vector < vector<bool >> edge_exist(N + 1, vector<bool>(N + 1));
    static unordered_map<string, long int> map_src_tgt_to_eid;


    if (i == 1) { // creates residual graph only if this is the first iteration of the mincut code ,ie., i == 1

        map_nseq_to_res_graph_nid.clear(); // added by sukanya - static maps need clearing
        set_seq_with_outgoing_edges_explored.clear(); // for multiple mincut calls in same session    

        //        edge_exist.clear();             // also resetting
        //        map_src_tgt_to_eid.clear();     // anjan's static data structures
        //        // commented out since resetting is giving a seg-fault

        residual_graph = new GraphNew;
        num_of_nodes = non_isolated_node_ids.size();
        num_of_edges = original_graph->get_edge_ids().size();
        new_gid = ++GraphManagerNew::graph_id_count;
        residual_graph->set_graph_id(new_gid);
        add_graph(new_gid, residual_graph);
        
        // populate adjacency matrix
        //fill_adj_matrix_for_graph(residual_graph);
    
#ifdef DEBUG_FLAG
        debug_log << "Created residual graph once. Graph id is " << new_gid << endl;
        debug_log << endl;
#endif

    }


    // creating the node for i      
    if (map_nseq_to_res_graph_nid.find(i) == map_nseq_to_res_graph_nid.end()) {
        new_nid = residual_graph->create_new_node();

        residual_graph->add_node_id(new_nid);
        add_node_id_graph_id(new_nid, residual_graph->get_graph_id());

        residual_graph->add_component_id_for_node(new_nid, i); // nseq in original graph
        residual_graph->add_component_id_for_node(new_nid, i); // identifier of mincut call
        residual_graph->add_component_id_for_node(new_nid, num_of_nodes); // height
        residual_graph->add_component_id_for_node(new_nid, original_graph->get_outlist(GET_NODE_ID(original_graph, i)).size()); // excess

        residual_graph->set_node_excess(new_nid, (float)original_graph->get_outlist(GET_NODE_ID(original_graph, i)).size()); // excess


        map_nseq_to_res_graph_nid.insert(pair<int, int>(i, new_nid));
        nid_to_outlist_index.insert(pair<int, int>(new_nid, 0));


#ifdef DEBUG_FLAG
        debug_log << "Created new node " << new_nid << " - nseq " << i << endl;
#endif          

    } else {
        new_nid = map_nseq_to_res_graph_nid[i];
        residual_graph->update_component_of_node_at_index(new_nid, 1, i); // updating identifier of mincut call
        residual_graph->update_component_of_node_at_index(new_nid, 2, num_of_nodes); // updating height
        residual_graph->update_component_of_node_at_index(new_nid, 3, original_graph->get_outlist(GET_NODE_ID(original_graph, i)).size()); // updating excess

        nid_to_outlist_index.insert(pair<int, int>(new_nid, 0));
    }

    set_s.insert(i);
    src_side_nodes[i] = 1;

    list<int> nodes_list;
    list<int>::iterator nodes_list_iter;

    nodes_list.push_back(new_nid);


    //while (nodes_list_iter != nodes_list.end()) {
    for (nodes_list_iter = nodes_list.begin(); nodes_list_iter != nodes_list.end(); nodes_list_iter++) {


#ifdef OPT_MIN_DEGREE_FLAG        
        if (need_exploration == false)
            break;
#endif
        int curr_nid_in_res_graph = *nodes_list_iter;
        int curr_nseq_in_orig_graph = residual_graph->get_component_ids_of_node(curr_nid_in_res_graph)[0];
        int curr_excess = residual_graph->get_component_ids_of_node(curr_nid_in_res_graph)[3];
        float curr_excess_float = residual_graph->get_node_excess(curr_nid_in_res_graph);

        itr++;

#ifdef USE_FLOAT_EDGE_WEIGHTS_FOR_MINCUT
        if (curr_excess_float == 0.0)
            continue;
#else        
        if (curr_excess == 0)
            continue;
#endif

        if (itr > 1 && (curr_nseq_in_orig_graph == i || curr_nseq_in_orig_graph == j))
            continue;
        
        int curr_height = residual_graph->get_component_ids_of_node(curr_nid_in_res_graph)[2];

        // if outlist is not already explored add out-edges to residual graph
        if (set_seq_with_outgoing_edges_explored.find(curr_nseq_in_orig_graph) == set_seq_with_outgoing_edges_explored.end()) {
            int nid = GET_NODE_ID(original_graph, curr_nseq_in_orig_graph);

            outlist = original_graph->get_outlist(nid);

            for (vec_itr = outlist.begin(); vec_itr != outlist.end(); vec_itr++) {

                if (NOT_INTERAC_EDGE(original_graph, *vec_itr))
                    continue;

                int succ_node_id = original_graph->get_target_node(*vec_itr);
#ifdef OPT_SIMPLE_PATH_FLAG
                if (set_nodes_on_simple_path.find(succ_node_id) == set_nodes_on_simple_path.end())
                    continue;
#endif

                //cout<<nid<<"("<<*vec_itr<<")"<<succ_node_id<<endl;

                if (succ_node_id == nid) {
                    //nodes_list_iter++;
                    continue;
                }

                int succ_node_seq = GET_NODE_SEQ_NUM(original_graph, succ_node_id);

                bool create_new_edge = false;

                // create target node if not already created -- set height and excess to zero
                if (map_nseq_to_res_graph_nid.find(succ_node_seq) == map_nseq_to_res_graph_nid.end()) {
                    int new_nid_in_res_graph = residual_graph->create_new_node();

                    residual_graph->add_node_id(new_nid_in_res_graph);
                    add_node_id_graph_id(new_nid_in_res_graph, residual_graph->get_graph_id());

                    residual_graph->add_component_id_for_node(new_nid_in_res_graph, succ_node_seq); // nseq in original graph
                    residual_graph->add_component_id_for_node(new_nid_in_res_graph, i); // identifier for mincut call
                    residual_graph->add_component_id_for_node(new_nid_in_res_graph, 0); // height 
                    residual_graph->add_component_id_for_node(new_nid_in_res_graph, 0); // excess

                    residual_graph->set_node_excess(new_nid_in_res_graph, 0.0); // excess


                    map_nseq_to_res_graph_nid.insert(pair<int, int>(succ_node_seq, new_nid_in_res_graph));
                    nid_to_outlist_index.insert(pair<int, int>(new_nid_in_res_graph, 0));
                    if (std::find(nodes_list.begin(), nodes_list.end(), new_nid_in_res_graph) == nodes_list.end()) {
                        nodes_list.push_back(new_nid_in_res_graph);
                    }

#ifdef DEBUG_FLAG
                    debug_log << "Created new node " << new_nid_in_res_graph << " - nseq " << succ_node_seq << endl;
#endif                    

                    int new_eid_in_res_graph = residual_graph->create_new_edge();
                    residual_graph->add_edge_id(new_eid_in_res_graph);
                    add_edge_id_graph_id(new_eid_in_res_graph, residual_graph->get_graph_id());
                    residual_graph->add_source_node(new_eid_in_res_graph, curr_nid_in_res_graph);
                    residual_graph->add_target_node(new_eid_in_res_graph, new_nid_in_res_graph);
                    residual_graph->add_edge_to_outlist_of_node(curr_nid_in_res_graph, new_eid_in_res_graph);
                    residual_graph->add_edge_to_inlist_of_node(new_nid_in_res_graph, new_eid_in_res_graph);
                    residual_graph->set_other_value1_in_edge(new_eid_in_res_graph, i); // identifier of mincut call
                    residual_graph->set_other_value2_in_edge(new_eid_in_res_graph, 1); // capacity 
                    
                    residual_graph->set_edge_capacity(new_eid_in_res_graph, 1.0); // capacity
                   
                    residual_graph->set_other_value4_in_edge(new_eid_in_res_graph, *vec_itr); // eid in original graph
                    residual_graph->add_edge_type(new_eid_in_res_graph, "original");

                    // reverse edge
                    int rev_eid_in_res_graph = residual_graph->create_new_edge();
                    residual_graph->add_edge_id(rev_eid_in_res_graph);
                    add_edge_id_graph_id(rev_eid_in_res_graph, residual_graph->get_graph_id());
                    residual_graph->add_target_node(rev_eid_in_res_graph, curr_nid_in_res_graph);
                    residual_graph->add_source_node(rev_eid_in_res_graph, new_nid_in_res_graph);
                    residual_graph->add_edge_to_inlist_of_node(curr_nid_in_res_graph, rev_eid_in_res_graph);
                    residual_graph->add_edge_to_outlist_of_node(new_nid_in_res_graph, rev_eid_in_res_graph);
                    residual_graph->set_other_value1_in_edge(rev_eid_in_res_graph, i); // identifier of mincut call

                    int rev_eid_in_orig_graph = -1;
                    bool orig_edge = false;
                    vector<int> outlist2 = original_graph->get_outlist(succ_node_id);
                    for (vector<int>::iterator out_itr = outlist2.begin(); out_itr != outlist2.end(); out_itr++) {
                        if (NOT_INTERAC_EDGE(original_graph, *out_itr))
                            continue;
                        if (original_graph->get_target_node(*out_itr) == nid) {
                            orig_edge = true;
                            rev_eid_in_orig_graph = *out_itr;
                            break;
                        }

                    }

                    if (orig_edge) {
                        residual_graph->set_other_value2_in_edge(rev_eid_in_res_graph, 1); // capacity
                        residual_graph->add_edge_type(rev_eid_in_res_graph, "original");

                    } else {
                        residual_graph->set_other_value2_in_edge(rev_eid_in_res_graph, 0); // capacity
                        residual_graph->add_edge_type(rev_eid_in_res_graph, "not_original");

                    }
                    residual_graph->set_other_value3_in_edge(rev_eid_in_res_graph, new_eid_in_res_graph); // eid of paired reverse edge
                    residual_graph->set_other_value3_in_edge(new_eid_in_res_graph, rev_eid_in_res_graph); // eid of paired reverse edge
                    residual_graph->set_other_value4_in_edge(rev_eid_in_res_graph, rev_eid_in_orig_graph); // eid in original graph

                    
                }                    // target node is already created -- update height and excess to zero for i-th iteration of mincut
                else {
                    int succ_nid_in_res_graph = map_nseq_to_res_graph_nid[succ_node_seq];
                    assert(succ_nid_in_res_graph != curr_nid_in_res_graph);

                    if (residual_graph->get_component_ids_of_node(succ_nid_in_res_graph)[1] != i) {

                        residual_graph->update_component_of_node_at_index(succ_nid_in_res_graph, 1, i); // updating identifier of mincut call
                        residual_graph->update_component_of_node_at_index(succ_nid_in_res_graph, 2, 0); // updating height
                        residual_graph->update_component_of_node_at_index(succ_nid_in_res_graph, 3, 0); // updating excess
                        
                        residual_graph->set_node_excess(succ_nid_in_res_graph, 0.0); // updating excess
                    }
                    //need optimization -- matrix is needed. edge_exist[curr_node_id][succ_node_id]  
                    int res_eid;
                    bool res_edge = false;
                    vector<int> outlist3 = residual_graph->get_outlist(curr_nid_in_res_graph);
                    for (vector<int>::iterator out_itr = outlist3.begin(); out_itr != outlist3.end(); out_itr++) {
                        res_eid = *out_itr;

                        if (residual_graph->get_target_node(res_eid) == succ_nid_in_res_graph) {
                            res_edge = true;
                            break;
                        }

                    }

                    if (res_edge) {
                        //    if (edge_exist[curr_nseq_in_orig_graph][succ_node_seq]) {
                        //        int res_eid;
                        //        stringstream ss;
                        //        ss << curr_nid_in_res_graph << ":" << succ_nid_in_res_graph;
                        //        res_eid = map_src_tgt_to_eid[ss.str()];
                        if (residual_graph->get_other_value1_in_edge(res_eid) != i) {
                            residual_graph->set_other_value1_in_edge(res_eid, i); // identifier of mincut call
                            assert(residual_graph->get_edge_type(res_eid) == "original");
                            residual_graph->set_other_value2_in_edge(res_eid, 1); // capacity
                            residual_graph->set_edge_capacity(res_eid, 1.0); // capacity
                        }
                        int rev_res_eid = residual_graph->get_other_value3_in_edge(res_eid); // eid of paired reverse edge
                        if (residual_graph->get_other_value1_in_edge(rev_res_eid) != i) {
                            residual_graph->set_other_value1_in_edge(rev_res_eid, i); // identifier of mincut call
                            if (residual_graph->get_edge_type(rev_res_eid) == "original") {
                                residual_graph->set_other_value2_in_edge(rev_res_eid, 1); // capacity
                                residual_graph->set_edge_capacity(res_eid, 1.0); // capacity
                            } else {
                                residual_graph->set_other_value2_in_edge(rev_res_eid, 0); // capacity
                                residual_graph->set_edge_capacity(res_eid, 0.0); // capacity
                            }
                        }
                    } else {
                        int new_eid_in_res_graph = residual_graph->create_new_edge();
                        residual_graph->add_edge_id(new_eid_in_res_graph);
                        add_edge_id_graph_id(new_eid_in_res_graph, residual_graph->get_graph_id());
                        residual_graph->add_source_node(new_eid_in_res_graph, curr_nid_in_res_graph);
                        residual_graph->add_target_node(new_eid_in_res_graph, succ_nid_in_res_graph);
                        residual_graph->add_edge_to_outlist_of_node(curr_nid_in_res_graph, new_eid_in_res_graph);
                        residual_graph->add_edge_to_inlist_of_node(succ_nid_in_res_graph, new_eid_in_res_graph);
                        residual_graph->set_other_value1_in_edge(new_eid_in_res_graph, i); // identifier of mincut call
                        residual_graph->set_other_value2_in_edge(new_eid_in_res_graph, 1); // capacity
                        residual_graph->set_edge_capacity(new_eid_in_res_graph, 1.0); // capacity
                        residual_graph->set_other_value4_in_edge(new_eid_in_res_graph, *vec_itr); // eid in original graph
                        residual_graph->add_edge_type(new_eid_in_res_graph, "original");

                        // reverse edge
                        int rev_eid_in_res_graph = residual_graph->create_new_edge();
                        residual_graph->add_edge_id(rev_eid_in_res_graph);
                        add_edge_id_graph_id(rev_eid_in_res_graph, residual_graph->get_graph_id());
                        residual_graph->add_target_node(rev_eid_in_res_graph, curr_nid_in_res_graph);
                        residual_graph->add_source_node(rev_eid_in_res_graph, succ_nid_in_res_graph);
                        residual_graph->add_edge_to_inlist_of_node(curr_nid_in_res_graph, rev_eid_in_res_graph);
                        residual_graph->add_edge_to_outlist_of_node(succ_nid_in_res_graph, rev_eid_in_res_graph);
                        residual_graph->set_other_value1_in_edge(rev_eid_in_res_graph, i); // identifier of mincut call

                        int rev_eid_in_orig_graph = -1;
                        bool orig_edge = false;
                        vector<int> outlist2 = original_graph->get_outlist(succ_node_id);
                        for (vector<int>::iterator out_itr = outlist2.begin(); out_itr != outlist2.end(); out_itr++) {
                            if (NOT_INTERAC_EDGE(original_graph, *out_itr))
                                continue;
                            if (original_graph->get_target_node(*out_itr) == nid) {
                                rev_eid_in_orig_graph = *out_itr;
                                orig_edge = true;
                                break;
                            }

                        }

                        if (orig_edge) {
                            residual_graph->set_other_value2_in_edge(rev_eid_in_res_graph, 1); // capacity
                            residual_graph->set_edge_capacity(rev_eid_in_res_graph, 1.0); // capacity
                            
                            residual_graph->add_edge_type(rev_eid_in_res_graph, "original");
                        } else {
                            residual_graph->set_other_value2_in_edge(rev_eid_in_res_graph, 0); // capacity
                            residual_graph->set_edge_capacity(rev_eid_in_res_graph, 0.0); // capacity
                            residual_graph->add_edge_type(rev_eid_in_res_graph, "not_original");
                        }
                        residual_graph->set_other_value3_in_edge(rev_eid_in_res_graph, new_eid_in_res_graph); // eid of paired reverse edge
                        residual_graph->set_other_value3_in_edge(new_eid_in_res_graph, rev_eid_in_res_graph); // eid of paired reverse edge
                        residual_graph->set_other_value4_in_edge(rev_eid_in_res_graph, rev_eid_in_orig_graph); // eid in original graph

                        

                    }
                }
            }

            set_seq_with_outgoing_edges_explored.insert(curr_nseq_in_orig_graph);


        }


        set<int> set_eids_to_tgt_nodes_with_min_height;
        int min_height_tgt_node_in_res_graph;
        int cum_flow_thru_edges_to_min_height_neighbr;


        int old_height = residual_graph->get_component_ids_of_node(curr_nid_in_res_graph)[2];


        // reset height, excess, capacities in residual graph for the current mincut call
        vector<int> outlist5 = residual_graph->get_outlist(curr_nid_in_res_graph);
        vector<int>::iterator out_itr;
        for (vector<int>::iterator out_itr = outlist5.begin(); out_itr != outlist5.end(); out_itr++) {

            int res_eid = *out_itr;
            int res_eid_tgt = residual_graph->get_target_node(res_eid);

#ifdef OPT_SIMPLE_PATH_FLAG
            int tgt_nid_in_orig_graph = GET_NODE_ID(original_graph, residual_graph->get_component_ids_of_node(res_eid_tgt)[0]);
            if (set_nodes_on_simple_path.find(tgt_nid_in_orig_graph) == set_nodes_on_simple_path.end())
                continue;
#endif            

            if (residual_graph->get_other_value1_in_edge(res_eid) != i) { //edge created in a previous mincut call

                if (residual_graph->get_component_ids_of_node(res_eid_tgt)[1] != i) {

                    residual_graph->update_component_of_node_at_index(res_eid_tgt, 1, i); // updating identifier of mincut call
                    residual_graph->update_component_of_node_at_index(res_eid_tgt, 2, 0); // updating height
                    residual_graph->update_component_of_node_at_index(res_eid_tgt, 3, 0); // updating excess
                    
                    residual_graph->set_node_excess(res_eid_tgt, 0.0); // updating excess

                }
                residual_graph->set_other_value1_in_edge(res_eid, i);
                if (residual_graph->get_edge_type(res_eid) == "original") {
                    residual_graph->set_other_value2_in_edge(res_eid, 1); // capacity
                    residual_graph->set_edge_capacity(res_eid, 1.0); // capacity
                } else {
                    residual_graph->set_other_value2_in_edge(res_eid, 0); // capacity
                    residual_graph->set_edge_capacity(res_eid, 0.0); // capacity
                }

                // since edge with id res_eid was created in a prev mincut call,
                // then the corresponding rev edge with id rev_res_eid 
                // should also have been created in the prev mincut call
                int rev_res_eid = residual_graph->get_other_value3_in_edge(res_eid);
                assert(residual_graph->get_other_value1_in_edge(rev_res_eid) != i);

                residual_graph->set_other_value1_in_edge(rev_res_eid, i);
                if (residual_graph->get_edge_type(rev_res_eid) == "original") {
                    residual_graph->set_other_value2_in_edge(rev_res_eid, 1); // capacity
                    residual_graph->set_edge_capacity(rev_res_eid, 1.0); // capacity
                } else {
                    residual_graph->set_other_value2_in_edge(rev_res_eid, 0); // capacity
                    residual_graph->set_edge_capacity(rev_res_eid, 0.0); // capacity
                }
            }
        }
#ifdef DEBUG_FLAG
        vector<int> res_eids = residual_graph->get_edge_ids();
        for (auto e = res_eids.begin(); e != res_eids.end(); e++) {
            debug_log << residual_graph->get_source_node(*e) << "-" <<  residual_graph->get_target_node(*e) << ": " << residual_graph->get_other_value2_in_edge(*e) << endl;
        }    
        debug_log << endl;
#endif
        // discharge begins
        int count = 0;
        
#ifdef USE_FLOAT_EDGE_WEIGHTS_FOR_MINCUT
        while (curr_excess_float > 0.0) {
#else
        while (curr_excess > 0) {
#endif

            if (residual_graph->get_component_ids_of_node(curr_nid_in_res_graph)[0] == j) {
                //nodes_list_iter++;
                break;
            }
            int curr_outlist_index = nid_to_outlist_index[curr_nid_in_res_graph];

            if (curr_outlist_index == (outlist5.size())) {
                if (residual_graph->get_component_ids_of_node(curr_nid_in_res_graph)[0] == i) {
                    //nodes_list_iter++;
                    break;
                }

#ifdef OPT_GAP_HEUR_FLAG               
                // Gap heuristic (source: https://github.com/jaehyunp/stanfordacm/blob/master/code/PushRelabel.cc)
                if (count_height[curr_height] == 1) {

                    int height_v;
                    cout << "+++node = " << curr_nid_in_res_graph << "(" << curr_nseq_in_orig_graph << ")" << "height = " << curr_height << endl;
                    vector<int> res_nids = residual_graph->get_node_ids();
                    int cntr = 0;
                    int sze = res_nids.size();
                    for (vector<int>::iterator iter = res_nids.begin(); iter != res_nids.end(); iter++) {
                        //for (int v = 0; v <N; v++) {
                        //if (map_nseq_to_res_graph_nid.find(v) != map_nseq_to_res_graph_nid.end()){
                        int v_in_res = *iter;
                        //int v_in_res  = map_nseq_to_res_graph_nid[v];
                        height_v = residual_graph->get_component_ids_of_node(v_in_res)[2];
                        if (height_v < curr_height || residual_graph->get_component_ids_of_node(v_in_res)[1] != i)
                            continue;

                        count_height[height_v]--;
                        height_v = max(height_v, N + 1);
                        residual_graph->update_component_of_node_at_index(v_in_res, 2, height_v); //update height
                        count_height[height_v]++;
                        //}
                    }
                    /*if(curr_nid_in_res_graph == 439){
                      cntr++;
                      cout<<height_v<<"("<<cntr<<" "<<sze<<")";
                      }*/

                    //                        //if (height_v >= N) {
                    //                        if (height_v >= residual_graph->get_node_ids().size()) {  // -- CHECK
                    //                            set_s.insert(curr_nseq_in_orig_graph);
                    //                            
                    //                        }
                } else {
#endif
                    // relabel

                    int min_neighbr_height = inf;
                    int neighbr_height;
                    for (out_itr = outlist5.begin(); out_itr != outlist5.end(); out_itr++) {
                        int tgt_node = residual_graph->get_target_node(*out_itr);
                        int edge_cap = residual_graph->get_other_value2_in_edge(*out_itr);
                        float edge_cap_float = residual_graph->get_edge_capacity(*out_itr);
                        
#ifdef OPT_SIMPLE_PATH_FLAG
                        int tgt_nid_in_orig_graph = GET_NODE_ID(original_graph, residual_graph->get_component_ids_of_node(tgt_node)[0]);
                        if (set_nodes_on_simple_path.find(tgt_nid_in_orig_graph) == set_nodes_on_simple_path.end())
                            continue;
#endif            

                        neighbr_height = residual_graph->get_component_ids_of_node(tgt_node)[2];
#ifdef USE_FLOAT_EDGE_WEIGHTS_FOR_MINCUT
                        if ((neighbr_height < min_neighbr_height) && edge_cap_float > 0.0) {
#else                      
                        if ((neighbr_height < min_neighbr_height) && edge_cap > 0) {
#endif
                            min_neighbr_height = neighbr_height;
                        }

                    }

                        
#ifdef OPT_GAP_HEUR_FLAG
                    count_height[curr_height]--;
#endif
                    
                    residual_graph->update_component_of_node_at_index(curr_nid_in_res_graph, 2, min_neighbr_height + 1);

                    curr_height = min_neighbr_height + 1;
                    //                  if (i == 1)
                    //                    cout << "height increased " << curr_nseq_in_orig_graph << ": " << curr_height << endl;
                    relabel_count++;
                    //                  if (curr_height >= num_of_nodes) {
                    //                  //if (curr_height >= residual_graph->get_node_ids().size()) { // -- CHECK
                    //                    set_s.insert(residual_graph->get_component_ids_of_node(curr_nid_in_res_graph)[0]);
                    //                    //cout << "inserting " << residual_graph->get_component_ids_of_node(curr_nid_in_res_graph)[0] << endl;
                    //                    
                    //                  }
#ifdef OPT_GAP_HEUR_FLAG                  
                    count_height[curr_height]++;
                }
#endif  

                nid_to_outlist_index[curr_nid_in_res_graph] = 0;
            } else {

                int curr_outlist_edge = outlist5[curr_outlist_index];
                int curr_outlist_edge_capacity = residual_graph->get_other_value2_in_edge(curr_outlist_edge);
                float curr_outlist_edge_capacity_float = residual_graph->get_edge_capacity(curr_outlist_edge);

                int curr_node_height = residual_graph->get_component_ids_of_node(curr_nid_in_res_graph)[2];
                int curr_tgt_node_height = residual_graph->get_component_ids_of_node(residual_graph->get_target_node(curr_outlist_edge))[2];

                
#ifdef USE_FLOAT_EDGE_WEIGHTS_FOR_MINCUT
                if ((curr_outlist_edge_capacity_float > 0.0) && ((map_nseq_to_res_graph_nid[i] == curr_nid_in_res_graph) || (curr_node_height == curr_tgt_node_height + 1))) {
#else
                if ((curr_outlist_edge_capacity > 0) && ((map_nseq_to_res_graph_nid[i] == curr_nid_in_res_graph) || (curr_node_height == curr_tgt_node_height + 1))) {
#endif

                    // push
                    int tgt_node_in_res_graph = residual_graph->get_target_node(curr_outlist_edge);
                    int tgt_nseq_in_orig_graph = residual_graph->get_component_ids_of_node(tgt_node_in_res_graph)[0];
                    
                    int curr_edge_capacity = residual_graph->get_other_value2_in_edge(curr_outlist_edge);
                    // update flow
                    int flow = (curr_excess < curr_edge_capacity) ? curr_excess : curr_edge_capacity;
                    residual_graph->update_component_of_node_at_index(curr_nid_in_res_graph, 3, curr_excess - flow);
                    int tgt_excess = residual_graph->get_component_ids_of_node(tgt_node_in_res_graph)[3];
                    residual_graph->update_component_of_node_at_index(tgt_node_in_res_graph, 3, tgt_excess + flow);
                    
                    // update float flow
                    float curr_edge_capacity_float = residual_graph->get_edge_capacity(curr_outlist_edge);
                    // update flow
                    float flow_float = (curr_excess_float < curr_edge_capacity_float) ? curr_excess_float : curr_edge_capacity_float;
                    residual_graph->set_node_excess(curr_nid_in_res_graph, curr_excess_float - flow_float);
                    float tgt_excess_float = residual_graph->get_node_excess(tgt_node_in_res_graph);
                    residual_graph->set_node_excess(tgt_node_in_res_graph, tgt_excess_float + flow_float);
                    


                    if ((tgt_nseq_in_orig_graph != i) && (tgt_nseq_in_orig_graph != j)) {


                        if (std::find(nodes_list.begin(), nodes_list.end(), tgt_node_in_res_graph) == nodes_list.end()) {
                            nodes_list.push_back(tgt_node_in_res_graph);
                        }

                    }

                    // update capacity
                    residual_graph->set_other_value2_in_edge(curr_outlist_edge, curr_edge_capacity - flow);
                    int rev_edge_id = residual_graph->get_other_value3_in_edge(curr_outlist_edge);
                    int rev_edge_capacity = residual_graph->get_other_value2_in_edge(rev_edge_id);
                    residual_graph->set_other_value2_in_edge(rev_edge_id, rev_edge_capacity + flow);
                    
                    curr_excess = curr_excess - flow;
                    
                    // update capacity for float
                    residual_graph->set_edge_capacity(curr_outlist_edge, curr_edge_capacity_float - flow_float);
                    float rev_edge_capacity_float = residual_graph->get_edge_capacity(rev_edge_id);
                    residual_graph->set_edge_capacity(rev_edge_id, rev_edge_capacity_float + flow_float);

                    curr_excess_float = curr_excess_float - flow_float;
               
                    


                    
                    
                    
#ifdef OPT_MIN_DEGREE_FLAG                    
                    //anjan -- optimization if maxflow(s,t) == min(|source_outlist|, |sink_inlist|)
                    if (tgt_nseq_in_orig_graph == j) {
                        ++sink_sat;
                    }

                    if (sink_sat == min(sink_in, src_out)) {
                        need_exploration = false;
                        break;
                    }
#endif                    

                } else {
                    nid_to_outlist_index[curr_nid_in_res_graph] = curr_outlist_index + 1;
                }
            }


            count++;
        }
        //cout << "loop count = " << count << endl;
        // discharge ends

        // if node's height is increased, move node to front of nodes_list
        if (curr_height > old_height) {

            list<int>::iterator element = nodes_list_iter;
            if (element != nodes_list.begin()) {
                nodes_list.splice(nodes_list.begin(), nodes_list, element, std::next(element));

            }

        }

        //        if (i == 1) {
        //        cout << "\nNodes list ";
        //        for (list<int>::iterator it = nodes_list.begin(); it != nodes_list.end(); it++) {
        //            cout << residual_graph->get_component_ids_of_node(*it)[0] << " ";
        //        }
        //        cout << endl;
        //        }

        //nodes_list_iter++;

    }

    set<int> set_nodes_frwd_reachable_from_i;
    set<int> set_nodes_bkwd_reachable_from_j;
    set<int> set_frwd_edges_from_i_with_zero_capacity;
    set<int> set_bkwd_edges_from_j_with_zero_capacity;

    set_nodes_frwd_reachable_from_i.insert(i);
    set_nodes_bkwd_reachable_from_j.insert(j);
#ifdef OPT_MIN_DEGREE_FLAG    
    if (need_exploration) {
#endif    
        //set<int> set_t;
        //	set_difference(set_seq_with_outgoing_edges_explored.begin(), set_seq_with_outgoing_edges_explored.end(), 
        //			set_s.begin(), set_s.end(), inserter(set_t, set_t.begin()));




        //	set<int> set_nodes_frwd_reachable_from_i;
        //	set<int> set_nodes_bkwd_reachable_from_j;
        //	set<int> set_frwd_edges_from_i_with_zero_capacity;
        //	set<int> set_bkwd_edges_from_j_with_zero_capacity;

        set<int> visited;
        list<int> bfs_queue;

        // find forward reachable nodes and edges from i
        bfs_queue.push_back(i);
        //bfs_queue.push_back(map_nseq_to_res_graph_nid[i]);

        while (!bfs_queue.empty()) {

            int curr_node = bfs_queue.front();

            bfs_queue.pop_front();

            if (visited.find(curr_node) == visited.end()) {
                set_nodes_frwd_reachable_from_i.insert(curr_node); // takes node seq num
                //cout << "frwd rchble from i " << curr_node << endl;
                //if (curr_node > i){
                set_s.insert(curr_node); // takes node seq num
                src_side_nodes[curr_node] = 1;
                //}
                visited.insert(curr_node);
                // traverse outlist
                vector<int> outlist_of_i_side_node = residual_graph->get_outlist(map_nseq_to_res_graph_nid[curr_node]);
                for (vector<int>::iterator outlist_of_i_itr = outlist_of_i_side_node.begin(); outlist_of_i_itr != outlist_of_i_side_node.end(); outlist_of_i_itr++) {
                    int curr_edge = (*outlist_of_i_itr);

#ifdef USE_FLOAT_EDGE_WEIGHTS_FOR_MINCUT                    
                    if (residual_graph->get_edge_capacity(curr_edge) == 0.0) { // stop at zero capacity edge
#else
                    if (residual_graph->get_other_value2_in_edge(curr_edge) == 0) { // stop at zero capacity edge
#endif
                        set_frwd_edges_from_i_with_zero_capacity.insert(curr_edge);


                    } else {
                        int target_nid = residual_graph->get_target_node(curr_edge);
                        bfs_queue.push_back(residual_graph->get_component_ids_of_node(target_nid)[0]);

                    }

                }
            }

        }

        assert(bfs_queue.empty());
        visited.clear();

        // find backward reachable nodes and edges from j
        bfs_queue.push_back(j);
        
        while (!bfs_queue.empty()) {
                int curr_node = bfs_queue.front();
                bfs_queue.pop_front();

                if (visited.find(curr_node) == visited.end()) {
                        set_nodes_bkwd_reachable_from_j.insert(curr_node); // takes node seq num
                        visited.insert(curr_node);
                
                        // traverse inlist
                        vector<int> inlist_of_j_side_node = residual_graph->get_inlist(map_nseq_to_res_graph_nid[curr_node]);
                        for (vector<int>::iterator inlist_of_j_itr = inlist_of_j_side_node.begin(); inlist_of_j_itr != inlist_of_j_side_node.end(); inlist_of_j_itr++) {
                            int curr_edge = (*inlist_of_j_itr);
                            if (residual_graph->get_edge_type(curr_edge) == "original") {
                                
                            // stop at zero capacity edge
#ifdef USE_FLOAT_EDGE_WEIGHTS_FOR_MINCUT 
                                if ((residual_graph->get_edge_capacity(curr_edge) == 0.0) && (set_frwd_edges_from_i_with_zero_capacity.find(curr_edge) != set_frwd_edges_from_i_with_zero_capacity.end()))  
#else                        
                                if ((residual_graph->get_other_value2_in_edge(curr_edge) == 0) && (set_frwd_edges_from_i_with_zero_capacity.find(curr_edge) != set_frwd_edges_from_i_with_zero_capacity.end()))
#endif
                                {    
                                    set_bkwd_edges_from_j_with_zero_capacity.insert(curr_edge);
                            
                                } 
                        
                                else {
                            
                        
#ifdef USE_FLOAT_EDGE_WEIGHTS_FOR_MINCUT 
                                if (residual_graph->get_edge_capacity(curr_edge) == 0.0)  
#else                        
                                if (residual_graph->get_other_value2_in_edge(curr_edge) == 0)
#endif                            
                                {   
                                        set_bkwd_edges_from_j_with_zero_capacity.insert(curr_edge);

                                        int source_nid = residual_graph->get_source_node(curr_edge);
                                        bfs_queue.push_back(residual_graph->get_component_ids_of_node(source_nid)[0]);
                                }
                    
                                }
                            }

                        }
                        set<int> undirected_cut_edges;

                        for (set<int>::iterator set_itr2 = set_frwd_edges_from_i_with_zero_capacity.begin(); set_itr2 != set_frwd_edges_from_i_with_zero_capacity.end(); set_itr2++) {
                            int curr_fwd_edge = *set_itr2;
                            int curr_tgt = residual_graph->get_component_ids_of_node(residual_graph->get_target_node(curr_fwd_edge))[0];
                            int curr_src = residual_graph->get_component_ids_of_node(residual_graph->get_source_node(curr_fwd_edge))[0];
                            if (set_nodes_bkwd_reachable_from_j.find(curr_tgt) != set_nodes_bkwd_reachable_from_j.end()) {

                                //int curr_src_nseq_in_orig_graph = residual_graph->get_component_ids_of_node(curr_src)[0];
                                int curr_src_nseq_in_orig_graph = curr_src;
                                int curr_src_nid_in_orig_graph = GET_NODE_ID(original_graph, curr_src_nseq_in_orig_graph);
                                //int curr_tgt_nseq_in_orig_graph = residual_graph->get_component_ids_of_node(curr_tgt)[0];
                                int curr_tgt_nseq_in_orig_graph = curr_tgt;
                                int curr_tgt_nid_in_orig_graph = GET_NODE_ID(original_graph, curr_tgt_nseq_in_orig_graph);
                                set<int> all_eids_between_two_nids;
                                original_graph->get_all_eids_between_two_nodes(curr_src_nid_in_orig_graph, curr_tgt_nid_in_orig_graph, all_eids_between_two_nids);
                                for (set<int>::iterator set_itr_eids = all_eids_between_two_nids.begin(); set_itr_eids != all_eids_between_two_nids.end(); set_itr_eids++) {
                                    undirected_cut_edges.insert(*set_itr_eids);
                                }
                                all_eids_between_two_nids.clear(); // added by sukanya on 23 Jun 2017
                                original_graph->get_all_eids_between_two_nodes(curr_tgt_nid_in_orig_graph, curr_src_nid_in_orig_graph, all_eids_between_two_nids);
                                for (set<int>::iterator set_itr_eids = all_eids_between_two_nids.begin(); set_itr_eids != all_eids_between_two_nids.end(); set_itr_eids++) {
                                    undirected_cut_edges.insert(*set_itr_eids);
                                }


                            }

                        }
                        
                        

        
                        set<int>::iterator cut_edges_itr;
                        for (cut_edges_itr = undirected_cut_edges.begin(); cut_edges_itr != undirected_cut_edges.end(); cut_edges_itr++) {
                            
                            int eid_in_orig_graph = *cut_edges_itr;

                            if (!original_graph->edge_has_subtype(eid_in_orig_graph, "dummy_d_to_u")) {
                                
                                EdgeNew * chosen_edge = original_graph->get_edge_from_eid(eid_in_orig_graph);
                                cut_edges.insert(eid_in_orig_graph);
                            }
                        }
                }
                
        }


       
#ifdef DEBUG_FLAG
    debug_log << "Node sets" << " s: " << set_nodes_frwd_reachable_from_i.size() << " t: " << set_nodes_bkwd_reachable_from_j.size() << endl;
    debug_log << "cut_edges: ";
    for (set<int>::iterator set_itr2 = cut_edges.begin(); set_itr2 != cut_edges.end(); set_itr2++) {
        debug_log << *set_itr2 << " ";
    }
    debug_log << endl;

#endif     
    
    assert(residual_graph->get_edge_ids().size() <= num_of_edges);

#ifdef DEBUG_FLAG
    debug_log << "Total relabels " << relabel_count << endl;
    debug_log << endl;
#endif    
}








void GraphManagerNew::compute_weighted_min_cut_for_ghtree_relabel_to_front(GraphNew* ugraph, vector<int>& non_isolated_node_unids, int i, int j, set<int>& cut_edges, set<int>& set_s) {
    
    //cout << "Mincut " << i << endl;
    
#ifdef DEBUG_FLAG
    debug_log << "Mincut iteration " << i << endl;
    debug_log << "-------------------------------" << endl;

    debug_log << "between " << "nseq " << i << "[nid " << ugraph->get_rep_id_from_nid(GET_NODE_ID(ugraph, i)) << "] " << " and nseq " << j << "[nid " << ugraph->get_rep_id_from_nid(GET_NODE_ID(ugraph, j)) << "] " << endl;

#endif
    
    vector<int> eids = ugraph->get_edge_ids();

    static int num_of_nodes;
    static int new_gid;
    static int num_of_edges;
    static map<int, int> map_nseq_to_res_graph_nid;

    static GraphNew * residual_graph;

    int curr_height, curr_excess;
    float curr_excess_flt;
    int relabel_count = 0;

    static set<int> set_seq_with_outgoing_edges_explored;
    set<int>::iterator set_itr;

    vector<int> outlist;
    vector<int>::iterator vec_itr;

    set<int> set_t;

    // this maps store the index of the neighboring node under consideration -- used for discharge
    map<int, int> nid_to_outlist_index;
    int new_nid, itr = 0;

    int N = non_isolated_node_unids.size();
    vector<bool> src_side_nodes(N + 1, 0);
    
#ifdef OPT_GAP_HEUR_FLAG    
    vector<int> count_height(2 * N + 1);
    count_height[N] = 1;
    count_height[0] = N - 1;
#endif    
     
    
    static vector < vector<bool > > edge_exist(N + 1, vector<bool>(N + 1));
    static unordered_map<string, long int> map_src_tgt_to_eid;
    
    
    
    
    if (i == 1) {
        map_nseq_to_res_graph_nid.clear(); // static maps need clearing
        set_seq_with_outgoing_edges_explored.clear(); // for multiple mincut calls in same session   
                
        residual_graph = new GraphNew;
        num_of_nodes = non_isolated_node_unids.size();
        num_of_edges = ugraph->get_edge_ids().size();
        new_gid = ++GraphManagerNew::graph_id_count;
        residual_graph->set_graph_id(new_gid);
        add_graph(new_gid, residual_graph);
        
//        // populate adjacency matrix
//        fill_adj_matrix_for_graph(residual_graph);
        
#ifdef DEBUG_FLAG
        debug_log << "Created residual graph once. Graph id is " << new_gid << endl;
        debug_log << endl;
#endif

    }
    
    // creating the node for i      
    if (map_nseq_to_res_graph_nid.find(i) == map_nseq_to_res_graph_nid.end()) {
        new_nid = residual_graph->create_new_node();

        residual_graph->add_node_id(new_nid);
        add_node_id_graph_id(new_nid, residual_graph->get_graph_id());

        residual_graph->add_component_id_for_node(new_nid, i); // nseq in original graph
        residual_graph->add_component_id_for_node(new_nid, i); // identifier of mincut call
        residual_graph->add_component_id_for_node(new_nid, num_of_nodes); // height
        
        // initial excess
        int excess = 0;
        float excess_float = 0.0;
        vector<int> outlist_of_i = ugraph->get_outlist(GET_NODE_ID(ugraph, i));
        for (auto itr = outlist_of_i.begin(); itr != outlist_of_i.end(); itr++) {
            excess_float = excess_float + ugraph->get_edge_weight_float(*itr);
            excess = excess + ugraph->get_edge_weight(*itr);
        }
            
        residual_graph->set_node_excess(new_nid, excess_float); // excess
        residual_graph->add_component_id_for_node(new_nid, excess); // excess
        
        
        map_nseq_to_res_graph_nid.insert(pair<int, int>(i, new_nid));
        nid_to_outlist_index.insert(pair<int, int>(new_nid, 0));


#ifdef DEBUG_FLAG
        debug_log << "Created new node " << new_nid << " - nseq " << i << endl;
#endif          

    } else {
        new_nid = map_nseq_to_res_graph_nid[i];
        residual_graph->update_component_of_node_at_index(new_nid, 1, i); // updating identifier of mincut call
        residual_graph->update_component_of_node_at_index(new_nid, 2, num_of_nodes); // updating height
        
        int excess = 0;
        float excess_float = 0.0;
        vector<int> outlist_of_i = ugraph->get_outlist(GET_NODE_ID(ugraph, i));
        for (auto itr = outlist_of_i.begin(); itr != outlist_of_i.end(); itr++) {
            excess_float = excess_float + ugraph->get_edge_weight_float(*itr);
            excess = excess + ugraph->get_edge_weight(*itr);
        }
        residual_graph->update_component_of_node_at_index(new_nid, 3, excess); // updating excess
        residual_graph->set_node_excess(new_nid, excess_float); // updating excess
        
        nid_to_outlist_index.insert(pair<int, int>(new_nid, 0));
    }        
    
    set_s.insert(i);
    src_side_nodes[i] = 1;

    list<int> nodes_list;
    list<int>::iterator nodes_list_iter;

    nodes_list.push_back(new_nid);
    
    for (nodes_list_iter = nodes_list.begin(); nodes_list_iter != nodes_list.end(); nodes_list_iter++) {
        
        int curr_nid_in_res_graph = *nodes_list_iter;
        int curr_nseq_in_orig_graph = residual_graph->get_component_ids_of_node(curr_nid_in_res_graph)[0];

        int curr_excess = residual_graph->get_component_ids_of_node(curr_nid_in_res_graph)[3];
        int curr_excess_float = residual_graph->get_node_excess(curr_nid_in_res_graph);

        itr++;

        
#ifdef USE_FLOAT_EDGE_WEIGHTS_FOR_MINCUT
        if (curr_excess_float == 0.0)
            continue;
#else
        if (curr_excess == 0)
            continue;
#endif
        
        if (itr > 1 && (curr_nseq_in_orig_graph == i || curr_nseq_in_orig_graph == j))
            continue;
        
        int curr_height = residual_graph->get_component_ids_of_node(curr_nid_in_res_graph)[2];
        
        // if outlist is not already explored add out-edges to residual graph
        if (set_seq_with_outgoing_edges_explored.find(curr_nseq_in_orig_graph) == set_seq_with_outgoing_edges_explored.end()) {
            int nid = GET_NODE_ID(ugraph, curr_nseq_in_orig_graph);

            outlist = ugraph->get_outlist(nid);

            for (vec_itr = outlist.begin(); vec_itr != outlist.end(); vec_itr++) {

                if (NOT_INTERAC_EDGE(ugraph, *vec_itr))
                    continue;

                int succ_node_id = ugraph->get_target_node(*vec_itr);

                if (succ_node_id == nid) {
                    continue;
                }

                int succ_node_seq = GET_NODE_SEQ_NUM(ugraph, succ_node_id);

                bool create_new_edge = false;

                // create target node if not already created -- set height and excess to zero
                if (map_nseq_to_res_graph_nid.find(succ_node_seq) == map_nseq_to_res_graph_nid.end()) {
                    int new_nid_in_res_graph = residual_graph->create_new_node();

                    residual_graph->add_node_id(new_nid_in_res_graph);
                    add_node_id_graph_id(new_nid_in_res_graph, residual_graph->get_graph_id());

                    residual_graph->add_component_id_for_node(new_nid_in_res_graph, succ_node_seq); // nseq in original graph
                    residual_graph->add_component_id_for_node(new_nid_in_res_graph, i); // identifier for mincut call
                    residual_graph->add_component_id_for_node(new_nid_in_res_graph, 0); // height
                    residual_graph->add_component_id_for_node(new_nid_in_res_graph, 0); // excess
                    residual_graph->set_node_excess(new_nid_in_res_graph, 0.0); // excess

                    map_nseq_to_res_graph_nid.insert(pair<int, int>(succ_node_seq, new_nid_in_res_graph));
                    nid_to_outlist_index.insert(pair<int, int>(new_nid_in_res_graph, 0));
                    if (std::find(nodes_list.begin(), nodes_list.end(), new_nid_in_res_graph) == nodes_list.end()) {
                        nodes_list.push_back(new_nid_in_res_graph);
                    }
                    
#ifdef DEBUG_FLAG
                    debug_log << "Created new node " << new_nid_in_res_graph << " - nseq " << succ_node_seq << endl;
#endif                    

                    int new_eid_in_res_graph = residual_graph->create_new_edge();
                    residual_graph->add_edge_id(new_eid_in_res_graph);
                    add_edge_id_graph_id(new_eid_in_res_graph, residual_graph->get_graph_id());
                    residual_graph->add_source_node(new_eid_in_res_graph, curr_nid_in_res_graph);
                    residual_graph->add_target_node(new_eid_in_res_graph, new_nid_in_res_graph);
                    residual_graph->add_edge_to_outlist_of_node(curr_nid_in_res_graph, new_eid_in_res_graph);
                    residual_graph->add_edge_to_inlist_of_node(new_nid_in_res_graph, new_eid_in_res_graph);
                    residual_graph->set_other_value1_in_edge(new_eid_in_res_graph, i); // identifier of mincut call
                    residual_graph->set_other_value2_in_edge(new_eid_in_res_graph, ugraph->get_edge_weight(*vec_itr)); // weighted capacity
                    residual_graph->set_edge_capacity(new_eid_in_res_graph, ugraph->get_edge_weight_float(*vec_itr)); // weighted capacity
                    residual_graph->set_other_value4_in_edge(new_eid_in_res_graph, *vec_itr); // eid in original graph
                    residual_graph->add_edge_type(new_eid_in_res_graph, "original");
                    

                    // reverse edge
                    int rev_eid_in_res_graph = residual_graph->create_new_edge();
                    residual_graph->add_edge_id(rev_eid_in_res_graph);
                    add_edge_id_graph_id(rev_eid_in_res_graph, residual_graph->get_graph_id());
                    residual_graph->add_target_node(rev_eid_in_res_graph, curr_nid_in_res_graph);
                    residual_graph->add_source_node(rev_eid_in_res_graph, new_nid_in_res_graph);
                    residual_graph->add_edge_to_inlist_of_node(curr_nid_in_res_graph, rev_eid_in_res_graph);
                    residual_graph->add_edge_to_outlist_of_node(new_nid_in_res_graph, rev_eid_in_res_graph);
                    residual_graph->set_other_value1_in_edge(rev_eid_in_res_graph, i); // identifier of mincut call
                    
                    int rev_eid_in_orig_graph = -1;
                    bool orig_edge = false;
                    vector<int> outlist2 = ugraph->get_outlist(succ_node_id);
                    for (vector<int>::iterator out_itr = outlist2.begin(); out_itr != outlist2.end(); out_itr++) {
                        if (NOT_INTERAC_EDGE(ugraph, *out_itr))
                            continue;
                        if (ugraph->get_target_node(*out_itr) == nid) {
                            orig_edge = true;
                            rev_eid_in_orig_graph = *out_itr;
                            break;
                        }

                    }
                    
                    residual_graph->set_other_value2_in_edge(rev_eid_in_res_graph, ugraph->get_edge_weight(*vec_itr)); // weighted capacity
                    residual_graph->set_edge_capacity(rev_eid_in_res_graph, ugraph->get_edge_weight_float(*vec_itr)); // weighted capacity
                    
                    residual_graph->set_other_value3_in_edge(rev_eid_in_res_graph, new_eid_in_res_graph); // eid of paired reverse edge
                    residual_graph->set_other_value3_in_edge(new_eid_in_res_graph, rev_eid_in_res_graph); // eid of paired reverse edge
                    residual_graph->set_other_value4_in_edge(rev_eid_in_res_graph, rev_eid_in_orig_graph); // eid in original graph

                                       
                } // target node is already created -- update height and excess to zero for i-th iteration of mincut
                
                else {
                    int succ_nid_in_res_graph = map_nseq_to_res_graph_nid[succ_node_seq];
                    assert(succ_nid_in_res_graph != curr_nid_in_res_graph);

                    if (residual_graph->get_component_ids_of_node(succ_nid_in_res_graph)[1] != i) {

                        residual_graph->update_component_of_node_at_index(succ_nid_in_res_graph, 1, i); // updating identifier of mincut call
                        residual_graph->update_component_of_node_at_index(succ_nid_in_res_graph, 2, 0); // updating height
                        residual_graph->update_component_of_node_at_index(succ_nid_in_res_graph, 3, 0); // updating excess
                        residual_graph->set_node_excess(succ_nid_in_res_graph, 0.0); // updating excess
                    }
                    
                    int res_eid;
                    bool res_edge = false;
                    vector<int> outlist3 = residual_graph->get_outlist(curr_nid_in_res_graph);
                    for (vector<int>::iterator out_itr = outlist3.begin(); out_itr != outlist3.end(); out_itr++) {
                        res_eid = *out_itr;

                        if (residual_graph->get_target_node(res_eid) == succ_nid_in_res_graph) {
                            res_edge = true;
                            break;
                        }

                    }

                    if (res_edge) {
                        
                        if (residual_graph->get_other_value1_in_edge(res_eid) != i) {
                            
                            residual_graph->set_other_value1_in_edge(res_eid, i); // identifier of mincut call
                            residual_graph->set_other_value2_in_edge(res_eid, ugraph->get_edge_weight(*vec_itr)); // weighted capacity
                            residual_graph->set_edge_capacity(res_eid, ugraph->get_edge_weight_float(*vec_itr)); // weighted capacity
                        }
                        int rev_res_eid = residual_graph->get_other_value3_in_edge(res_eid); // eid of paired reverse edge
                        if (residual_graph->get_other_value1_in_edge(rev_res_eid) != i) {
                            
                            residual_graph->set_other_value1_in_edge(rev_res_eid, i); // identifier of mincut call
                            residual_graph->set_other_value2_in_edge(rev_res_eid, ugraph->get_edge_weight(*vec_itr)); // weighted capacity
                            residual_graph->set_edge_capacity(rev_res_eid, ugraph->get_edge_weight_float(*vec_itr)); // weighted capacity
                        }
                    } else {
                        int new_eid_in_res_graph = residual_graph->create_new_edge();
                        residual_graph->add_edge_id(new_eid_in_res_graph);
                        add_edge_id_graph_id(new_eid_in_res_graph, residual_graph->get_graph_id());
                        residual_graph->add_source_node(new_eid_in_res_graph, curr_nid_in_res_graph);
                        residual_graph->add_target_node(new_eid_in_res_graph, succ_nid_in_res_graph);
                        residual_graph->add_edge_to_outlist_of_node(curr_nid_in_res_graph, new_eid_in_res_graph);
                        residual_graph->add_edge_to_inlist_of_node(succ_nid_in_res_graph, new_eid_in_res_graph);
                        residual_graph->set_other_value1_in_edge(new_eid_in_res_graph, i); // identifier of mincut call
                        residual_graph->set_other_value2_in_edge(new_eid_in_res_graph, ugraph->get_edge_weight(*vec_itr)); // weighted capacity
                        residual_graph->set_edge_capacity(new_eid_in_res_graph, ugraph->get_edge_weight_float(*vec_itr)); // weighted capacity
                        
                        residual_graph->set_other_value4_in_edge(new_eid_in_res_graph, *vec_itr); // eid in original graph
                        residual_graph->add_edge_type(new_eid_in_res_graph, "original");
                        
                        
                        // reverse edge
                        int rev_eid_in_res_graph = residual_graph->create_new_edge();
                        residual_graph->add_edge_id(rev_eid_in_res_graph);
                        add_edge_id_graph_id(rev_eid_in_res_graph, residual_graph->get_graph_id());
                        residual_graph->add_target_node(rev_eid_in_res_graph, curr_nid_in_res_graph);
                        residual_graph->add_source_node(rev_eid_in_res_graph, succ_nid_in_res_graph);
                        residual_graph->add_edge_to_inlist_of_node(curr_nid_in_res_graph, rev_eid_in_res_graph);
                        residual_graph->add_edge_to_outlist_of_node(succ_nid_in_res_graph, rev_eid_in_res_graph);
                        residual_graph->set_other_value1_in_edge(rev_eid_in_res_graph, i); // identifier of mincut call

                        int rev_eid_in_orig_graph = -1;
                        bool orig_edge = false;
                        vector<int> outlist2 = ugraph->get_outlist(succ_node_id);
                        for (vector<int>::iterator out_itr = outlist2.begin(); out_itr != outlist2.end(); out_itr++) {
                            if (NOT_INTERAC_EDGE(ugraph, *out_itr))
                                continue;
                            if (ugraph->get_target_node(*out_itr) == nid) {
                                rev_eid_in_orig_graph = *out_itr;
                                orig_edge = true;
                                break;
                            }

                        }

                        residual_graph->set_other_value2_in_edge(rev_eid_in_res_graph, ugraph->get_edge_weight(*vec_itr)); // weighted capacity
                        residual_graph->set_edge_capacity(rev_eid_in_res_graph, ugraph->get_edge_weight_float(*vec_itr)); // weighted capacity float
                        residual_graph->set_other_value3_in_edge(rev_eid_in_res_graph, new_eid_in_res_graph); // eid of paired reverse edge
                        residual_graph->set_other_value3_in_edge(new_eid_in_res_graph, rev_eid_in_res_graph); // eid of paired reverse edge
                        residual_graph->set_other_value4_in_edge(rev_eid_in_res_graph, rev_eid_in_orig_graph); // eid in original graph


                    }
                }
            }

            set_seq_with_outgoing_edges_explored.insert(curr_nseq_in_orig_graph);


        }

        set<int> set_eids_to_tgt_nodes_with_min_height;
        int min_height_tgt_node_in_res_graph;
        int cum_flow_thru_edges_to_min_height_neighbr;


        int old_height = residual_graph->get_component_ids_of_node(curr_nid_in_res_graph)[2];


        // reset height, excess, capacities in residual graph for the current mincut call
        vector<int> outlist5 = residual_graph->get_outlist(curr_nid_in_res_graph);
        vector<int>::iterator out_itr;      
                
        for (vector<int>::iterator out_itr = outlist5.begin(); out_itr != outlist5.end(); out_itr++) {

            int res_eid = *out_itr;
            int res_eid_tgt = residual_graph->get_target_node(res_eid);

            if (residual_graph->get_other_value1_in_edge(res_eid) != i) { //edge created in a previous mincut call

                if (residual_graph->get_component_ids_of_node(res_eid_tgt)[1] != i) {

                    residual_graph->update_component_of_node_at_index(res_eid_tgt, 1, i); // updating identifier of mincut call
                    residual_graph->update_component_of_node_at_index(res_eid_tgt, 2, 0); // updating height
                    residual_graph->update_component_of_node_at_index(res_eid_tgt, 3, 0); // updating excess
                    residual_graph->set_node_excess(res_eid_tgt, 0.0); // updating excess

                }
                residual_graph->set_other_value1_in_edge(res_eid, i);
                residual_graph->set_other_value4_in_edge(res_eid, residual_graph->get_other_value4_in_edge(*out_itr)); // eid in original graph
                residual_graph->set_other_value2_in_edge(res_eid, ugraph->get_edge_weight(residual_graph->get_other_value4_in_edge(res_eid))); // weighted capacity
                residual_graph->set_edge_capacity(res_eid, ugraph->get_edge_weight_float(residual_graph->get_other_value4_in_edge(res_eid))); // weighted capacity float    
                

                // since edge with id res_eid was created in a prev mincut call,
                // then the corresponding rev edge with id rev_res_eid 
                // should also have been created in the prev mincut call
                int rev_res_eid = residual_graph->get_other_value3_in_edge(res_eid);
                assert(residual_graph->get_other_value1_in_edge(rev_res_eid) != i);

                residual_graph->set_other_value1_in_edge(rev_res_eid, i);                
                residual_graph->set_other_value4_in_edge(rev_res_eid, residual_graph->get_other_value4_in_edge(rev_res_eid));
                residual_graph->set_other_value2_in_edge(rev_res_eid, ugraph->get_edge_weight(residual_graph->get_other_value4_in_edge(rev_res_eid))); // weighted capacity
                residual_graph->set_edge_capacity(rev_res_eid, ugraph->get_edge_weight_float(residual_graph->get_other_value4_in_edge(rev_res_eid))); // weighted capacity float   
                
            }
        }
        

       
       
        // discharge begins
        int count = 0;
#ifdef USE_FLOAT_EDGE_WEIGHTS_FOR_MINCUT
        while (curr_excess_float > 0.0) {
#else     
        while (curr_excess > 0) {
#endif
           
            if (residual_graph->get_component_ids_of_node(curr_nid_in_res_graph)[0] == j) {
                break;
            }
            int curr_outlist_index = nid_to_outlist_index[curr_nid_in_res_graph];

            if (curr_outlist_index == (outlist5.size())) {
                if (residual_graph->get_component_ids_of_node(curr_nid_in_res_graph)[0] == i) {
                    break;
                }

#ifdef OPT_GAP_HEUR_FLAG               
                // Gap heuristic
                if (count_height[curr_height] == 1) {

                    int height_v;
                    //cout << "+++node = " << curr_nid_in_res_graph << "(" << curr_nseq_in_orig_graph << ")" << "height = " << curr_height << endl;
                    vector<int> res_nids = residual_graph->get_node_ids();
                    int cntr = 0;
                    int sze = res_nids.size();
                    for (vector<int>::iterator iter = res_nids.begin(); iter != res_nids.end(); iter++) {
                        
                        int v_in_res = *iter;
                        
                        height_v = residual_graph->get_component_ids_of_node(v_in_res)[2];
                        if (height_v < curr_height || residual_graph->get_component_ids_of_node(v_in_res)[1] != i)
                            continue;

                        count_height[height_v]--;
                        height_v = max(height_v, N + 1);
                        residual_graph->update_component_of_node_at_index(v_in_res, 2, height_v); //update height
                        count_height[height_v]++;
                        
                    }
                    
                } else {
#endif
                    // relabel

                    int min_neighbr_height = inf;
                    int neighbr_height;
                    for (out_itr = outlist5.begin(); out_itr != outlist5.end(); out_itr++) {
                        int tgt_node = residual_graph->get_target_node(*out_itr);
                        int edge_cap = residual_graph->get_other_value2_in_edge(*out_itr);
                        float edge_cap_float = residual_graph->get_edge_capacity(*out_itr);

                        neighbr_height = residual_graph->get_component_ids_of_node(tgt_node)[2];
#ifdef USE_FLOAT_EDGE_WEIGHTS_FOR_MINCUT
                        if ((neighbr_height < min_neighbr_height) && edge_cap_float > 0.0) {
#else     
                        if ((neighbr_height < min_neighbr_height) && edge_cap > 0) {
#endif                        
                                min_neighbr_height = neighbr_height;
                        }

                    }

#ifdef OPT_GAP_HEUR_FLAG
                    count_height[curr_height]--;
#endif

                    residual_graph->update_component_of_node_at_index(curr_nid_in_res_graph, 2, min_neighbr_height + 1);
                    curr_height = min_neighbr_height + 1;
                    
                    relabel_count++;
                    
#ifdef OPT_GAP_HEUR_FLAG                  
                    count_height[curr_height]++;
                }
#endif  

                nid_to_outlist_index[curr_nid_in_res_graph] = 0;
            } else {

                int curr_outlist_edge = outlist5[curr_outlist_index];
                int curr_outlist_edge_capacity = residual_graph->get_other_value2_in_edge(curr_outlist_edge);
                float curr_outlist_edge_capacity_float = residual_graph->get_edge_capacity(curr_outlist_edge);
                
                int curr_node_height = residual_graph->get_component_ids_of_node(curr_nid_in_res_graph)[2];
                int curr_tgt_node_height = residual_graph->get_component_ids_of_node(residual_graph->get_target_node(curr_outlist_edge))[2];
                
#ifdef USE_FLOAT_EDGE_WEIGHTS_FOR_MINCUT
                if ((curr_outlist_edge_capacity_float > 0.0) && ((map_nseq_to_res_graph_nid[i] == curr_nid_in_res_graph) || (curr_node_height == curr_tgt_node_height + 1))) {

                    // push
                    int tgt_node_in_res_graph = residual_graph->get_target_node(curr_outlist_edge);
                    int tgt_nseq_in_orig_graph = residual_graph->get_component_ids_of_node(tgt_node_in_res_graph)[0];
                    int curr_edge_capacity_float = residual_graph->get_edge_capacity(curr_outlist_edge);
                    // update flow
                    float flow_float = (curr_excess_float < curr_edge_capacity_float) ? curr_excess_float : curr_edge_capacity_float;
                    
                    residual_graph->set_node_excess(curr_nid_in_res_graph, curr_excess_float - flow_float);
                    float tgt_excess_float = residual_graph->get_node_excess(tgt_node_in_res_graph);
                    residual_graph->set_node_excess(tgt_node_in_res_graph, tgt_excess_float + flow_float);


                    if ((tgt_nseq_in_orig_graph != i) && (tgt_nseq_in_orig_graph != j)) {


                        if (std::find(nodes_list.begin(), nodes_list.end(), tgt_node_in_res_graph) == nodes_list.end()) {
                            nodes_list.push_back(tgt_node_in_res_graph);
                        }

                    }

                    // update capacity
                    residual_graph->set_edge_capacity(curr_outlist_edge, curr_edge_capacity_float - flow_float);
                    
                    int rev_edge_id = residual_graph->get_other_value3_in_edge(curr_outlist_edge);
                    float rev_edge_capacity_float = residual_graph->get_edge_capacity(rev_edge_id);
                    residual_graph->set_edge_capacity(rev_edge_id, rev_edge_capacity_float + flow_float);
                    
                    curr_excess_float = curr_excess_float - flow_float;
                   

                }
#else     
                if ((curr_outlist_edge_capacity > 0) && ((map_nseq_to_res_graph_nid[i] == curr_nid_in_res_graph) || (curr_node_height == curr_tgt_node_height + 1))) {

                    // push
                    int tgt_node_in_res_graph = residual_graph->get_target_node(curr_outlist_edge);
                    int tgt_nseq_in_orig_graph = residual_graph->get_component_ids_of_node(tgt_node_in_res_graph)[0];
                    int curr_edge_capacity = residual_graph->get_other_value2_in_edge(curr_outlist_edge);
                    // update flow
                    int flow = (curr_excess < curr_edge_capacity) ? curr_excess : curr_edge_capacity;
                    
                    residual_graph->update_component_of_node_at_index(curr_nid_in_res_graph, 3, curr_excess - flow);
                    int tgt_excess = residual_graph->get_component_ids_of_node(tgt_node_in_res_graph)[3];
                    residual_graph->update_component_of_node_at_index(tgt_node_in_res_graph, 3, tgt_excess + flow);


                    if ((tgt_nseq_in_orig_graph != i) && (tgt_nseq_in_orig_graph != j)) {


                        if (std::find(nodes_list.begin(), nodes_list.end(), tgt_node_in_res_graph) == nodes_list.end()) {
                            nodes_list.push_back(tgt_node_in_res_graph);
                        }

                    }

                    // update capacity
                    residual_graph->set_other_value2_in_edge(curr_outlist_edge, curr_edge_capacity - flow);
                    
                    int rev_edge_id = residual_graph->get_other_value3_in_edge(curr_outlist_edge);
                    int rev_edge_capacity = residual_graph->get_other_value2_in_edge(rev_edge_id);
                    residual_graph->set_other_value2_in_edge(rev_edge_id, rev_edge_capacity + flow);
                    
                    curr_excess = curr_excess - flow;
                   

                }
#endif
                else {
                    nid_to_outlist_index[curr_nid_in_res_graph] = curr_outlist_index + 1;
                }
            }


            count++;
        }
        
        // discharge ends

        // if node's height is increased, move node to front of nodes_list
        if (curr_height > old_height) {

            list<int>::iterator element = nodes_list_iter;
            if (element != nodes_list.begin()) {
                nodes_list.splice(nodes_list.begin(), nodes_list, element, std::next(element));

            }

        }  
    }
    
    
    set<int> set_nodes_frwd_reachable_from_i;
    set<int> set_nodes_bkwd_reachable_from_j;
    set<int> set_frwd_edges_from_i_with_zero_capacity;
    set<int> set_bkwd_edges_from_j_with_zero_capacity;

    set_nodes_frwd_reachable_from_i.insert(i);
    set_nodes_bkwd_reachable_from_j.insert(j);
      
    set<int> visited;
    list<int> bfs_queue;

    // find forward reachable nodes and edges from i
    bfs_queue.push_back(i);
    

    while (!bfs_queue.empty()) {

        int curr_node = bfs_queue.front();

        bfs_queue.pop_front();

        if (visited.find(curr_node) == visited.end()) {
            set_nodes_frwd_reachable_from_i.insert(curr_node); // takes node seq num
            
            set_s.insert(curr_node); // takes node seq num
            src_side_nodes[curr_node] = 1;
            
            visited.insert(curr_node);
            // traverse outlist
            vector<int> outlist_of_i_side_node = residual_graph->get_outlist(map_nseq_to_res_graph_nid[curr_node]);
            for (vector<int>::iterator outlist_of_i_itr = outlist_of_i_side_node.begin(); outlist_of_i_itr != outlist_of_i_side_node.end(); outlist_of_i_itr++) {
                int curr_edge = (*outlist_of_i_itr);

#ifdef USE_FLOAT_EDGE_WEIGHTS_FOR_MINCUT
                if (residual_graph->get_edge_capacity(curr_edge) == 0.0) { // stop at zero capacity edge
#else
                
                if (residual_graph->get_other_value2_in_edge(curr_edge) == 0) { // stop at zero capacity edge
#endif
                    set_frwd_edges_from_i_with_zero_capacity.insert(curr_edge);


                } else {
                    int target_nid = residual_graph->get_target_node(curr_edge);
                    bfs_queue.push_back(residual_graph->get_component_ids_of_node(target_nid)[0]);

                }

            }
        }

    }
    
    assert(bfs_queue.empty());
        visited.clear();

        // find backward reachable nodes and edges from j
        bfs_queue.push_back(j);
        
        while (!bfs_queue.empty()) {
            int curr_node = bfs_queue.front();
            
            bfs_queue.pop_front();

            if (visited.find(curr_node) == visited.end()) {
                
                set_nodes_bkwd_reachable_from_j.insert(curr_node); // takes node seq num
                visited.insert(curr_node);
                // traverse inlist

                vector<int> inlist_of_j_side_node = residual_graph->get_inlist(map_nseq_to_res_graph_nid[curr_node]);
                for (vector<int>::iterator inlist_of_j_itr = inlist_of_j_side_node.begin(); inlist_of_j_itr != inlist_of_j_side_node.end(); inlist_of_j_itr++) {
                    int curr_edge = (*inlist_of_j_itr);

                    
#ifdef USE_FLOAT_EDGE_WEIGHTS_FOR_MINCUT                   
                    if ((residual_graph->get_edge_capacity(curr_edge) == 0.0)&&(set_frwd_edges_from_i_with_zero_capacity.find(curr_edge) != set_frwd_edges_from_i_with_zero_capacity.end())) { // stop at zero capacity edge
#else
                    if ((residual_graph->get_other_value2_in_edge(curr_edge) == 0)&&(set_frwd_edges_from_i_with_zero_capacity.find(curr_edge) != set_frwd_edges_from_i_with_zero_capacity.end())) { // stop at zero capacity edge    
#endif
                        set_bkwd_edges_from_j_with_zero_capacity.insert(curr_edge);

                    } else {
#ifdef USE_FLOAT_EDGE_WEIGHTS_FOR_MINCUT
                        if (residual_graph->get_edge_capacity(curr_edge) == 0.0)
#else                   
                        if (residual_graph->get_other_value2_in_edge(curr_edge) == 0)
#endif                            
                            set_bkwd_edges_from_j_with_zero_capacity.insert(curr_edge);

                        int source_nid = residual_graph->get_source_node(curr_edge);
                        bfs_queue.push_back(residual_graph->get_component_ids_of_node(source_nid)[0]);
                    }
                   

                }
            }

        }
        set<int> undirected_cut_edges;


        for (set<int>::iterator set_itr2 = set_frwd_edges_from_i_with_zero_capacity.begin(); set_itr2 != set_frwd_edges_from_i_with_zero_capacity.end(); set_itr2++) {
            int curr_fwd_edge = *set_itr2;
            int curr_tgt = residual_graph->get_component_ids_of_node(residual_graph->get_target_node(curr_fwd_edge))[0];
            int curr_src = residual_graph->get_component_ids_of_node(residual_graph->get_source_node(curr_fwd_edge))[0];
            if (set_nodes_bkwd_reachable_from_j.find(curr_tgt) != set_nodes_bkwd_reachable_from_j.end()) {

                //int curr_src_nseq_in_orig_graph = residual_graph->get_component_ids_of_node(curr_src)[0];
                int curr_src_nseq_in_orig_graph = curr_src;
                int curr_src_nid_in_orig_graph = GET_NODE_ID(ugraph, curr_src_nseq_in_orig_graph);
                //int curr_tgt_nseq_in_orig_graph = residual_graph->get_component_ids_of_node(curr_tgt)[0];
                int curr_tgt_nseq_in_orig_graph = curr_tgt;
                int curr_tgt_nid_in_orig_graph = GET_NODE_ID(ugraph, curr_tgt_nseq_in_orig_graph);
                set<int> all_eids_between_two_nids;
                ugraph->get_all_eids_between_two_nodes(curr_src_nid_in_orig_graph, curr_tgt_nid_in_orig_graph, all_eids_between_two_nids);
                for (set<int>::iterator set_itr_eids = all_eids_between_two_nids.begin(); set_itr_eids != all_eids_between_two_nids.end(); set_itr_eids++) {
                    undirected_cut_edges.insert(*set_itr_eids);
                }
                ugraph->get_all_eids_between_two_nodes(curr_tgt_nid_in_orig_graph, curr_src_nid_in_orig_graph, all_eids_between_two_nids);
                for (set<int>::iterator set_itr_eids = all_eids_between_two_nids.begin(); set_itr_eids != all_eids_between_two_nids.end(); set_itr_eids++) {
                    undirected_cut_edges.insert(*set_itr_eids);
                }


            }

        }
        
        

        //    set_intersection(set_frwd_edges_from_i_with_zero_capacity.begin(), set_frwd_edges_from_i_with_zero_capacity.end(), 
        //            set_bkwd_edges_from_j_with_zero_capacity.begin(), set_bkwd_edges_from_j_with_zero_capacity.end(), inserter(undirected_cut_edges, undirected_cut_edges.begin()));

        set<int>::iterator cut_edges_itr;
        for (cut_edges_itr = undirected_cut_edges.begin(); cut_edges_itr != undirected_cut_edges.end(); cut_edges_itr++) {
            
            int eid_in_ugraph = *cut_edges_itr;
            
            if (!ugraph->edge_has_subtype(eid_in_ugraph, "dummy_d_to_u")) {
                cut_edges.insert(eid_in_ugraph);
            }
        }

       
//        if ((ugraph->get_rep_id_from_nid(GET_NODE_ID(ugraph, i))) != (ugraph->get_rep_id_from_nid(GET_NODE_ID(ugraph, j))))
//            assert (!cut_edges.empty());
//        else
//            assert (cut_edges.empty());


#ifdef DEBUG_FLAG
    debug_log << "Node sets" << " s: " << set_nodes_frwd_reachable_from_i.size() << " t: " << set_nodes_bkwd_reachable_from_j.size() << endl;
    debug_log << "cut_edges: ";
    for (set<int>::iterator set_itr2 = cut_edges.begin(); set_itr2 != cut_edges.end(); set_itr2++) {
        debug_log << *set_itr2 << " ";
    }
    debug_log << endl;

#endif     
////    // populate adjacency matrix
////    fill_adj_matrix_for_graph(residual_graph);
    assert(residual_graph->get_edge_ids().size() <= num_of_edges);

#ifdef DEBUG_FLAG
    debug_log << "Total relabels " << relabel_count << endl;
    debug_log << endl;
#endif    
    
}
        




void GraphManagerNew::compute_min_cut_for_ghtree_relabel_to_front_2(GraphNew * original_graph, vector<int>& non_isolated_node_ids, int i, int j, set<int>& cut_edges, set<int>& fwd_cut_edges, set<int>& bkd_cut_edges, set<int>& set_s) {

    cout << "Mincut " << i << endl;

#ifdef DEBUG_FLAG
    debug_log << "Mincut iteration " << i << endl;
    debug_log << "-------------------------------" << endl;

    debug_log << "between " << i << " and " << j << endl;

#endif

    static int num_of_nodes, new_gid;
    static int num_of_edges;
    static map<int, int> map_nseq_to_res_graph_nid;

    static GraphNew * residual_graph;

    int curr_height, curr_excess;
    int relabel_count = 0;

    static set<int> set_seq_with_outgoing_edges_explored;
    set<int>::iterator set_itr;

    vector<int> outlist;
    vector<int>::iterator vec_itr;

    set<int> set_t;

    // this maps store the index of the neighboring node under consideration -- used for discharge
    map<int, int> nid_to_outlist_index;
    int new_nid, itr = 0;

    //int N = original_graph->get_node_ids().size();
    //non_isolated_node_ids
    int N = non_isolated_node_ids.size();
    vector<bool> src_side_nodes(N + 1, 0);

#ifdef OPT_GAP_HEUR_FLAG    

    vector<int> count_height(2 * N + 1);

    count_height[N] = 1;
    count_height[0] = N - 1;
#endif 

#ifdef OPT_MIN_DEGREE_FLAG    
    int sink_sat = 0;
    int sink_in = original_graph->get_inlist(GET_NODE_ID(original_graph, j)).size();
    int src_out = original_graph->get_outlist(GET_NODE_ID(original_graph, i)).size();
    bool need_exploration = true;
#endif    


#ifdef OPT_SIMPLE_PATH_FLAG
    set<int> set_nodes_on_simple_path;
    get_nodes_on_simple_path(original_graph, i, j, set_nodes_on_simple_path);
#ifdef DEBUG_FLAG    
    debug_log << i << " and " << j << ": ";
    for (set<int>::iterator set_itr = set_nodes_on_simple_path.begin(); set_itr != set_nodes_on_simple_path.end(); set_itr++) {
        debug_log << *set_itr << " ";
    }
    debug_log << endl;
#endif

#endif



    static vector < vector<bool >> edge_exist(N + 1, vector<bool>(N + 1));
    static unordered_map<string, long int> map_src_tgt_to_eid;


    if (i == 1) { // creates residual graph only if this is the first iteration of the mincut code ,ie., i == 1
        residual_graph = new GraphNew;
        //num_of_nodes = original_graph->get_node_ids().size();
        num_of_nodes = non_isolated_node_ids.size();
        num_of_edges = original_graph->get_edge_ids().size();
        new_gid = ++GraphManagerNew::graph_id_count;
        residual_graph->set_graph_id(new_gid);
        add_graph(new_gid, residual_graph);
        
        // populate adjacency matrix
        //fill_adj_matrix_for_graph(residual_graph);
        
#ifdef DEBUG_FLAG
        debug_log << "Created residual graph once. Graph id is " << new_gid << endl;
        debug_log << endl;
#endif

    }


    // creating the node for i      
    if (map_nseq_to_res_graph_nid.find(i) == map_nseq_to_res_graph_nid.end()) {
        new_nid = residual_graph->create_new_node();

        residual_graph->add_node_id(new_nid);
        add_node_id_graph_id(new_nid, residual_graph->get_graph_id());

        residual_graph->add_component_id_for_node(new_nid, i); // nseq in original graph
        residual_graph->add_component_id_for_node(new_nid, i); // identifier of mincut call
        residual_graph->add_component_id_for_node(new_nid, num_of_nodes); // height
        residual_graph->add_component_id_for_node(new_nid, original_graph->get_outlist(GET_NODE_ID(original_graph, i)).size()); // excess

        map_nseq_to_res_graph_nid.insert(pair<int, int>(i, new_nid));
        nid_to_outlist_index.insert(pair<int, int>(new_nid, 0));


#ifdef DEBUG_FLAG
        debug_log << "Created new node " << new_nid << " - nseq " << i << endl;
#endif          

    } else {
        new_nid = map_nseq_to_res_graph_nid[i];
        residual_graph->update_component_of_node_at_index(new_nid, 1, i); // updating identifier of mincut call
        residual_graph->update_component_of_node_at_index(new_nid, 2, num_of_nodes); // updating height
        residual_graph->update_component_of_node_at_index(new_nid, 3, original_graph->get_outlist(GET_NODE_ID(original_graph, i)).size()); // updating excess

        nid_to_outlist_index.insert(pair<int, int>(new_nid, 0));
    }

    set_s.insert(i);
    src_side_nodes[i] = 1;

    list<int> nodes_list;
    list<int>::iterator nodes_list_iter;

    nodes_list.push_back(new_nid);


    //while (nodes_list_iter != nodes_list.end()) {
    for (nodes_list_iter = nodes_list.begin(); nodes_list_iter != nodes_list.end(); nodes_list_iter++) {


#ifdef OPT_MIN_DEGREE_FLAG        
        if (need_exploration == false)
            break;
#endif
        int curr_nid_in_res_graph = *nodes_list_iter;
        int curr_nseq_in_orig_graph = residual_graph->get_component_ids_of_node(curr_nid_in_res_graph)[0];

        int curr_excess = residual_graph->get_component_ids_of_node(curr_nid_in_res_graph)[3];

        itr++;

        if (curr_excess == 0)
            continue;

        if (itr > 1 && (curr_nseq_in_orig_graph == i || curr_nseq_in_orig_graph == j))
            continue;
        //if((itr>1&&(curr_nseq_in_orig_graph==i||curr_nseq_in_orig_graph==j)) || curr_excess == 0)
        //	continue;

        //        if(curr_excess == 0) {
        //            //nodes_list_iter++;
        //            continue;
        //        }
        int curr_height = residual_graph->get_component_ids_of_node(curr_nid_in_res_graph)[2];

        // if outlist is not already explored add out-edges to residual graph
        if (set_seq_with_outgoing_edges_explored.find(curr_nseq_in_orig_graph) == set_seq_with_outgoing_edges_explored.end()) {
            int nid = GET_NODE_ID(original_graph, curr_nseq_in_orig_graph);

            outlist = original_graph->get_outlist(nid);

            for (vec_itr = outlist.begin(); vec_itr != outlist.end(); vec_itr++) {
                if (NOT_INTERAC_EDGE(original_graph, *vec_itr))
                    continue;

                int succ_node_id = original_graph->get_target_node(*vec_itr);
#ifdef OPT_SIMPLE_PATH_FLAG
                if (set_nodes_on_simple_path.find(succ_node_id) == set_nodes_on_simple_path.end())
                    continue;
#endif

                //cout<<nid<<"("<<*vec_itr<<")"<<succ_node_id<<endl;

                if (succ_node_id == nid) {
                    //nodes_list_iter++;
                    continue;
                }

                int succ_node_seq = GET_NODE_SEQ_NUM(original_graph, succ_node_id);

                bool create_new_edge = false;

                // create target node if not already created -- set height and excess to zero
                if (map_nseq_to_res_graph_nid.find(succ_node_seq) == map_nseq_to_res_graph_nid.end()) {
                    int new_nid_in_res_graph = residual_graph->create_new_node();

                    residual_graph->add_node_id(new_nid_in_res_graph);
                    add_node_id_graph_id(new_nid_in_res_graph, residual_graph->get_graph_id());

                    residual_graph->add_component_id_for_node(new_nid_in_res_graph, succ_node_seq); // nseq in original graph
                    residual_graph->add_component_id_for_node(new_nid_in_res_graph, i); // identifier for mincut call
                    residual_graph->add_component_id_for_node(new_nid_in_res_graph, 0); // height
                    residual_graph->add_component_id_for_node(new_nid_in_res_graph, 0); // excess

                    map_nseq_to_res_graph_nid.insert(pair<int, int>(succ_node_seq, new_nid_in_res_graph));
                    nid_to_outlist_index.insert(pair<int, int>(new_nid_in_res_graph, 0));
                    if (std::find(nodes_list.begin(), nodes_list.end(), new_nid_in_res_graph) == nodes_list.end()) {
                        nodes_list.push_back(new_nid_in_res_graph);
                    }

#ifdef DEBUG_FLAG
                    debug_log << "Created new node " << new_nid_in_res_graph << " - nseq " << succ_node_seq << endl;
#endif                    

                    int new_eid_in_res_graph = residual_graph->create_new_edge();
                    residual_graph->add_edge_id(new_eid_in_res_graph);
                    add_edge_id_graph_id(new_eid_in_res_graph, residual_graph->get_graph_id());
                    residual_graph->add_source_node(new_eid_in_res_graph, curr_nid_in_res_graph);
                    residual_graph->add_target_node(new_eid_in_res_graph, new_nid_in_res_graph);
                    residual_graph->add_edge_to_outlist_of_node(curr_nid_in_res_graph, new_eid_in_res_graph);
                    residual_graph->add_edge_to_inlist_of_node(new_nid_in_res_graph, new_eid_in_res_graph);
                    residual_graph->set_other_value1_in_edge(new_eid_in_res_graph, i); // identifier of mincut call
                    residual_graph->set_other_value2_in_edge(new_eid_in_res_graph, 1); // capacity
                    residual_graph->set_other_value4_in_edge(new_eid_in_res_graph, *vec_itr); // eid in original graph
                    residual_graph->add_edge_type(new_eid_in_res_graph, "original");

                    // reverse edge
                    int rev_eid_in_res_graph = residual_graph->create_new_edge();
                    residual_graph->add_edge_id(rev_eid_in_res_graph);
                    add_edge_id_graph_id(rev_eid_in_res_graph, residual_graph->get_graph_id());
                    residual_graph->add_target_node(rev_eid_in_res_graph, curr_nid_in_res_graph);
                    residual_graph->add_source_node(rev_eid_in_res_graph, new_nid_in_res_graph);
                    residual_graph->add_edge_to_inlist_of_node(curr_nid_in_res_graph, rev_eid_in_res_graph);
                    residual_graph->add_edge_to_outlist_of_node(new_nid_in_res_graph, rev_eid_in_res_graph);
                    residual_graph->set_other_value1_in_edge(rev_eid_in_res_graph, i); // identifier of mincut call

                    int rev_eid_in_orig_graph = -1;
                    bool orig_edge = false;
                    vector<int> outlist2 = original_graph->get_outlist(succ_node_id);
                    for (vector<int>::iterator out_itr = outlist2.begin(); out_itr != outlist2.end(); out_itr++) {
                        if (NOT_INTERAC_EDGE(original_graph, *vec_itr))
                            continue;

                        if (original_graph->get_target_node(*out_itr) == nid) {
                            orig_edge = true;
                            rev_eid_in_orig_graph = *out_itr;
                            break;
                        }

                    }

                    if (orig_edge) {
                        residual_graph->set_other_value2_in_edge(rev_eid_in_res_graph, 1); // capacity
                        residual_graph->add_edge_type(rev_eid_in_res_graph, "original");

                    } else {
                        residual_graph->set_other_value2_in_edge(rev_eid_in_res_graph, 0); // capacity
                        residual_graph->add_edge_type(rev_eid_in_res_graph, "not_original");

                    }
                    residual_graph->set_other_value3_in_edge(rev_eid_in_res_graph, new_eid_in_res_graph); // eid of paired reverse edge
                    residual_graph->set_other_value3_in_edge(new_eid_in_res_graph, rev_eid_in_res_graph); // eid of paired reverse edge
                    residual_graph->set_other_value4_in_edge(rev_eid_in_res_graph, rev_eid_in_orig_graph); // eid in original graph

                    //anjan
                    ////                    edge_exist[curr_nseq_in_orig_graph][succ_node_seq] = edge_exist[succ_node_seq][curr_nseq_in_orig_graph] = true;
                    ////                    stringstream ss1, ss2;
                    ////                    ss1 << curr_nid_in_res_graph << ":" << new_nid_in_res_graph;
                    ////                    ss2 << new_nid_in_res_graph << ":" << curr_nid_in_res_graph;
                    ////                    map_src_tgt_to_eid.insert(pair<string, long int>(ss1.str(), new_eid_in_res_graph));
                    ////                    map_src_tgt_to_eid.insert(pair<string, long int>(ss2.str(), rev_eid_in_res_graph));

                }                    // target node is already created -- update height and excess to zero for i-th iteration of mincut
                else {
                    int succ_nid_in_res_graph = map_nseq_to_res_graph_nid[succ_node_seq];
                    assert(succ_nid_in_res_graph != curr_nid_in_res_graph);

                    if (residual_graph->get_component_ids_of_node(succ_nid_in_res_graph)[1] != i) {

                        residual_graph->update_component_of_node_at_index(succ_nid_in_res_graph, 1, i); // updating identifier of mincut call
                        residual_graph->update_component_of_node_at_index(succ_nid_in_res_graph, 2, 0); // updating height
                        residual_graph->update_component_of_node_at_index(succ_nid_in_res_graph, 3, 0); // updating excess
                    }
                    //need optimization -- matrix is needed. edge_exist[curr_node_id][succ_node_id]  
                    int res_eid;
                    bool res_edge = false;
                    vector<int> outlist3 = residual_graph->get_outlist(curr_nid_in_res_graph);
                    for (vector<int>::iterator out_itr = outlist3.begin(); out_itr != outlist3.end(); out_itr++) {
                        res_eid = *out_itr;

                        if (residual_graph->get_target_node(res_eid) == succ_nid_in_res_graph) {
                            res_edge = true;
                            break;
                        }

                    }

                    if (res_edge) {
                        ////if (edge_exist[curr_nseq_in_orig_graph][succ_node_seq]) {
                        int res_eid;
                        stringstream ss;
                        ss << curr_nid_in_res_graph << ":" << succ_nid_in_res_graph;
                        ////res_eid = map_src_tgt_to_eid[ss.str()];
                        if (residual_graph->get_other_value1_in_edge(res_eid) != i) {
                            residual_graph->set_other_value1_in_edge(res_eid, i); // identifier of mincut call
                            assert(residual_graph->get_edge_type(res_eid) == "original");
                            residual_graph->set_other_value2_in_edge(res_eid, 1); // capacity
                        }
                        int rev_res_eid = residual_graph->get_other_value3_in_edge(res_eid); // eid of paired reverse edge
                        if (residual_graph->get_other_value1_in_edge(rev_res_eid) != i) {
                            residual_graph->set_other_value1_in_edge(rev_res_eid, i); // identifier of mincut call
                            if (residual_graph->get_edge_type(rev_res_eid) == "original") {
                                residual_graph->set_other_value2_in_edge(rev_res_eid, 1); // capacity
                            } else {
                                residual_graph->set_other_value2_in_edge(rev_res_eid, 0); // capacity
                            }
                        }
                    } else {
                        int new_eid_in_res_graph = residual_graph->create_new_edge();
                        residual_graph->add_edge_id(new_eid_in_res_graph);
                        add_edge_id_graph_id(new_eid_in_res_graph, residual_graph->get_graph_id());
                        residual_graph->add_source_node(new_eid_in_res_graph, curr_nid_in_res_graph);
                        residual_graph->add_target_node(new_eid_in_res_graph, succ_nid_in_res_graph);
                        residual_graph->add_edge_to_outlist_of_node(curr_nid_in_res_graph, new_eid_in_res_graph);
                        residual_graph->add_edge_to_inlist_of_node(succ_nid_in_res_graph, new_eid_in_res_graph);
                        residual_graph->set_other_value1_in_edge(new_eid_in_res_graph, i); // identifier of mincut call
                        residual_graph->set_other_value2_in_edge(new_eid_in_res_graph, 1); // capacity
                        residual_graph->set_other_value4_in_edge(new_eid_in_res_graph, *vec_itr); // eid in original graph
                        residual_graph->add_edge_type(new_eid_in_res_graph, "original");

                        // reverse edge
                        int rev_eid_in_res_graph = residual_graph->create_new_edge();
                        residual_graph->add_edge_id(rev_eid_in_res_graph);
                        add_edge_id_graph_id(rev_eid_in_res_graph, residual_graph->get_graph_id());
                        residual_graph->add_target_node(rev_eid_in_res_graph, curr_nid_in_res_graph);
                        residual_graph->add_source_node(rev_eid_in_res_graph, succ_nid_in_res_graph);
                        residual_graph->add_edge_to_inlist_of_node(curr_nid_in_res_graph, rev_eid_in_res_graph);
                        residual_graph->add_edge_to_outlist_of_node(succ_nid_in_res_graph, rev_eid_in_res_graph);
                        residual_graph->set_other_value1_in_edge(rev_eid_in_res_graph, i); // identifier of mincut call

                        int rev_eid_in_orig_graph = -1;
                        bool orig_edge = false;
                        vector<int> outlist2 = original_graph->get_outlist(succ_node_id);
                        for (vector<int>::iterator out_itr = outlist2.begin(); out_itr != outlist2.end(); out_itr++) {
                            if (NOT_INTERAC_EDGE(original_graph, *vec_itr))
                                continue;

                            if (original_graph->get_target_node(*out_itr) == nid) {
                                rev_eid_in_orig_graph = *out_itr;
                                orig_edge = true;
                                break;
                            }

                        }

                        if (orig_edge) {
                            residual_graph->set_other_value2_in_edge(rev_eid_in_res_graph, 1); // capacity
                            residual_graph->add_edge_type(rev_eid_in_res_graph, "original");
                        } else {
                            residual_graph->set_other_value2_in_edge(rev_eid_in_res_graph, 0); // capacity
                            residual_graph->add_edge_type(rev_eid_in_res_graph, "not_original");
                        }
                        residual_graph->set_other_value3_in_edge(rev_eid_in_res_graph, new_eid_in_res_graph); // eid of paired reverse edge
                        residual_graph->set_other_value3_in_edge(new_eid_in_res_graph, rev_eid_in_res_graph); // eid of paired reverse edge
                        residual_graph->set_other_value4_in_edge(rev_eid_in_res_graph, rev_eid_in_orig_graph); // eid in original graph

                        //anjan
                        ////                        edge_exist[curr_nseq_in_orig_graph][succ_node_seq] = edge_exist[succ_node_seq][curr_nseq_in_orig_graph] = true;
                        ////                        stringstream ss1, ss2;
                        ////                        ss1 << curr_nid_in_res_graph << ":" << succ_nid_in_res_graph;
                        ////                        ss2 << succ_nid_in_res_graph << ":" << curr_nid_in_res_graph;
                        ////                        map_src_tgt_to_eid.insert(pair<string, long int>(ss1.str(), new_eid_in_res_graph));
                        ////                        map_src_tgt_to_eid.insert(pair<string, long int>(ss2.str(), rev_eid_in_res_graph));

                    }
                }
            }

            set_seq_with_outgoing_edges_explored.insert(curr_nseq_in_orig_graph);


        }


        set<int> set_eids_to_tgt_nodes_with_min_height;
        int min_height_tgt_node_in_res_graph;
        int cum_flow_thru_edges_to_min_height_neighbr;


        int old_height = residual_graph->get_component_ids_of_node(curr_nid_in_res_graph)[2];


        // reset height, excess, capacities in residual graph for the current mincut call
        vector<int> outlist5 = residual_graph->get_outlist(curr_nid_in_res_graph);
        vector<int>::iterator out_itr;
        for (vector<int>::iterator out_itr = outlist5.begin(); out_itr != outlist5.end(); out_itr++) {

            int res_eid = *out_itr;
            int res_eid_tgt = residual_graph->get_target_node(res_eid);

#ifdef OPT_SIMPLE_PATH_FLAG
            int tgt_nid_in_orig_graph = GET_NODE_ID(original_graph, residual_graph->get_component_ids_of_node(res_eid_tgt)[0]);
            if (set_nodes_on_simple_path.find(tgt_nid_in_orig_graph) == set_nodes_on_simple_path.end())
                continue;
#endif            

            if (residual_graph->get_other_value1_in_edge(res_eid) != i) { //edge created in a previous mincut call

                if (residual_graph->get_component_ids_of_node(res_eid_tgt)[1] != i) {

                    residual_graph->update_component_of_node_at_index(res_eid_tgt, 1, i); // updating identifier of mincut call
                    residual_graph->update_component_of_node_at_index(res_eid_tgt, 2, 0); // updating height
                    residual_graph->update_component_of_node_at_index(res_eid_tgt, 3, 0); // updating excess


                }
                residual_graph->set_other_value1_in_edge(res_eid, i);
                if (residual_graph->get_edge_type(res_eid) == "original") {
                    residual_graph->set_other_value2_in_edge(res_eid, 1); // capacity
                } else {
                    residual_graph->set_other_value2_in_edge(res_eid, 0); // capacity
                }

                // since edge with id res_eid was created in a prev mincut call,
                // then the corresponding rev edge with id rev_res_eid 
                // should also have been created in the prev mincut call
                int rev_res_eid = residual_graph->get_other_value3_in_edge(res_eid);
                assert(residual_graph->get_other_value1_in_edge(rev_res_eid) != i);

                residual_graph->set_other_value1_in_edge(rev_res_eid, i);
                if (residual_graph->get_edge_type(rev_res_eid) == "original") {
                    residual_graph->set_other_value2_in_edge(rev_res_eid, 1); // capacity
                } else {
                    residual_graph->set_other_value2_in_edge(rev_res_eid, 0); // capacity
                }
            }
        }

        // discharge begins
        int count = 0;
        while (curr_excess > 0) {

            if (residual_graph->get_component_ids_of_node(curr_nid_in_res_graph)[0] == j) {
                //nodes_list_iter++;
                break;
            }
            int curr_outlist_index = nid_to_outlist_index[curr_nid_in_res_graph];

            if (curr_outlist_index == (outlist5.size())) {
                if (residual_graph->get_component_ids_of_node(curr_nid_in_res_graph)[0] == i) {
                    //nodes_list_iter++;
                    break;
                }

#ifdef OPT_GAP_HEUR_FLAG               
                // Gap heuristic
                if (count_height[curr_height] == 1) {

                    int height_v;
                    cout << "+++node = " << curr_nid_in_res_graph << "(" << curr_nseq_in_orig_graph << ")" << "height = " << curr_height << endl;
                    vector<int> res_nids = residual_graph->get_node_ids();
                    int cntr = 0;
                    int sze = res_nids.size();
                    for (vector<int>::iterator iter = res_nids.begin(); iter != res_nids.end(); iter++) {
                        //for (int v = 0; v <N; v++) {
                        //if (map_nseq_to_res_graph_nid.find(v) != map_nseq_to_res_graph_nid.end()){
                        int v_in_res = *iter;
                        //int v_in_res  = map_nseq_to_res_graph_nid[v];
                        height_v = residual_graph->get_component_ids_of_node(v_in_res)[2];
                        if (height_v < curr_height || residual_graph->get_component_ids_of_node(v_in_res)[1] != i)
                            continue;

                        count_height[height_v]--;
                        height_v = max(height_v, N + 1);
                        residual_graph->update_component_of_node_at_index(v_in_res, 2, height_v); //update height
                        count_height[height_v]++;
                        //}
                    }
                    /*if(curr_nid_in_res_graph == 439){
                      cntr++;
                      cout<<height_v<<"("<<cntr<<" "<<sze<<")";
                      }*/

                    //                        //if (height_v >= N) {
                    //                        if (height_v >= residual_graph->get_node_ids().size()) {  // -- CHECK
                    //                            set_s.insert(curr_nseq_in_orig_graph);
                    //                            
                    //                        }
                } else {
#endif
                    // relabel

                    int min_neighbr_height = inf;
                    int neighbr_height;
                    for (out_itr = outlist5.begin(); out_itr != outlist5.end(); out_itr++) {
                        int tgt_node = residual_graph->get_target_node(*out_itr);
                        int edge_cap = residual_graph->get_other_value2_in_edge(*out_itr);
#ifdef OPT_SIMPLE_PATH_FLAG
                        int tgt_nid_in_orig_graph = GET_NODE_ID(original_graph, residual_graph->get_component_ids_of_node(tgt_node)[0]);
                        if (set_nodes_on_simple_path.find(tgt_nid_in_orig_graph) == set_nodes_on_simple_path.end())
                            continue;
#endif            

                        neighbr_height = residual_graph->get_component_ids_of_node(tgt_node)[2];
                        if ((neighbr_height < min_neighbr_height) && edge_cap > 0) {
                            min_neighbr_height = neighbr_height;
                        }

                    }

                    //temp
                    /*if(relabel_count == 1326 && i==64)
                      cout<<"";
                     */
#ifdef OPT_GAP_HEUR_FLAG
                    count_height[curr_height]--;
#endif

                    residual_graph->update_component_of_node_at_index(curr_nid_in_res_graph, 2, min_neighbr_height + 1);
                    curr_height = min_neighbr_height + 1;
                    //                  if (i == 1)
                    //                    cout << "height increased " << curr_nseq_in_orig_graph << ": " << curr_height << endl;
                    relabel_count++;
                    //                  if (curr_height >= num_of_nodes) {
                    //                  //if (curr_height >= residual_graph->get_node_ids().size()) { // -- CHECK
                    //                    set_s.insert(residual_graph->get_component_ids_of_node(curr_nid_in_res_graph)[0]);
                    //                    //cout << "inserting " << residual_graph->get_component_ids_of_node(curr_nid_in_res_graph)[0] << endl;
                    //                    
                    //                  }
#ifdef OPT_GAP_HEUR_FLAG                  
                    count_height[curr_height]++;
                }
#endif  

                nid_to_outlist_index[curr_nid_in_res_graph] = 0;
            } else {

                int curr_outlist_edge = outlist5[curr_outlist_index];
                int curr_outlist_edge_capacity = residual_graph->get_other_value2_in_edge(curr_outlist_edge);
                int curr_node_height = residual_graph->get_component_ids_of_node(curr_nid_in_res_graph)[2];
                int curr_tgt_node_height = residual_graph->get_component_ids_of_node(residual_graph->get_target_node(curr_outlist_edge))[2];

                if ((curr_outlist_edge_capacity > 0) && ((map_nseq_to_res_graph_nid[i] == curr_nid_in_res_graph) || (curr_node_height == curr_tgt_node_height + 1))) {

                    // push
                    int tgt_node_in_res_graph = residual_graph->get_target_node(curr_outlist_edge);
                    int tgt_nseq_in_orig_graph = residual_graph->get_component_ids_of_node(tgt_node_in_res_graph)[0];
                    int curr_edge_capacity = residual_graph->get_other_value2_in_edge(curr_outlist_edge);
                    // update flow
                    int flow = (curr_excess < curr_edge_capacity) ? curr_excess : curr_edge_capacity;
                    residual_graph->update_component_of_node_at_index(curr_nid_in_res_graph, 3, curr_excess - flow);
                    int tgt_excess = residual_graph->get_component_ids_of_node(tgt_node_in_res_graph)[3];
                    residual_graph->update_component_of_node_at_index(tgt_node_in_res_graph, 3, tgt_excess + flow);


                    if ((tgt_nseq_in_orig_graph != i) && (tgt_nseq_in_orig_graph != j)) {


                        if (std::find(nodes_list.begin(), nodes_list.end(), tgt_node_in_res_graph) == nodes_list.end()) {
                            nodes_list.push_back(tgt_node_in_res_graph);
                        }

                    }

                    // update capacity
                    residual_graph->set_other_value2_in_edge(curr_outlist_edge, curr_edge_capacity - flow);
                    int rev_edge_id = residual_graph->get_other_value3_in_edge(curr_outlist_edge);
                    int rev_edge_capacity = residual_graph->get_other_value2_in_edge(rev_edge_id);
                    residual_graph->set_other_value2_in_edge(rev_edge_id, rev_edge_capacity + flow);

                    curr_excess = curr_excess - flow;


#ifdef OPT_MIN_DEGREE_FLAG                    
                    //anjan -- optimization if maxflow(s,t) == min(|source_outlist|, |sink_inlist|)
                    if (tgt_nseq_in_orig_graph == j) {
                        ++sink_sat;
                    }

                    if (sink_sat == min(sink_in, src_out)) {
                        need_exploration = false;
                        break;
                    }
#endif                    

                } else {
                    nid_to_outlist_index[curr_nid_in_res_graph] = curr_outlist_index + 1;
                }
            }


            count++;
        }
        //cout << "loop count = " << count << endl;
        // discharge ends

        // if node's height is increased, move node to front of nodes_list
        if (curr_height > old_height) {

            list<int>::iterator element = nodes_list_iter;
            if (element != nodes_list.begin()) {
                nodes_list.splice(nodes_list.begin(), nodes_list, element, std::next(element));

            }

        }

        //        if (i == 1) {
        //        cout << "\nNodes list ";
        //        for (list<int>::iterator it = nodes_list.begin(); it != nodes_list.end(); it++) {
        //            cout << residual_graph->get_component_ids_of_node(*it)[0] << " ";
        //        }
        //        cout << endl;
        //        }

        //nodes_list_iter++;

    }

    set<int> set_nodes_frwd_reachable_from_i;
    set<int> set_nodes_bkwd_reachable_from_j;
    set<int> set_frwd_edges_from_i_with_zero_capacity;
    set<int> set_bkwd_edges_from_j_with_zero_capacity;

    set_nodes_frwd_reachable_from_i.insert(i);
    set_nodes_bkwd_reachable_from_j.insert(j);
#ifdef OPT_MIN_DEGREE_FLAG    
    if (need_exploration) {
#endif    
        //set<int> set_t;
        //	set_difference(set_seq_with_outgoing_edges_explored.begin(), set_seq_with_outgoing_edges_explored.end(), 
        //			set_s.begin(), set_s.end(), inserter(set_t, set_t.begin()));




        //	set<int> set_nodes_frwd_reachable_from_i;
        //	set<int> set_nodes_bkwd_reachable_from_j;
        //	set<int> set_frwd_edges_from_i_with_zero_capacity;
        //	set<int> set_bkwd_edges_from_j_with_zero_capacity;

        set<int> visited;
        list<int> bfs_queue;

        // find forward reachable nodes and edges from i
        bfs_queue.push_back(i);
        //bfs_queue.push_back(map_nseq_to_res_graph_nid[i]);

        while (!bfs_queue.empty()) {

            int curr_node = bfs_queue.front();

            bfs_queue.pop_front();

            if (visited.find(curr_node) == visited.end()) {
                set_nodes_frwd_reachable_from_i.insert(curr_node); // takes node seq num
                //cout << "frwd rchble from i " << curr_node << endl;
                //if (curr_node > i){
                set_s.insert(curr_node); // takes node seq num
                src_side_nodes[curr_node] = 1;
                //}
                visited.insert(curr_node);
                // traverse outlist
                vector<int> outlist_of_i_side_node = residual_graph->get_outlist(map_nseq_to_res_graph_nid[curr_node]);
                for (vector<int>::iterator outlist_of_i_itr = outlist_of_i_side_node.begin(); outlist_of_i_itr != outlist_of_i_side_node.end(); outlist_of_i_itr++) {
                    int curr_edge = (*outlist_of_i_itr);


                    if (residual_graph->get_other_value2_in_edge(curr_edge) == 0) { // stop at zero capacity edge
                        set_frwd_edges_from_i_with_zero_capacity.insert(curr_edge);


                    } else {
                        int target_nid = residual_graph->get_target_node(curr_edge);
                        bfs_queue.push_back(residual_graph->get_component_ids_of_node(target_nid)[0]);

                    }

                }
            }

        }

        assert(bfs_queue.empty());
        visited.clear();

        // find backward reachable nodes and edges from j
        bfs_queue.push_back(j);
        //bfs_queue.push_back(map_nseq_to_res_graph_nid[j]);

        while (!bfs_queue.empty()) {
            int curr_node = bfs_queue.front();
            //int source_nid;
            bfs_queue.pop_front();

            if (visited.find(curr_node) == visited.end()) {
                //           cout << "bkwd rchble from j " << curr_node << endl;
                set_nodes_bkwd_reachable_from_j.insert(curr_node); // takes node seq num
                visited.insert(curr_node);
                // traverse inlist

                vector<int> inlist_of_j_side_node = residual_graph->get_inlist(map_nseq_to_res_graph_nid[curr_node]);
                for (vector<int>::iterator inlist_of_j_itr = inlist_of_j_side_node.begin(); inlist_of_j_itr != inlist_of_j_side_node.end(); inlist_of_j_itr++) {
                    int curr_edge = (*inlist_of_j_itr);

                    //anjan
                    if (residual_graph->get_edge_type(curr_edge) == "original") {
                        if ((residual_graph->get_other_value2_in_edge(curr_edge) == 0)&&(set_frwd_edges_from_i_with_zero_capacity.find(curr_edge) != set_frwd_edges_from_i_with_zero_capacity.end())) { // stop at zero capacity edge
                            //anjan
                            set_bkwd_edges_from_j_with_zero_capacity.insert(curr_edge);
                            //cut_edges.insert(curr_edge); // commented out by sukanya
                        } else {//anjan
                            if (residual_graph->get_other_value2_in_edge(curr_edge) == 0)
                                set_bkwd_edges_from_j_with_zero_capacity.insert(curr_edge);
                            //bfs_queue.push_back(residual_graph->get_source_node(curr_edge)); // changed by sukanya
                            int source_nid = residual_graph->get_source_node(curr_edge);
                            bfs_queue.push_back(residual_graph->get_component_ids_of_node(source_nid)[0]);
                        }
                    }


                    //                if (residual_graph->get_edge_type(curr_edge) == "original") {
                    //                    int source_nid = residual_graph->get_source_node(curr_edge);
                    //                    if (set_nodes_frwd_reachable_from_i.find(residual_graph->get_component_ids_of_node(source_nid)[0]) == set_nodes_frwd_reachable_from_i.end()) {
                    //                            set_bkwd_edges_from_j_with_zero_capacity.insert(curr_edge);
                    //                            bfs_queue.push_back(residual_graph->get_component_ids_of_node(source_nid)[0]);
                    //                    }
                    //                   
                    //                }



                }
            }

        }
        set<int> undirected_cut_edges;

        for (set<int>::iterator set_itr2 = set_frwd_edges_from_i_with_zero_capacity.begin(); set_itr2 != set_frwd_edges_from_i_with_zero_capacity.end(); set_itr2++) {
            int curr_tgt = residual_graph->get_component_ids_of_node(residual_graph->get_target_node(*set_itr2))[0];
            if (set_nodes_bkwd_reachable_from_j.find(curr_tgt) != set_nodes_bkwd_reachable_from_j.end()) {
                undirected_cut_edges.insert(residual_graph->get_other_value4_in_edge(*set_itr2));
                int rev_eid_in_res_graph = residual_graph->get_other_value3_in_edge(*set_itr2);
                undirected_cut_edges.insert(residual_graph->get_other_value4_in_edge(rev_eid_in_res_graph));
            }

        }

        //    set_intersection(set_frwd_edges_from_i_with_zero_capacity.begin(), set_frwd_edges_from_i_with_zero_capacity.end(), 
        //            set_bkwd_edges_from_j_with_zero_capacity.begin(), set_bkwd_edges_from_j_with_zero_capacity.end(), inserter(undirected_cut_edges, undirected_cut_edges.begin()));

        set<int>::iterator cut_edges_itr;
        for (cut_edges_itr = undirected_cut_edges.begin(); cut_edges_itr != undirected_cut_edges.end(); cut_edges_itr++) {
            //int eid_in_orig_graph = residual_graph->get_other_value4_in_edge(*cut_edges_itr);
            int eid_in_orig_graph = *cut_edges_itr;
            if (!original_graph->edge_has_subtype(eid_in_orig_graph, "dummy_d_to_u")) {//if (eid_in_orig_graph != -1) {
                //also check the edge's src is in actual source side
                EdgeNew * chosen_edge = original_graph->get_edge_from_eid(eid_in_orig_graph);
                // if(src_side_nodes[GET_NODE_SEQ_NUM(original_graph, chosen_edge->get_source())]==1)
                cut_edges.insert(eid_in_orig_graph);
                if (src_side_nodes[GET_NODE_SEQ_NUM(original_graph, chosen_edge->get_source())] == 1)
                    fwd_cut_edges.insert(eid_in_orig_graph);
                if (src_side_nodes[GET_NODE_SEQ_NUM(original_graph, chosen_edge->get_source())] != 1)
                    bkd_cut_edges.insert(eid_in_orig_graph);
            }
        }


#ifdef OPT_MIN_DEGREE_FLAG
    } else {// for maxflow(s,t) == min(src_outlist, sink_inlist) optimization
        vector<int> inlist, outlist, all_org_nids;
        set_s.clear();
        if (sink_sat == sink_in) {
            //get the edges of source
            int j_id = GET_NODE_ID(original_graph, j);
            inlist = original_graph->get_inlist(j_id);
            outlist = original_graph->get_outlist(j_id);

            //populate set_s
            //all_org_nids = original_graph->get_node_ids();
            all_org_nids = non_isolated_node_ids();
            for (vector<int>::iterator node_itr = all_org_nids.begin(); node_itr != all_org_nids.end(); node_itr++) {
                //if(GET_NODE_SEQ_NUM(original_graph, *node_itr) >= i)
                set_s.insert(GET_NODE_SEQ_NUM(original_graph, *node_itr));
            }
            set_s.erase(j);

            /*for (vector<int>::iterator in_itr = inlist.begin(); in_itr != inlist.end(); in_itr++){
              int eid_in_orig_graph = *in_itr;
              if (!original_graph->edge_has_subtype(eid_in_orig_graph, "dummy")) //if (eid_in_orig_graph != -1)
              cut_edges.insert(eid_in_orig_graph);
            //cout<<eid_in_orig_graph<<" ";
            }*/



        } else {
            //get the outlist of source
            int i_id = GET_NODE_ID(original_graph, i);
            inlist = original_graph->get_inlist(i_id);
            outlist = original_graph->get_outlist(i_id);

            //populate set_s
            set_s.insert(i);


            ////		for (vector<int>::iterator out_itr = outlist.begin(); out_itr != outlist.end(); out_itr++){
            ////			int eid_in_orig_graph = *out_itr;
            ////			if (!original_graph->edge_has_subtype(eid_in_orig_graph, "dummy")) //if (eid_in_orig_graph != -1)
            ////				cut_edges.insert(eid_in_orig_graph);
            ////		//cout<<eid_in_orig_graph<<" ";
            ////			
            ////		}


        }

        //push them into cut-edge
        for (vector<int>::iterator in_itr = inlist.begin(); in_itr != inlist.end(); in_itr++) {
            int eid_in_orig_graph = *in_itr;
            if (!original_graph->edge_has_subtype(eid_in_orig_graph, "dummy")) //if (eid_in_orig_graph != -1)
                cut_edges.insert(eid_in_orig_graph);
            bkd_cut_edges.insert(eid_in_orig_graph);
            //cout<<eid_in_orig_graph<<" ";
        }
        for (vector<int>::iterator out_itr = outlist.begin(); out_itr != outlist.end(); out_itr++) {
            int eid_in_orig_graph = *out_itr;
            if (!original_graph->edge_has_subtype(eid_in_orig_graph, "dummy")) //if (eid_in_orig_graph != -1)
                cut_edges.insert(eid_in_orig_graph);
            fwd_cut_edges.insert(eid_in_orig_graph);
            //cout<<eid_in_orig_graph<<" ";

        }



    }
#endif        

    //#ifdef DEBUG_FLAG        
    //        debug_log << "Node sets" << " s: " << set_nodes_frwd_reachable_from_i.size() << " t: " << set_nodes_bkwd_reachable_from_j.size() << endl;
    //        debug_log << "S: ";
    //        for (set<int>::iterator iter = set_nodes_frwd_reachable_from_i.begin(); iter != set_nodes_frwd_reachable_from_i.end(); iter++) {
    //            debug_log << *iter << " - " << residual_graph->get_component_ids_of_node(map_nseq_to_res_graph_nid[*iter])[2] << " | ";
    //        }
    //        debug_log << endl;
    //
    //        debug_log << "T: ";
    //        for (set<int>::iterator iter = set_nodes_bkwd_reachable_from_j.begin(); iter != set_nodes_bkwd_reachable_from_j.end(); iter++) {
    //            debug_log << *iter << " - " << residual_graph->get_component_ids_of_node(map_nseq_to_res_graph_nid[*iter])[2] << " | ";
    //        }
    //        debug_log << endl;
    //#endif     

#ifdef DEBUG_FLAG
    debug_log << "Node sets" << " s: " << set_nodes_frwd_reachable_from_i.size() << " t: " << set_nodes_bkwd_reachable_from_j.size() << endl;
    debug_log << "cut_edges: ";
    for (set<int>::iterator set_itr2 = cut_edges.begin(); set_itr2 != cut_edges.end(); set_itr2++) {
        debug_log << *set_itr2 << " ";
    }
    debug_log << endl;

#endif     
    // if(i==5&&j==1){
    /*for(int mm=0;mm<14;mm++)
      cout<<src_side_nodes[mm]<<":";
      cout<<endl;
      for (set<int>::iterator set_itr2 = set_s.begin(); set_itr2 != set_s.end(); set_itr2++) {
      cout << *set_itr2 << "=";
      }
      cout<<endl;*/
    //}
    assert(residual_graph->get_edge_ids().size() <= num_of_edges);

#ifdef DEBUG_FLAG
    debug_log << "Total relabels " << relabel_count << endl;
    debug_log << endl;
#endif    

}



// Implements the push-relabel algorithm

void GraphManagerNew::compute_min_cut_for_ghtree(GraphNew * original_graph, int i, int j, set<int>& cut_edges, set<int>& set_s,
        map<int, set<int> >& frwd_bfs_results, map<int, set<int> >& bkwd_bfs_results) {

    set<int> nodes_on_path_from_i_to_j; // contains nids in original graph
    get_nodes_on_path_from_i_to_j_dummy(original_graph, GET_NODE_ID(original_graph, i), GET_NODE_ID(original_graph, j), nodes_on_path_from_i_to_j,
            frwd_bfs_results, bkwd_bfs_results);

    cout << "Mincut " << i << endl;

#ifdef DEBUG_FLAG
    debug_log << "Mincut iteration " << i << endl;
    debug_log << "-------------------------------" << endl;

    debug_log << "Computing min-cut between " << i << " and " << j << endl;

#endif

    static int num_of_nodes, new_gid;
    static map<int, int> map_nseq_to_res_graph_nid;

    static GraphNew * residual_graph;

    int curr_height, curr_excess;

    static set<int> set_seq_with_outgoing_edges_explored;
    set<int>::iterator set_itr;

    vector<int> outlist;
    vector<int>::iterator vec_itr;

    int new_nid;

    if (i == 1) { // creates residual graph only if this is the first iteration of the mincut code ,ie., i == 1
        residual_graph = new GraphNew;
        num_of_nodes = original_graph->get_node_ids().size();
        new_gid = ++GraphManagerNew::graph_id_count;
        residual_graph->set_graph_id(new_gid);
        add_graph(new_gid, residual_graph);
        
        // populate adjacency matrix
        //fill_adj_matrix_for_graph(residual_graph);
#ifdef DEBUG_FLAG
        debug_log << "Created residual graph once. Graph id is " << new_gid << endl;
        debug_log << endl;
#endif

    }


    if (i == 1621) {
        cout << "Takes too long" << endl;
    }

    // creating the node for i      
    if (map_nseq_to_res_graph_nid.find(i) == map_nseq_to_res_graph_nid.end()) {
        new_nid = residual_graph->create_new_node();

        residual_graph->add_node_id(new_nid);
        add_node_id_graph_id(new_nid, residual_graph->get_graph_id());

        residual_graph->add_component_id_for_node(new_nid, i); // nseq in original graph
        residual_graph->add_component_id_for_node(new_nid, i); // identifier of mincut call
        residual_graph->add_component_id_for_node(new_nid, num_of_nodes); // height
        residual_graph->add_component_id_for_node(new_nid, original_graph->get_outlist(GET_NODE_ID(original_graph, i)).size()); // excess

        map_nseq_to_res_graph_nid.insert(pair<int, int>(i, new_nid));

    } else {
        new_nid = map_nseq_to_res_graph_nid[i];
        residual_graph->update_component_of_node_at_index(new_nid, 1, i); // updating identifier of mincut call
        residual_graph->update_component_of_node_at_index(new_nid, 2, num_of_nodes); // updating height
        residual_graph->update_component_of_node_at_index(new_nid, 3, original_graph->get_outlist(GET_NODE_ID(original_graph, i)).size()); // updating excess

    }

    // creating the node for j -- added by sukanya on 24 May 2016
    // this is required because j will not be present in the set nodes_on_path_from_i_to_j
    // hence it may not be created later on
    int new_nid_for_target;
    if (map_nseq_to_res_graph_nid.find(j) == map_nseq_to_res_graph_nid.end()) {
        new_nid_for_target = residual_graph->create_new_node();

        residual_graph->add_node_id(new_nid_for_target);
        add_node_id_graph_id(new_nid_for_target, residual_graph->get_graph_id());

        residual_graph->add_component_id_for_node(new_nid_for_target, j); // nseq in original graph
        residual_graph->add_component_id_for_node(new_nid_for_target, i); // identifier of mincut call
        residual_graph->add_component_id_for_node(new_nid_for_target, 0); // height
        residual_graph->add_component_id_for_node(new_nid_for_target, 0); // excess

        map_nseq_to_res_graph_nid.insert(pair<int, int>(j, new_nid_for_target));

    } else {
        new_nid_for_target = map_nseq_to_res_graph_nid[j];
        residual_graph->update_component_of_node_at_index(new_nid_for_target, 1, i); // updating identifier of mincut call
        residual_graph->update_component_of_node_at_index(new_nid_for_target, 2, 0); // updating height
        residual_graph->update_component_of_node_at_index(new_nid_for_target, 3, 0); // updating excess

    }


    list<int> nodes_queue;
    nodes_queue.push_back(new_nid);

    nodes_on_path_from_i_to_j.insert(GET_NODE_ID(original_graph, i));
    nodes_on_path_from_i_to_j.insert(GET_NODE_ID(original_graph, j));

    int count2 = 0;
    while (!nodes_queue.empty()) {

        int curr_nid_in_res_graph = nodes_queue.front();
        int curr_nseq_in_orig_graph = residual_graph->get_component_ids_of_node(curr_nid_in_res_graph)[0];

        nodes_queue.pop_front();

        // if node does not lie on path from i to j
        int curr_nid_in_orig_graph = GET_NODE_ID(original_graph, curr_nseq_in_orig_graph);
        if (nodes_on_path_from_i_to_j.find(curr_nid_in_orig_graph) == nodes_on_path_from_i_to_j.end())
            continue;


        int curr_excess = residual_graph->get_component_ids_of_node(curr_nid_in_res_graph)[3];
        if (curr_excess == 0)
            continue;

        int curr_height = residual_graph->get_component_ids_of_node(curr_nid_in_res_graph)[2];

        // if outlist is not already explored add out-edges to residual graph
        if (set_seq_with_outgoing_edges_explored.find(curr_nseq_in_orig_graph) == set_seq_with_outgoing_edges_explored.end()) {
            int nid = GET_NODE_ID(original_graph, curr_nseq_in_orig_graph);

            outlist = original_graph->get_outlist(nid);

            for (vec_itr = outlist.begin(); vec_itr != outlist.end(); vec_itr++) {

                int succ_node_id = original_graph->get_target_node(*vec_itr);

                // if node does not lie on path from i to j
                if (nodes_on_path_from_i_to_j.find(succ_node_id) == nodes_on_path_from_i_to_j.end())
                    continue;

                if (succ_node_id == nid)
                    continue;

                int succ_node_seq = GET_NODE_SEQ_NUM(original_graph, succ_node_id);

                bool create_new_edge = false;

                // create target node if not already created -- set height and excess to zero
                if (map_nseq_to_res_graph_nid.find(succ_node_seq) == map_nseq_to_res_graph_nid.end()) {
                    int new_nid_in_res_graph = residual_graph->create_new_node();

                    residual_graph->add_node_id(new_nid_in_res_graph);
                    add_node_id_graph_id(new_nid_in_res_graph, residual_graph->get_graph_id());

                    residual_graph->add_component_id_for_node(new_nid_in_res_graph, succ_node_seq); // nseq in original graph
                    residual_graph->add_component_id_for_node(new_nid_in_res_graph, i); // identifier for mincut call
                    residual_graph->add_component_id_for_node(new_nid_in_res_graph, 0); // height
                    residual_graph->add_component_id_for_node(new_nid_in_res_graph, 0); // excess

                    map_nseq_to_res_graph_nid.insert(pair<int, int>(succ_node_seq, new_nid_in_res_graph));

#ifdef DEBUG_FLAG
                    debug_log << "Created new node " << new_nid_in_res_graph << endl;
#endif                    

                    int new_eid_in_res_graph = residual_graph->create_new_edge();
                    residual_graph->add_edge_id(new_eid_in_res_graph);
                    add_edge_id_graph_id(new_eid_in_res_graph, residual_graph->get_graph_id());
                    residual_graph->add_source_node(new_eid_in_res_graph, curr_nid_in_res_graph);
                    residual_graph->add_target_node(new_eid_in_res_graph, new_nid_in_res_graph);
                    residual_graph->add_edge_to_outlist_of_node(curr_nid_in_res_graph, new_eid_in_res_graph);
                    residual_graph->add_edge_to_inlist_of_node(new_nid_in_res_graph, new_eid_in_res_graph);
                    residual_graph->set_other_value1_in_edge(new_eid_in_res_graph, i); // identifier of mincut call
                    residual_graph->set_other_value2_in_edge(new_eid_in_res_graph, 1); // capacity
                    residual_graph->set_other_value4_in_edge(new_eid_in_res_graph, *vec_itr); // eid in original graph
                    residual_graph->add_edge_type(new_eid_in_res_graph, "original");

                    // reverse edge
                    int rev_eid_in_res_graph = residual_graph->create_new_edge();
                    residual_graph->add_edge_id(rev_eid_in_res_graph);
                    add_edge_id_graph_id(rev_eid_in_res_graph, residual_graph->get_graph_id());
                    residual_graph->add_target_node(rev_eid_in_res_graph, curr_nid_in_res_graph);
                    residual_graph->add_source_node(rev_eid_in_res_graph, new_nid_in_res_graph);
                    residual_graph->add_edge_to_inlist_of_node(curr_nid_in_res_graph, rev_eid_in_res_graph);
                    residual_graph->add_edge_to_outlist_of_node(new_nid_in_res_graph, rev_eid_in_res_graph);
                    residual_graph->set_other_value1_in_edge(rev_eid_in_res_graph, i); // identifier of mincut call

                    int rev_eid_in_orig_graph = -1;
                    bool orig_edge = false;
                    vector<int> outlist2 = original_graph->get_outlist(succ_node_id);
                    for (vector<int>::iterator out_itr = outlist2.begin(); out_itr != outlist2.end(); out_itr++) {
                        if (original_graph->get_target_node(*out_itr) == nid) {
                            orig_edge = true;
                            rev_eid_in_orig_graph = *out_itr;
                            break;
                        }

                    }

                    if (orig_edge) {
                        residual_graph->set_other_value2_in_edge(rev_eid_in_res_graph, 1); // capacity
                        residual_graph->add_edge_type(rev_eid_in_res_graph, "original");

                    } else {
                        residual_graph->set_other_value2_in_edge(rev_eid_in_res_graph, 0); // capacity
                        residual_graph->add_edge_type(rev_eid_in_res_graph, "not_original");

                    }
                    residual_graph->set_other_value3_in_edge(rev_eid_in_res_graph, new_eid_in_res_graph); // eid of paired reverse edge
                    residual_graph->set_other_value3_in_edge(new_eid_in_res_graph, rev_eid_in_res_graph); // eid of paired reverse edge
                    residual_graph->set_other_value4_in_edge(rev_eid_in_res_graph, rev_eid_in_orig_graph); // eid in original graph
                }                    // target node is already created -- update height and excess to zero for i-th iteration of mincut
                else {
                    int succ_nid_in_res_graph = map_nseq_to_res_graph_nid[succ_node_seq];
                    assert(succ_nid_in_res_graph != curr_nid_in_res_graph);

                    if (residual_graph->get_component_ids_of_node(succ_nid_in_res_graph)[1] != i) {

                        residual_graph->update_component_of_node_at_index(succ_nid_in_res_graph, 1, i); // updating identifier of mincut call
                        residual_graph->update_component_of_node_at_index(succ_nid_in_res_graph, 2, 0); // updating height
                        residual_graph->update_component_of_node_at_index(succ_nid_in_res_graph, 3, 0); // updating excess
                    }

                    int res_eid;
                    bool res_edge = false;
                    vector<int> outlist3 = residual_graph->get_outlist(curr_nid_in_res_graph);
                    for (vector<int>::iterator out_itr = outlist3.begin(); out_itr != outlist3.end(); out_itr++) {
                        res_eid = *out_itr;

                        if (residual_graph->get_target_node(res_eid) == succ_nid_in_res_graph) {
                            res_edge = true;
                            break;
                        }

                    }
                    if (res_edge) {

                        if (residual_graph->get_other_value1_in_edge(res_eid) != i) {
                            residual_graph->set_other_value1_in_edge(res_eid, i); // identifier of mincut call
                            assert(residual_graph->get_edge_type(res_eid) == "original");
                            residual_graph->set_other_value2_in_edge(res_eid, 1); // capacity
                        }
                        int rev_res_eid = residual_graph->get_other_value3_in_edge(res_eid); // eid of paired reverse edge
                        if (residual_graph->get_other_value1_in_edge(rev_res_eid) != i) {
                            residual_graph->set_other_value1_in_edge(rev_res_eid, i); // identifier of mincut call
                            if (residual_graph->get_edge_type(rev_res_eid) == "original") {
                                residual_graph->set_other_value2_in_edge(rev_res_eid, 1); // capacity
                            } else {
                                residual_graph->set_other_value2_in_edge(rev_res_eid, 0); // capacity
                            }
                        }
                    } else {
                        int new_eid_in_res_graph = residual_graph->create_new_edge();
                        residual_graph->add_edge_id(new_eid_in_res_graph);
                        add_edge_id_graph_id(new_eid_in_res_graph, residual_graph->get_graph_id());
                        residual_graph->add_source_node(new_eid_in_res_graph, curr_nid_in_res_graph);
                        residual_graph->add_target_node(new_eid_in_res_graph, succ_nid_in_res_graph);
                        residual_graph->add_edge_to_outlist_of_node(curr_nid_in_res_graph, new_eid_in_res_graph);
                        residual_graph->add_edge_to_inlist_of_node(succ_nid_in_res_graph, new_eid_in_res_graph);
                        residual_graph->set_other_value1_in_edge(new_eid_in_res_graph, i); // identifier of mincut call
                        residual_graph->set_other_value2_in_edge(new_eid_in_res_graph, 1); // capacity
                        residual_graph->set_other_value4_in_edge(new_eid_in_res_graph, *vec_itr); // eid in original graph
                        residual_graph->add_edge_type(new_eid_in_res_graph, "original");

                        // reverse edge
                        int rev_eid_in_res_graph = residual_graph->create_new_edge();
                        residual_graph->add_edge_id(rev_eid_in_res_graph);
                        add_edge_id_graph_id(rev_eid_in_res_graph, residual_graph->get_graph_id());
                        residual_graph->add_target_node(rev_eid_in_res_graph, curr_nid_in_res_graph);
                        residual_graph->add_source_node(rev_eid_in_res_graph, succ_nid_in_res_graph);
                        residual_graph->add_edge_to_inlist_of_node(curr_nid_in_res_graph, rev_eid_in_res_graph);
                        residual_graph->add_edge_to_outlist_of_node(succ_nid_in_res_graph, rev_eid_in_res_graph);
                        residual_graph->set_other_value1_in_edge(rev_eid_in_res_graph, i); // identifier of mincut call

                        int rev_eid_in_orig_graph = -1;
                        bool orig_edge = false;
                        vector<int> outlist2 = original_graph->get_outlist(succ_node_id);
                        for (vector<int>::iterator out_itr = outlist2.begin(); out_itr != outlist2.end(); out_itr++) {
                            if (original_graph->get_target_node(*out_itr) == nid) {
                                rev_eid_in_orig_graph = *out_itr;
                                orig_edge = true;
                                break;
                            }

                        }

                        if (orig_edge) {
                            residual_graph->set_other_value2_in_edge(rev_eid_in_res_graph, 1); // capacity
                            residual_graph->add_edge_type(rev_eid_in_res_graph, "original");
                        } else {
                            residual_graph->set_other_value2_in_edge(rev_eid_in_res_graph, 0); // capacity
                            residual_graph->add_edge_type(rev_eid_in_res_graph, "not_original");
                        }
                        residual_graph->set_other_value3_in_edge(rev_eid_in_res_graph, new_eid_in_res_graph); // eid of paired reverse edge
                        residual_graph->set_other_value3_in_edge(new_eid_in_res_graph, rev_eid_in_res_graph); // eid of paired reverse edge
                        residual_graph->set_other_value4_in_edge(rev_eid_in_res_graph, rev_eid_in_orig_graph); // eid in original graph
                    }
                }
            }

            set_seq_with_outgoing_edges_explored.insert(curr_nseq_in_orig_graph);

        }


        set<int> set_eids_to_tgt_nodes_with_min_height;
        int min_height_tgt_node_in_res_graph;
        int cum_flow_thru_edges_to_min_height_neighbr;

        int old_height = residual_graph->get_component_ids_of_node(curr_nid_in_res_graph)[2];

        do {
            cum_flow_thru_edges_to_min_height_neighbr = 0;

            // Get set of neighboring nodes with minimum height
            set_eids_to_tgt_nodes_with_min_height.clear();
            min_height_tgt_node_in_res_graph = inf;

            vector<int> outlist5 = residual_graph->get_outlist(curr_nid_in_res_graph);
            for (vector<int>::iterator out_itr = outlist5.begin(); out_itr != outlist5.end(); out_itr++) {

                int res_eid = *out_itr;
                int res_eid_tgt = residual_graph->get_target_node(res_eid);

                if (residual_graph->get_other_value1_in_edge(res_eid) != i) { //edge created in a previous mincut call

                    //if (residual_graph->get_component_ids_of_node(res_eid_tgt)[1] != i) {

                    residual_graph->update_component_of_node_at_index(res_eid_tgt, 1, i); // updating identifier of mincut call
                    residual_graph->update_component_of_node_at_index(res_eid_tgt, 2, 0); // updating height
                    residual_graph->update_component_of_node_at_index(res_eid_tgt, 3, 0); // updating excess


                    //}
                    residual_graph->set_other_value1_in_edge(res_eid, i);
                    if (residual_graph->get_edge_type(res_eid) == "original") {
                        residual_graph->set_other_value2_in_edge(res_eid, 1); // capacity
                    } else {
                        residual_graph->set_other_value2_in_edge(res_eid, 0); // capacity
                    }

                    // since edge with id res_eid was created in a prev mincut call,
                    // then the corresponding rev edge with id rev_res_eid 
                    // should also have been created in the prev mincut call
                    int rev_res_eid = residual_graph->get_other_value3_in_edge(res_eid);
                    assert(residual_graph->get_other_value1_in_edge(rev_res_eid) != i);

                    residual_graph->set_other_value1_in_edge(rev_res_eid, i);
                    if (residual_graph->get_edge_type(rev_res_eid) == "original") {
                        residual_graph->set_other_value2_in_edge(rev_res_eid, 1); // capacity
                    } else {
                        residual_graph->set_other_value2_in_edge(rev_res_eid, 0); // capacity
                    }
                }




                int curr_edge_capacity = residual_graph->get_other_value2_in_edge(res_eid);
                if (curr_edge_capacity > 0) { // capacity of this edge is greater than 0
                    int height_tgt_in_res_graph = residual_graph->get_component_ids_of_node(res_eid_tgt)[2];

                    if (height_tgt_in_res_graph < min_height_tgt_node_in_res_graph) {
                        cum_flow_thru_edges_to_min_height_neighbr = curr_edge_capacity;
                        set_eids_to_tgt_nodes_with_min_height.clear();
                        set_eids_to_tgt_nodes_with_min_height.insert(res_eid);
                        min_height_tgt_node_in_res_graph = height_tgt_in_res_graph;

                    } else if (height_tgt_in_res_graph == min_height_tgt_node_in_res_graph && cum_flow_thru_edges_to_min_height_neighbr < curr_excess) {
                        set_eids_to_tgt_nodes_with_min_height.insert(res_eid);
                        cum_flow_thru_edges_to_min_height_neighbr += curr_edge_capacity;
                    }

                }

            }


            //assert(min_height_tgt_node_in_res_graph != inf);// -- violated


            if ((curr_height <= min_height_tgt_node_in_res_graph) &&
                    (curr_nseq_in_orig_graph != j) && (curr_nseq_in_orig_graph != i)) {

                residual_graph->update_component_of_node_at_index(curr_nid_in_res_graph, 2, min_height_tgt_node_in_res_graph + 1);
                curr_height = min_height_tgt_node_in_res_graph + 1;
            }

            // assert(curr_height <= num_of_nodes + 1); // may fail?
            assert(curr_height <= 2 * num_of_nodes - 1);

            if (curr_height > min_height_tgt_node_in_res_graph) {

                //                if (i != 1) {
                //                    assert(curr_height == min_height_tgt_node_in_res_graph + 1);
                //                }

                // push flow to neighboring nodes with lower height
                for (set_itr = set_eids_to_tgt_nodes_with_min_height.begin(); (set_itr != set_eids_to_tgt_nodes_with_min_height.end()) && (curr_excess > 0); set_itr++) {

                    int curr_eid = *set_itr;
                    int tgt_node_in_res_graph = residual_graph->get_target_node(curr_eid);
                    int tgt_nseq_in_orig_graph = residual_graph->get_component_ids_of_node(tgt_node_in_res_graph)[0];

                    int curr_edge_capacity = residual_graph->get_other_value2_in_edge(curr_eid);
                    // update flow
                    int flow = (curr_excess < curr_edge_capacity) ? curr_excess : curr_edge_capacity;
                    residual_graph->update_component_of_node_at_index(curr_nid_in_res_graph, 3, curr_excess - flow);
                    int tgt_excess = residual_graph->get_component_ids_of_node(tgt_node_in_res_graph)[3];
                    residual_graph->update_component_of_node_at_index(tgt_node_in_res_graph, 3, tgt_excess + flow);

                    //if (tgt_nseq_in_orig_graph != j) {
                    if ((tgt_nseq_in_orig_graph != i) && (tgt_nseq_in_orig_graph != j)) {
                        nodes_queue.push_back(tgt_node_in_res_graph);

                    }

                    // update capacity
                    residual_graph->set_other_value2_in_edge(curr_eid, curr_edge_capacity - flow);
                    int rev_edge_id = residual_graph->get_other_value3_in_edge(curr_eid);
                    int rev_edge_capacity = residual_graph->get_other_value2_in_edge(rev_edge_id);
                    residual_graph->set_other_value2_in_edge(rev_edge_id, rev_edge_capacity + flow);

                    curr_excess = curr_excess - flow;

                    //                    char wait;
                    //                    cin >> wait;
                }
            } else {

                break;
            }

        } while (curr_excess > 0);

        count2++;
    }
    //if (i == 1621)
    cout << "bfs count = " << count2 << endl;

    set<int> set_nodes_frwd_reachable_from_i;
    set<int> set_nodes_bkwd_reachable_from_j;
    set<int> set_frwd_edges_from_i_with_zero_capacity;
    set<int> set_bkwd_edges_from_j_with_zero_capacity;

    set<int> visited;
    list<int> bfs_queue;

    // find forward reachable nodes and edges from i
    bfs_queue.push_back(i);
    //bfs_queue.push_back(map_nseq_to_res_graph_nid[i]);

    while (!bfs_queue.empty()) {

        int curr_node = bfs_queue.front();

        bfs_queue.pop_front();

        if (visited.find(curr_node) == visited.end()) {
            set_nodes_frwd_reachable_from_i.insert(curr_node); // takes node seq num
            if (curr_node > i) {
                set_s.insert(curr_node); // takes node seq num
            }
            visited.insert(curr_node);
            // traverse outlist
            vector<int> outlist_of_i_side_node = residual_graph->get_outlist(map_nseq_to_res_graph_nid[curr_node]);
            for (vector<int>::iterator outlist_of_i_itr = outlist_of_i_side_node.begin(); outlist_of_i_itr != outlist_of_i_side_node.end(); outlist_of_i_itr++) {
                int curr_edge = (*outlist_of_i_itr);


                if (residual_graph->get_other_value2_in_edge(curr_edge) == 0) { // stop at zero capacity edge
                    set_frwd_edges_from_i_with_zero_capacity.insert(curr_edge);


                } else {
                    int target_nid = residual_graph->get_target_node(curr_edge);
                    bfs_queue.push_back(residual_graph->get_component_ids_of_node(target_nid)[0]);

                }

            }
        }

    }

    assert(bfs_queue.empty());
    visited.clear();

    // find backward reachable nodes and edges from j
    bfs_queue.push_back(j);
    //bfs_queue.push_back(map_nseq_to_res_graph_nid[j]);

    while (!bfs_queue.empty()) {
        int curr_node = bfs_queue.front();
        //int source_nid;
        bfs_queue.pop_front();

        if (visited.find(curr_node) == visited.end()) {
            set_nodes_bkwd_reachable_from_j.insert(curr_node); // takes node seq num
            visited.insert(curr_node);
            // traverse inlist

            vector<int> inlist_of_j_side_node = residual_graph->get_inlist(map_nseq_to_res_graph_nid[curr_node]);
            for (vector<int>::iterator inlist_of_j_itr = inlist_of_j_side_node.begin(); inlist_of_j_itr != inlist_of_j_side_node.end(); inlist_of_j_itr++) {
                int curr_edge = (*inlist_of_j_itr);

                //anjan
                if (residual_graph->get_edge_type(curr_edge) == "original") {
                    if ((residual_graph->get_other_value2_in_edge(curr_edge) == 0)&&(set_frwd_edges_from_i_with_zero_capacity.find(curr_edge) != set_frwd_edges_from_i_with_zero_capacity.end())) { // stop at zero capacity edge
                        //anjan
                        set_bkwd_edges_from_j_with_zero_capacity.insert(curr_edge);
                        //cut_edges.insert(curr_edge); // commented out by sukanya
                    } else {//anjan
                        if (residual_graph->get_other_value2_in_edge(curr_edge) == 0)
                            set_bkwd_edges_from_j_with_zero_capacity.insert(curr_edge);
                        //bfs_queue.push_back(residual_graph->get_source_node(curr_edge)); // changed by sukanya
                        int source_nid = residual_graph->get_source_node(curr_edge);
                        bfs_queue.push_back(residual_graph->get_component_ids_of_node(source_nid)[0]);
                    }
                }


                //                if (residual_graph->get_edge_type(curr_edge) == "original") {
                //                    int source_nid = residual_graph->get_source_node(curr_edge);
                //                    if (set_nodes_frwd_reachable_from_i.find(residual_graph->get_component_ids_of_node(source_nid)[0]) == set_nodes_frwd_reachable_from_i.end()) {
                //                            set_bkwd_edges_from_j_with_zero_capacity.insert(curr_edge);
                //                            bfs_queue.push_back(residual_graph->get_component_ids_of_node(source_nid)[0]);
                //                    }
                //                   
                //                }



            }
        }

    }
    set<int> undirected_cut_edges;

    for (set<int>::iterator set_itr2 = set_frwd_edges_from_i_with_zero_capacity.begin(); set_itr2 != set_frwd_edges_from_i_with_zero_capacity.end(); set_itr2++) {
        int curr_tgt = residual_graph->get_component_ids_of_node(residual_graph->get_target_node(*set_itr2))[0];
        if (set_nodes_bkwd_reachable_from_j.find(curr_tgt) != set_nodes_bkwd_reachable_from_j.end()) {
            undirected_cut_edges.insert(residual_graph->get_other_value4_in_edge(*set_itr2));
            int rev_eid_in_res_graph = residual_graph->get_other_value3_in_edge(*set_itr2);
            undirected_cut_edges.insert(residual_graph->get_other_value4_in_edge(rev_eid_in_res_graph));
        }

    }



#ifdef DEBUG_FLAG
    debug_log << "undirected_cut_edges contains: ";
    for (set<int>::iterator set_itr2 = undirected_cut_edges.begin(); set_itr2 != undirected_cut_edges.end(); set_itr2++) {
        debug_log << *set_itr2 << " ";
    }
    debug_log << endl;

#endif    



    //    set_intersection(set_frwd_edges_from_i_with_zero_capacity.begin(), set_frwd_edges_from_i_with_zero_capacity.end(), 
    //            set_bkwd_edges_from_j_with_zero_capacity.begin(), set_bkwd_edges_from_j_with_zero_capacity.end(), inserter(undirected_cut_edges, undirected_cut_edges.begin()));

    set<int>::iterator cut_edges_itr;
    for (cut_edges_itr = undirected_cut_edges.begin(); cut_edges_itr != undirected_cut_edges.end(); cut_edges_itr++) {
        //int eid_in_orig_graph = residual_graph->get_other_value4_in_edge(*cut_edges_itr);
        int eid_in_orig_graph = *cut_edges_itr;
        if (eid_in_orig_graph != -1) {
            cut_edges.insert(eid_in_orig_graph);
        }
    }



#ifdef DEBUG_FLAG    
    debug_log << endl;
#endif    
}


// takes union of inlist and outlist of parent_i as a cut

void GraphManagerNew::compute_min_cut_dummy(GraphNew * graph, int i, int parent_i, set<int>& cut_edges, set<int>& set_s) {


    vector<int> inlist, outlist;
    inlist = graph->get_inlist(parent_i);
    outlist = graph->get_outlist(parent_i);

    vector<int>::iterator vec_itr;

    set_s.insert(parent_i);
    for (vec_itr = inlist.begin(); vec_itr != inlist.end(); vec_itr++) {
        cut_edges.insert(*vec_itr);
        set_s.insert(graph->get_source_node(*vec_itr));
    }

    for (vec_itr = outlist.begin(); vec_itr != outlist.end(); vec_itr++) {
        cut_edges.insert(*vec_itr);
        set_s.insert(graph->get_target_node(*vec_itr));
    }

#ifdef DEBUG_FLAG
    debug_log << " -- mincut between " << parent_i << " and " << i << " -- " << endl;

    for (set<int>::iterator set_itr = cut_edges.begin(); set_itr != cut_edges.end(); set_itr++) {
        debug_log << (*set_itr) << " ";
    }
    debug_log << endl;
#endif


}

int GraphManagerNew::compute_gh_tree(int ugid, vector<int>& non_isolated_node_unids, vector<int>& gomoryhu_parents, vector<set<int> >& cut_edges) {
    GraphNew* ugraph = get_graph(ugid);
    if (ugraph == NULL) {
        cerr << "Error: there is no graph for id " << ugid << endl;
    }

    cout << "Computing mincuts.." << endl;
    // Gusfield algorithm for computing gh tree
    int n = gomoryhu_parents.size();
    for (int i = 1; i < n; i++) {

#ifdef ONLY_INTERAC_EDGES_FOR_MINCUT                            
        assert(!ugraph->is_isolated_node(GET_NODE_ID(ugraph, i)));

#endif   

        set<int> set_nd_useq_nums_gt_i_with_same_parent_as_i_on_i_side_of_cut;
        set<int> set_edge_ueids;
        set<int>::iterator set_itr;


        //compute_min_cut_for_ghtree_relabel_to_front(graph, non_isolated_node_ids, i, gomoryhu_parents[i], set_edge_ids, set_nd_seq_nums_gt_i_with_same_parent_as_i_on_i_side_of_cut);
        compute_weighted_min_cut_for_ghtree_relabel_to_front(ugraph, non_isolated_node_unids, i, gomoryhu_parents[i], set_edge_ueids, set_nd_useq_nums_gt_i_with_same_parent_as_i_on_i_side_of_cut);


        cut_edges[i] = set_edge_ueids; // set_edge_ueids represent cut edges between i and gomoryhu_parents[i]

        
#ifdef OPT_SIMPLE_PATH_FLAG
        // bfs call from source node on original graph not taking the cut edges
        set<int> visited;
        list<int> bfs_queue;

        bfs_queue.push_back(i);

        while (!bfs_queue.empty()) {
            int curr_node = bfs_queue.front();
            bfs_queue.pop_front();

            if (visited.find(curr_node) == visited.end()) {
                set_nd_useq_nums_gt_i_with_same_parent_as_i_on_i_side_of_cut.insert(curr_node);
                visited.insert(curr_node);
                vector<int> outlist = ugraph->get_outlist(curr_node);
                for (vector<int>::iterator outlist_itr = outlist.begin(); outlist_itr != outlist.end(); outlist_itr++) {
                    int curr_edge = *outlist_itr;

                    if (set_edge_ueids.find(curr_edge) == set_edge_ueids.end()) {
                        continue;
                    } else {
                        int target_node = ugraph->get_target_node(curr_edge);
                        bfs_queue.push_back(target_node);
                    }
                }
            }
        }

#endif        
        bool pt_is_in_X_side = false;
        for (set_itr = set_nd_useq_nums_gt_i_with_same_parent_as_i_on_i_side_of_cut.begin(); set_itr != set_nd_useq_nums_gt_i_with_same_parent_as_i_on_i_side_of_cut.end(); set_itr++) {

            if (i != *set_itr && gomoryhu_parents[*set_itr] == gomoryhu_parents[i])
                gomoryhu_parents[*set_itr] = i;
            //checking if p[t] is in X
            if (gomoryhu_parents[gomoryhu_parents[i]] == *set_itr)
                pt_is_in_X_side = true;

        }

        if (pt_is_in_X_side) {
            int t = gomoryhu_parents[i];
            gomoryhu_parents[i] = gomoryhu_parents[t];
            gomoryhu_parents[t] = i;
            cut_edges[i] = cut_edges[t];
            cut_edges[t] = set_edge_ueids;

        }

        
        
    }
    cout << n << " mincuts computed" << endl;



    // -- creating graph for Gomory-Hu tree -- starts here

    map<int, int> map_nseq_to_ghtree_nid;

    // create new graph for gh tree
    int new_gid = -1;
    GraphNew * ghtree = new GraphNew;
    new_gid = ++GraphManagerNew::graph_id_count;
    ghtree->set_graph_id(new_gid);
    add_graph(new_gid, ghtree);

    // duplicate 0th node
    int new_nid = duplicate_node(ghtree, ugraph, GET_NODE_ID(ugraph, 0), true);
    
    
    map_nseq_to_ghtree_nid.insert(pair<int, int>(0, new_nid));


    for (int i = 1; i < n; i++) {
#ifdef ONLY_INTERAC_EDGES_FOR_MINCUT                            
        assert(!ugraph->is_isolated_node(GET_NODE_ID(ugraph, i)));

#endif
        // duplicate node
        int temp_i = GET_NODE_ID(ugraph, i);
        new_nid = duplicate_node(ghtree, ugraph, GET_NODE_ID(ugraph, i), true);
        map_nseq_to_ghtree_nid.insert(pair<int, int>(i, new_nid));

        // -- added on 5 Aug 2016
        // duplicate parent node if not already created
        int new_parent_nid = duplicate_node(ghtree, ugraph, GET_NODE_ID(ugraph, gomoryhu_parents[i]), true);
        map_nseq_to_ghtree_nid.insert(pair<int, int>(gomoryhu_parents[i], new_parent_nid));
        // --

        int node_i = map_nseq_to_ghtree_nid[i];
        int node_parent_i = map_nseq_to_ghtree_nid[gomoryhu_parents[i]];

        // create edge
        int new_eid = ghtree->create_new_edge();
        ghtree->add_edge_id(new_eid);
        add_edge_id_graph_id(new_eid, ghtree->get_graph_id());
        ghtree->add_source_node(new_eid, node_i);
        ghtree->add_target_node(new_eid, node_parent_i);
        ghtree->add_edge_to_outlist_of_node(node_i, new_eid);
        ghtree->add_edge_to_inlist_of_node(node_parent_i, new_eid);
        ghtree->add_edge_type(new_eid, "gh_edge");
        ghtree->add_subtype_for_edge(new_eid, "gh_edge");

        set<pair<int, int> > written_pairs;
        for (set<int>::iterator itr = cut_edges[i].begin(); itr != cut_edges[i].end(); itr++) {
            int eid = *itr;

            int source_id = ugraph->get_source_node(eid);
            int target_id = ugraph->get_target_node(eid);

            if (written_pairs.find(make_pair(source_id, target_id)) != written_pairs.end())
                continue;

            written_pairs.insert(make_pair(source_id, target_id));


            //if ((!graph->edge_has_subtype(*itr, "dummy_u_to_d")) && (!graph->edge_has_subtype(*itr, "dummy_d_to_u"))) {
            if (!ugraph->edge_has_subtype(*itr, "dummy_d_to_u")) {
                //string edge_src_name = graph->get_all_display_ids_of_node(graph->get_source_node(*itr))[0];
                //string edge_tgt_name = graph->get_all_display_ids_of_node(graph->get_target_node(*itr))[0];
                string edge_src_name = ugraph->get_rep_id_from_nid(ugraph->get_source_node(*itr));
                string edge_tgt_name = ugraph->get_rep_id_from_nid(ugraph->get_target_node(*itr));
                string gh_edge = edge_src_name + "--" + edge_tgt_name;
                ghtree->add_pathway_for_edge(new_eid, gh_edge);

                ghtree->add_other_values_in_edge(new_eid, eid);
            }
        }
    }

    // -- creating graph for Gomory-Hu tree -- ends here   

    cout << "Created GH tree" << endl;
    
//////    // populate adjacency matrix
//////    fill_adj_matrix_for_graph(ghtree);
//////    
    
    cout << "Returning from compute_gh_tree" << endl;
    return new_gid;
}

int GraphManagerNew::compute_gh_tree_2(int gid, vector<int>& non_isolated_node_ids, vector<int>& gomoryhu_parents, vector<set<int> >& cut_edges, vector<set<int> >& fwd_cut_edges, vector<set<int> >& bkd_cut_edges) {
    GraphNew* graph = get_graph(gid);
    if (graph == NULL) {
        cerr << "Error: there is no graph for id " << gid << endl;
    }

    // Gusfield algorithm for computing gh tree
    int n = gomoryhu_parents.size();
    for (int i = 1; i < n; i++) {

        set<int> set_nd_seq_nums_gt_i_with_same_parent_as_i_on_i_side_of_cut;
        set<int> set_edge_ids;
        set<int> set_fwd_edge_ids;
        set<int> set_bkd_edge_ids;
        set<int>::iterator set_itr;

        //mincut_Dinics(graph, i, gomoryhu_parents[i], graph->get_node_ids().size(), set_edge_ids, set_nd_seq_nums_gt_i_with_same_parent_as_i_on_i_side_of_cut);
        compute_min_cut_for_ghtree_relabel_to_front_2(graph, non_isolated_node_ids, i, gomoryhu_parents[i], set_edge_ids, set_fwd_edge_ids, set_bkd_edge_ids, set_nd_seq_nums_gt_i_with_same_parent_as_i_on_i_side_of_cut);
        //compute_min_cut_for_ghtree_relabel_to_front(graph, i, gomoryhu_parents[i], set_edge_ids, set_nd_seq_nums_gt_i_with_same_parent_as_i_on_i_side_of_cut);

        cut_edges[i] = set_edge_ids; // set_edge_ids represent cut edges between i and gomoryhu_parents[i]
        fwd_cut_edges[i] = set_fwd_edge_ids;
        bkd_cut_edges[i] = set_bkd_edge_ids;

#ifdef OPT_SIMPLE_PATH_FLAG
        // bfs call from source node on original graph not taking the cut edges
        set<int> visited;
        list<int> bfs_queue;

        bfs_queue.push_back(i);

        while (!bfs_queue.empty()) {
            int curr_node = bfs_queue.front();
            bfs_queue.pop_front();

            if (visited.find(curr_node) == visited.end()) {
                set_nd_seq_nums_gt_i_with_same_parent_as_i_on_i_side_of_cut.insert(curr_node);
                visited.insert(curr_node);
                vector<int> outlist = graph->get_outlist(curr_node);
                for (vector<int>::iterator outlist_itr = outlist.begin(); outlist_itr != outlist.end(); outlist_itr++) {
                    int curr_edge = *outlist_itr;

                    if (set_edge_ids.find(curr_edge) == set_edge_ids.end()) {
                        continue;
                    } else {
                        int target_node = graph->get_target_node(curr_edge);
                        bfs_queue.push_back(target_node);
                    }
                }
            }
        }

#endif        
        bool pt_is_in_X_side = false;
        for (set_itr = set_nd_seq_nums_gt_i_with_same_parent_as_i_on_i_side_of_cut.begin(); set_itr != set_nd_seq_nums_gt_i_with_same_parent_as_i_on_i_side_of_cut.end(); set_itr++) {

            if (i != *set_itr && gomoryhu_parents[*set_itr] == gomoryhu_parents[i])
                gomoryhu_parents[*set_itr] = i;
            //checking if p[t] is in X
            if (gomoryhu_parents[gomoryhu_parents[i]] == *set_itr)
                pt_is_in_X_side = true;

        }

        if (pt_is_in_X_side) {
            int t = gomoryhu_parents[i];
            gomoryhu_parents[i] = gomoryhu_parents[t];
            gomoryhu_parents[t] = i;
            cut_edges[i] = cut_edges[t];
            cut_edges[t] = set_edge_ids;
            fwd_cut_edges[i] = fwd_cut_edges[t];
            fwd_cut_edges[t] = set_fwd_edge_ids;
            bkd_cut_edges[i] = bkd_cut_edges[t];
            bkd_cut_edges[t] = set_bkd_edge_ids;


        }

    }

    //    for (int i = 0; i < n; i++) 
    //	cout<<gomoryhu_parents[i]<<" ";


    /* for (int i = 0; i < n; i++) 
       cout<<gomoryhu_parents[i]<<" ";
       cout<<endl;
       set<int> set_edge_ids;
       for(int i=1;i<n;i++){
       set_edge_ids = cut_edges[i];
       for (set<int>::iterator set_itr2 = set_edge_ids.begin(); set_itr2 != set_edge_ids.end(); set_itr2++) {
       cout << *set_itr2 << " ";

       }
       cout<<endl;
       }*/


    // -- creating graph for Gomory-Hu tree -- starts here

    map<int, int> map_nseq_to_ghtree_nid;

    // create new graph for gh tree
    int new_gid = -1;
    GraphNew * ghtree = new GraphNew;
    new_gid = ++GraphManagerNew::graph_id_count;
    ghtree->set_graph_id(new_gid);
    add_graph(new_gid, ghtree);


    // duplicate 0th node
    int new_nid = duplicate_node(ghtree, graph, GET_NODE_ID(graph, 0), true);
    map_nseq_to_ghtree_nid.insert(pair<int, int>(0, new_nid));


    for (int i = 1; i < n; i++) {

        // duplicate node
        new_nid = duplicate_node(ghtree, graph, GET_NODE_ID(graph, i), true);
        map_nseq_to_ghtree_nid.insert(pair<int, int>(i, new_nid));

        // -- added on 5 Aug 2016
        // duplicate parent node if not already created
        int new_parent_nid = duplicate_node(ghtree, graph, GET_NODE_ID(graph, gomoryhu_parents[i]), true);
        map_nseq_to_ghtree_nid.insert(pair<int, int>(gomoryhu_parents[i], new_parent_nid));
        // --

        int node_i = map_nseq_to_ghtree_nid[i];
        int node_parent_i = map_nseq_to_ghtree_nid[gomoryhu_parents[i]];

        // create edge
        int new_eid = ghtree->create_new_edge();
        ghtree->add_edge_id(new_eid);
        add_edge_id_graph_id(new_eid, ghtree->get_graph_id());
        ghtree->add_source_node(new_eid, node_i);
        ghtree->add_target_node(new_eid, node_parent_i);
        ghtree->add_edge_to_outlist_of_node(node_i, new_eid);
        ghtree->add_edge_to_inlist_of_node(node_parent_i, new_eid);
        ghtree->add_edge_type(new_eid, "gh_edge");
        ghtree->add_subtype_for_edge(new_eid, "gh_edge");
        for (set<int>::iterator itr = cut_edges[i].begin(); itr != cut_edges[i].end(); itr++) {
            if (!graph->edge_has_subtype(*itr, "dummy")) {
                //string edge_src_name = graph->get_all_display_ids_of_node(graph->get_source_node(*itr))[0];
                //string edge_tgt_name = graph->get_all_display_ids_of_node(graph->get_target_node(*itr))[0];
                string edge_src_name = graph->get_rep_id_from_nid(graph->get_source_node(*itr));
                string edge_tgt_name = graph->get_rep_id_from_nid(graph->get_target_node(*itr));
                string gh_edge = edge_src_name + "--" + edge_tgt_name;
                ghtree->add_pathway_for_edge(new_eid, gh_edge);
            }
        }
    }

    // -- creating graph for Gomory-Hu tree -- ends here   


    
    // populate adjacency matrix
    //fill_adj_matrix_for_graph(ghtree);
    
    return new_gid;
}
//void GraphManagerNew::connect(GraphNew * graph, set<int>& present_edges, vector< vector <set<int> > >& minCutMatrix, int source_nid, int target_nid){
//    //vector<int> curr_min_cut = minCutMatrix[source_nid-1][target_nid-1];
//    set<int> curr_min_cut = minCutMatrix[source_nid-1][target_nid-1];
//    set<int>::iterator set_itr;
//    cout << "Current min cut contains edges:" << endl;
//
//    for(set_itr = curr_min_cut.begin(); set_itr != curr_min_cut.end(); set_itr++){
//        cout << (*set_itr) << endl;
//    }
//    cout << endl;
//
//    // display graph drawn so far and edges in min-cut between current pair of nodes in red
//    cout << "Choose an edge:" << endl;
//    int chosen_edge_id;
//    cin >> chosen_edge_id;
//    EdgeNew * chosen_edge = graph->get_edge_from_eid(chosen_edge_id);
//    present_edges.insert(chosen_edge->get_edge_id());
//    
//    if (source_nid != chosen_edge->get_source())
//        connect(graph, present_edges, minCutMatrix, source_nid, chosen_edge->get_source());
//    
//    if(target_nid != chosen_edge->get_target())
//        connect(graph, present_edges, minCutMatrix, chosen_edge->get_target(), target_nid);
//}

void GraphManagerNew::print_all_mincuts_src_to_tgt(GraphNew * graph, int count, map<int, int>& map_count, int nid, vector<set<int> >& cum_min_cut_edges, int node_index, vector <set<int> >& cut_edges, vector<int>& gomoryhu_parents, ofstream &outfile) {



    for (int i = count - 1; i >= 0; i--)
        if (map_count[i] != nid)
            if (cum_min_cut_edges[node_index].size() == cut_edges[map_count[i]].size()) {
                //cout<<"Edge in Tree ("<<map_count[i]<<", "<<gomoryhu_parents[map_count[i]]<<"): minCut edges:"<<endl;//here instead of map_count, print the cut_edges[map_count[i]]
                outfile << "Edge in Tree (" << map_count[i] << ", " << gomoryhu_parents[map_count[i]] << "): minCut edges:" << endl;
                for (set<int>::iterator set_itr = cut_edges[map_count[i]].begin(); set_itr != cut_edges[map_count[i]].end(); set_itr++)
                    //cout << (*set_itr)<<", ";
                    //outfile << (*set_itr)<<", ";
                    outfile << graph->get_all_display_ids_of_node(graph->get_source_node(*set_itr))[0] << " -- " <<
                    graph->get_all_display_ids_of_node(graph->get_target_node(*set_itr))[0] << endl;
                //outfile << graph->get_source_node(*set_itr)<<" -- "<<graph->get_target_node(*set_itr) << endl;
            }
    outfile << endl;

}
//In this method, we traverse both from source_nid and target_nid. they may be in a same path or different path that meet together somewhere. One of the property of GH-tree is 0 is the super parent of all nodes. that is if we traverse from a node along their parents then ultimately we reach to 0. 
//Here the algo is to traverse one step from source_nid and then traverse one step from target_nid. the common node where they first meet would be of four types 
// 0 itself
// some non-zero node
// source_nid
// target_nid
//task to be done -- additionally we sent some 3 parameter to get the min-cut edge(u,v) in the gh tree and to get where u is located in src_side or target side

set<int> GraphManagerNew::getMinCutEdges(GraphNew * graph, vector <set<int> >& cut_edges, vector<int>& gomoryhu_parents, int source_nid, int target_nid, int &node_u_in_tree, int &is_src_side, ofstream &outfile) {

    int min_node_i, min_node_j;
    int node_i = min_node_i = source_nid;
    int node_j = min_node_j = target_nid;
    int n_size = graph->get_node_ids().size(); // number of nodes
    vector<bool> i_true(n_size);
    vector<bool> j_true(n_size);
    map<int, int> map_i_to_count, map_count_to_i;
    map<int, int> map_j_to_count, map_count_to_j;
    int count_i = 0, count_j = 0;
    vector<set<int> > cum_min_cut_edges_i(n_size);
    vector<set<int> > cum_min_cut_edges_j(n_size);
    set<int> curr_cut_edges;
    int prev_size_i = inf, prev_size_j = inf, min_size, node_index_i, node_index_j;

    //at last, within the while loop, we will see node_i and node_j is updated with there parent node.
    while (true) {
        if (node_i == 0) { // from source_nid, we have reached to the 0 node OR the source node itself is 0. so no further traversal is required
            i_true[0] = true;
            map_i_to_count[0] = count_i;
        }

        if (node_j == 0) {// from target_nid, we have reached to the 0 node OR the target node itself is 0. so no further traversal is required
            j_true[0] = true;
            map_j_to_count[0] = count_j;
        }

        if (node_i != 0) {
            i_true[node_i] = true; //i_true act as a check point that node_i is already visited. it is required for checking the common meet point of node_i and node_j
            map_i_to_count[node_i] = count_i; // this map is a N->N map, we ordered the node traverse. so that they can be referrenced easily in cum_min_cut_edges_i.
            curr_cut_edges = cut_edges[node_i]; //cut_edges[i] tells the mincut edges between i and parent[i]
            min_size = curr_cut_edges.size();
            map_count_to_i[count_i] = node_i;
            if (min_size < prev_size_i && node_i != target_nid) {
                cum_min_cut_edges_i[count_i] = curr_cut_edges; // keep track of which is the minimum and propaget the minimum.
                prev_size_i = min_size;
                min_node_i = node_i;
            } else {
                cum_min_cut_edges_i[count_i] = cum_min_cut_edges_i[count_i - 1];
            }
            count_i++;

        }
        if (node_j != 0) {
            j_true[node_j] = true; //j_true act as a check point that node_j is already visited. it is required for checking the common meet point of node_i and node_j
            map_j_to_count[node_j] = count_j;
            curr_cut_edges = cut_edges[node_j]; //cut_edges[i] tells the mincut edges between i and parent[i]
            min_size = curr_cut_edges.size();
            map_count_to_j[count_j] = node_j;
            if (min_size < prev_size_j && node_j != source_nid) {
                cum_min_cut_edges_j[count_j] = curr_cut_edges;
                prev_size_j = min_size;
                min_node_j = node_j;
            } else {
                cum_min_cut_edges_j[count_j] = cum_min_cut_edges_j[count_j - 1];
            }
            count_j++;
        }

        if (i_true[node_j]) {// the common point found while traversing form node_j, i.e. target node
            node_index_j = map_j_to_count[node_j] - 1;
            node_index_i = map_i_to_count[node_j] - 1;
            //if the path from j to i is direct 
            if (node_j == source_nid) {
                print_all_mincuts_src_to_tgt(graph, count_j, map_count_to_j, source_nid, cum_min_cut_edges_j, node_index_j, cut_edges, gomoryhu_parents, outfile);
                is_src_side = 0;
                node_u_in_tree = min_node_j;
                return cum_min_cut_edges_j[node_index_j];
            }
            //cout << endl;
            // if i and j are in not in a same path
            if (count_i > 1) count_i--;
            if (count_j > 1) count_j--;
            if ((cum_min_cut_edges_i[node_index_i].size() <= cum_min_cut_edges_j[node_index_j].size())) {
                is_src_side = 1;
                node_u_in_tree = min_node_i;
                print_all_mincuts_src_to_tgt(graph, count_j, map_count_to_j, source_nid, cum_min_cut_edges_j, node_index_j, cut_edges, gomoryhu_parents, outfile);

                if ((cum_min_cut_edges_i[node_index_i].size() <= cum_min_cut_edges_j[node_index_j].size()))
                    print_all_mincuts_src_to_tgt(graph, count_i, map_count_to_i, target_nid, cum_min_cut_edges_i, node_index_i, cut_edges, gomoryhu_parents, outfile);

                return cum_min_cut_edges_i[node_index_i];
            } else {
                is_src_side = 0;
                //node_u_in_tree = map_count_to_j[count_j-2];
                node_u_in_tree = min_node_j;
                print_all_mincuts_src_to_tgt(graph, count_j, map_count_to_j, source_nid, cum_min_cut_edges_j, node_index_j, cut_edges, gomoryhu_parents, outfile);
                return cum_min_cut_edges_j[node_index_j];
            }
        } else if (j_true[node_i]) {// the common point found while traversing form node_i, i.e. src_node
            node_index_j = map_j_to_count[node_i] - 1;
            node_index_i = map_i_to_count[node_i] - 1;
            //if the path from i to j is direct -- to dump all mincuts in the path from i to j
            if (node_i == target_nid) {
                print_all_mincuts_src_to_tgt(graph, count_i, map_count_to_i, target_nid, cum_min_cut_edges_i, node_index_i, cut_edges, gomoryhu_parents, outfile);
                is_src_side = 1;
                node_u_in_tree = min_node_i;
                return cum_min_cut_edges_i[node_index_i];

            }
            //cout << endl;
            // if i and j are in not in a same path
            if (count_i > 1) count_i--;
            if (count_j > 1) count_j--;
            if ((cum_min_cut_edges_i[node_index_i].size() <= cum_min_cut_edges_j[node_index_j].size())) {
                is_src_side = 1;
                node_u_in_tree = min_node_i;
                print_all_mincuts_src_to_tgt(graph, count_i, map_count_to_i, target_nid, cum_min_cut_edges_i, node_index_i, cut_edges, gomoryhu_parents, outfile);

                if ((cum_min_cut_edges_i[node_index_i].size() == cum_min_cut_edges_j[node_index_j].size()))
                    print_all_mincuts_src_to_tgt(graph, count_j, map_count_to_j, source_nid, cum_min_cut_edges_j, node_index_j, cut_edges, gomoryhu_parents, outfile);

                return cum_min_cut_edges_i[node_index_i];
            } else {
                is_src_side = 0;
                node_u_in_tree = min_node_j;
                print_all_mincuts_src_to_tgt(graph, count_j, map_count_to_j, source_nid, cum_min_cut_edges_j, node_index_j, cut_edges, gomoryhu_parents, outfile);

                return cum_min_cut_edges_j[node_index_j];
            }
        }
        node_i = gomoryhu_parents[node_i];
        node_j = gomoryhu_parents[node_j];
    }
}

//this is the modified case of directed one
//modify this problem in such a way such that no need of cumulative search.

set<int> GraphManagerNew::getMinCutEdges_directed(GraphNew * graph, vector <set<int> >& fwd_cut_edges, vector <set<int> >& bkd_cut_edges, vector<int>& gomoryhu_parents, int source_nid, int target_nid, int &node_u_in_tree, int &is_src_side, ofstream &outfile) {
    int min_node_i, min_node_j;
    int node_i = min_node_i = source_nid;
    int node_j = min_node_j = target_nid;
    int n_size = graph->get_node_ids().size(); // number of nodes
    vector<bool> i_true(n_size);
    vector<bool> j_true(n_size);
    map<int, int> map_i_to_count, map_count_to_i;
    map<int, int> map_j_to_count, map_count_to_j;
    int count_i = 0, count_j = 0;
    vector<set<int> > cum_min_cut_edges_i(n_size);
    vector<set<int> > cum_min_cut_edges_j(n_size);
    set<int> curr_cut_edges;
    int prev_size_i = inf, prev_size_j = inf, min_size, node_index_i, node_index_j;

    //at last, within the while loop, we will see node_i and node_j is updated with there parent node.
    while (true) {
        if (node_i == 0) { // from source_nid, we have reached to the 0 node OR the source node itself is 0. so no further traversal is required
            i_true[0] = true;
            map_i_to_count[0] = count_i;
        }

        if (node_j == 0) {// from target_nid, we have reached to the 0 node OR the target node itself is 0. so no further traversal is required
            j_true[0] = true;
            map_j_to_count[0] = count_j;
        }

        if (node_i != 0) {
            i_true[node_i] = true; //i_true act as a check point that node_i is already visited. it is required for checking the common meet point of node_i and node_j
            map_i_to_count[node_i] = count_i; // this map is a N->N map, we ordered the node traverse. so that they can be referrenced easily in cum_min_cut_edges_i.
            curr_cut_edges = fwd_cut_edges[node_i]; //cut_edges[i] tells the mincut edges between i and parent[i]
            min_size = curr_cut_edges.size();
            map_count_to_i[count_i] = node_i;
            if (min_size < prev_size_i && node_i != target_nid) {
                cum_min_cut_edges_i[count_i] = curr_cut_edges; // keep track of which is the minimum and propaget the minimum.
                prev_size_i = min_size;
                min_node_i = node_i;
            } else {
                cum_min_cut_edges_i[count_i] = cum_min_cut_edges_i[count_i - 1];
            }
            count_i++;

        }
        if (node_j != 0) {
            j_true[node_j] = true; //j_true act as a check point that node_j is already visited. it is required for checking the common meet point of node_i and node_j
            map_j_to_count[node_j] = count_j;
            curr_cut_edges = bkd_cut_edges[node_j]; //cut_edges[i] tells the mincut edges between i and parent[i]
            min_size = curr_cut_edges.size();
            map_count_to_j[count_j] = node_j;
            if (min_size < prev_size_j && node_j != source_nid) {
                cum_min_cut_edges_j[count_j] = curr_cut_edges;
                prev_size_j = min_size;
                min_node_j = node_j;
            } else {
                cum_min_cut_edges_j[count_j] = cum_min_cut_edges_j[count_j - 1];
            }
            count_j++;
        }

        if (i_true[node_j]) {// the common point found while traversing form node_j, i.e. target node
            node_index_j = map_j_to_count[node_j] - 1;
            node_index_i = map_i_to_count[node_j] - 1;
            //if the path from j to i is direct 
            if (node_j == source_nid) {
                print_all_mincuts_src_to_tgt(graph, count_j, map_count_to_j, source_nid, cum_min_cut_edges_j, node_index_j, bkd_cut_edges, gomoryhu_parents, outfile);
                is_src_side = 0;
                node_u_in_tree = min_node_j;
                return cum_min_cut_edges_j[node_index_j];
            }
            cout << endl;
            // if i and j are in not in a same path
            if (count_i > 1) count_i--;
            if (count_j > 1) count_j--;
            if ((cum_min_cut_edges_i[node_index_i].size() <= cum_min_cut_edges_j[node_index_j].size())) {
                is_src_side = 1;
                node_u_in_tree = min_node_i;
                print_all_mincuts_src_to_tgt(graph, count_j, map_count_to_j, source_nid, cum_min_cut_edges_j, node_index_j, bkd_cut_edges, gomoryhu_parents, outfile);

                if ((cum_min_cut_edges_i[node_index_i].size() <= cum_min_cut_edges_j[node_index_j].size()))
                    print_all_mincuts_src_to_tgt(graph, count_i, map_count_to_i, target_nid, cum_min_cut_edges_i, node_index_i, fwd_cut_edges, gomoryhu_parents, outfile);

                return cum_min_cut_edges_i[node_index_i];
            } else {
                is_src_side = 0;
                //node_u_in_tree = map_count_to_j[count_j-2];
                node_u_in_tree = min_node_j;
                print_all_mincuts_src_to_tgt(graph, count_j, map_count_to_j, source_nid, cum_min_cut_edges_j, node_index_j, bkd_cut_edges, gomoryhu_parents, outfile);
                return cum_min_cut_edges_j[node_index_j];
            }
        } else if (j_true[node_i]) {// the common point found while traversing form node_i, i.e. src_node
            node_index_j = map_j_to_count[node_i] - 1;
            node_index_i = map_i_to_count[node_i] - 1;
            //if the path from i to j is direct -- to dump all mincuts in the path from i to j
            if (node_i == target_nid) {
                print_all_mincuts_src_to_tgt(graph, count_i, map_count_to_i, target_nid, cum_min_cut_edges_i, node_index_i, fwd_cut_edges, gomoryhu_parents, outfile);
                is_src_side = 1;
                node_u_in_tree = min_node_i;
                return cum_min_cut_edges_i[node_index_i];

            }
            cout << endl;
            // if i and j are in not in a same path
            if (count_i > 1) count_i--;
            if (count_j > 1) count_j--;
            if ((cum_min_cut_edges_i[node_index_i].size() <= cum_min_cut_edges_j[node_index_j].size())) {
                is_src_side = 1;
                node_u_in_tree = min_node_i;
                print_all_mincuts_src_to_tgt(graph, count_i, map_count_to_i, target_nid, cum_min_cut_edges_i, node_index_i, fwd_cut_edges, gomoryhu_parents, outfile);

                if ((cum_min_cut_edges_i[node_index_i].size() == cum_min_cut_edges_j[node_index_j].size()))
                    print_all_mincuts_src_to_tgt(graph, count_j, map_count_to_j, source_nid, cum_min_cut_edges_j, node_index_j, bkd_cut_edges, gomoryhu_parents, outfile);

                return cum_min_cut_edges_i[node_index_i];
            } else {
                is_src_side = 0;
                node_u_in_tree = min_node_j;
                print_all_mincuts_src_to_tgt(graph, count_j, map_count_to_j, source_nid, cum_min_cut_edges_j, node_index_j, bkd_cut_edges, gomoryhu_parents, outfile);

                return cum_min_cut_edges_j[node_index_j];
            }
        }
        node_i = gomoryhu_parents[node_i];
        node_j = gomoryhu_parents[node_j];
    }
}

bool GraphManagerNew::bfs_without_excluded_edges(GraphNew* graph, int src_seqno, int dest_seqno, set<int> excluded_edge_set) {
    set<int> visited;
    list<int> bfs_queue;

    bfs_queue.push_back(src_seqno);
    while (!bfs_queue.empty()) {
        int curr_node = bfs_queue.front();
        if (curr_node == dest_seqno)
            return true;
        bfs_queue.pop_front();
        if (visited.find(curr_node) == visited.end()) {
            visited.insert(curr_node);
            // traverse outlist
            vector<int> outlist = graph->get_outlist(curr_node);
            for (vector<int>::iterator outlist_itr = outlist.begin(); outlist_itr != outlist.end(); outlist_itr++) {
                int curr_edge = (*outlist_itr);
                if (excluded_edge_set.find(curr_edge) == excluded_edge_set.end() && !graph->edge_has_subtype(curr_edge, "dummy_d_to_u")) {
                    bfs_queue.push_back(graph->get_target_node(curr_edge));

                }
            }

        }
    }
    return false;
}

set<int> GraphManagerNew::getFilteredCutEdges(GraphNew* graph, set<int>& mincut_eids, int src_seqno, int dest_seqno) {
    set<int> filtered_edges;
    for (set<int>::iterator set_itr = mincut_eids.begin(); set_itr != mincut_eids.end(); set_itr++) {
        set<int> excluded_edge_set = mincut_eids;
        excluded_edge_set.erase(*set_itr);
        if (bfs_without_excluded_edges(graph, src_seqno, dest_seqno, excluded_edge_set))
            filtered_edges.insert(*set_itr);
    }
    return filtered_edges;
}

set<int> GraphManagerNew::my_getMinCutEdges(GraphNew * graph, vector <set<int> >& cut_edges, vector<int>& gomoryhu_parents, int source_nid, int target_nid) {
    int node_i = GET_NODE_SEQ_NUM(graph, source_nid);
    int node_j = GET_NODE_SEQ_NUM(graph, target_nid);
    int n_size = graph->get_node_ids().size();
    vector<bool> i_true(n_size);
    vector<bool> j_true(n_size);
    map<int, int> map_i_to_count;
    map<int, int> map_j_to_count;
    int count_i = 0, count_j = 0;
    vector<set<int> > cum_min_cut_edges_i(n_size);
    vector<set<int> > cum_min_cut_edges_j(n_size);
    set<int> curr_cut_edges;
    int prev_size_i = inf, prev_size_j = inf, min_size, node_index_i, node_index_j;

    while (true) {
        if (node_i == 0) {
            i_true[0] = true;
            map_i_to_count[0] = count_i;
        }

        if (node_j == 0) {
            j_true[0] = true;
            map_j_to_count[0] = count_j;
        }

        if (node_i != 0) {
            i_true[node_i] = true;
            map_i_to_count[node_i] = count_i;
            curr_cut_edges = cut_edges[node_i]; //cut_edges[i] tells the mincut edges between i and parent[i]
            min_size = curr_cut_edges.size();
            if (min_size < prev_size_i) {
                cum_min_cut_edges_i[count_i] = curr_cut_edges;
                prev_size_i = min_size;
            } else {
                cum_min_cut_edges_i[count_i] = cum_min_cut_edges_i[count_i - 1];
            }
            count_i++;

        }
        if (node_j != 0) {
            j_true[node_j] = true;
            map_j_to_count[node_j] = count_j;
            curr_cut_edges = cut_edges[node_j]; //cut_edges[i] tells the mincut edges between i and parent[i]
            min_size = curr_cut_edges.size();
            if (min_size < prev_size_j) {
                cum_min_cut_edges_j[count_j] = curr_cut_edges;
                prev_size_j = min_size;
            } else {
                cum_min_cut_edges_j[count_j] = cum_min_cut_edges_j[count_j - 1];
            }
            count_j++;
        }

        if (i_true[node_j]) {
            node_index_j = map_j_to_count[node_j] - 1;
            node_index_i = map_i_to_count[node_j] - 1;
            if (count_i == 0 && count_j > 0)
                return cum_min_cut_edges_j[node_index_j];
            if ((cum_min_cut_edges_i[node_index_i].size() < cum_min_cut_edges_j[node_index_j].size()))
                return cum_min_cut_edges_i[node_index_i];
            else
                return cum_min_cut_edges_j[node_index_j];
        } else if (j_true[node_i]) {
            node_index_j = map_j_to_count[node_j] - 1;
            node_index_i = map_i_to_count[node_j] - 1;
            if (count_i > 0 && count_j == 0)
                return cum_min_cut_edges_i[node_index_i];
            if ((cum_min_cut_edges_i[node_index_i].size() < cum_min_cut_edges_j[node_index_j].size()))
                return cum_min_cut_edges_i[node_index_i];
            else
                return cum_min_cut_edges_j[node_index_j];
        }
        node_i = gomoryhu_parents[node_i];
        node_j = gomoryhu_parents[node_j];
    }
}

int GraphManagerNew::is_in_src_side(int chosen_edge_src, int node_u_in_tree, vector<int>& gomoryhu_parents) {
    while (chosen_edge_src != node_u_in_tree) {
        if (chosen_edge_src == 0)
            break;
        chosen_edge_src = gomoryhu_parents[chosen_edge_src];
    }
    if (chosen_edge_src == node_u_in_tree)
        return 1;
    else
        return 0;
}

void GraphManagerNew::new_connect(GraphNew * graph, set<int>& present_edges, vector <set<int> >& cut_edges, vector<int>& gomoryhu_parents, int source_nid, int target_nid, ofstream &outfile) {
    int node_u_in_tree; // represents the u of the u-v cut in the GH-tree
    int is_src_side; // tells us whether it node_u_in_tree is in source_nid side or not.
    cout << "src = " << source_nid << " target = " << target_nid << endl;
    outfile << "src = " << source_nid << " target = " << target_nid << endl;
    outfile << "-------------------------------------------------" << endl;

    set<int> curr_min_cut = getMinCutEdges(graph, cut_edges, gomoryhu_parents, source_nid, target_nid, node_u_in_tree, is_src_side, outfile);

    set<int>::iterator set_itr;
    cout << "Current min cut contains edges:" << endl;

    for (set_itr = curr_min_cut.begin(); set_itr != curr_min_cut.end(); set_itr++) {
        cout << (*set_itr) << "(source nid = " << graph->get_all_display_ids_of_node(graph->get_edge_from_eid(*set_itr)->get_source())[0] << " target nid = " << graph->get_all_display_ids_of_node(graph->get_edge_from_eid(*set_itr)->get_target())[0] << ")" << endl;
    }
    cout << endl;
    // display graph drawn so far and edges in min-cut between current pair of nodes in red
    cout << "Choose an edge:" << endl;
    int chosen_edge_id;
    cin >> chosen_edge_id;
    EdgeNew * chosen_edge = graph->get_edge_from_eid(chosen_edge_id);
    if (!graph->edge_has_subtype(chosen_edge_id, "dummy_d_to_u")) {
        present_edges.insert(chosen_edge->get_edge_id());
    }
    int chosen_edge_src = GET_NODE_SEQ_NUM(graph, chosen_edge->get_source());
    int chosen_edge_tgt = GET_NODE_SEQ_NUM(graph, chosen_edge->get_target());
    int is_in_u_side = is_in_src_side(chosen_edge_src, node_u_in_tree, gomoryhu_parents);
    if ((is_in_u_side == 0 && is_src_side == 1) || (is_in_u_side == 1 && is_src_side == 0)) { // chosen edge src is not in u's side and u is in src side. or its opposite
        chosen_edge_src = chosen_edge_src + chosen_edge_tgt;
        chosen_edge_tgt = chosen_edge_src - chosen_edge_tgt;
        chosen_edge_src = chosen_edge_src - chosen_edge_tgt;
    }
    if (source_nid != chosen_edge_src) {
        //cout<<"src = "<<source_nid<<" target = "<<chosen_edge_src<<endl;
        new_connect(graph, present_edges, cut_edges, gomoryhu_parents, source_nid, chosen_edge_src, outfile);
    }

    if (target_nid != chosen_edge_tgt) {
        //cout<<"src = "<<chosen_edge_tgt<<" target = "<<target_nid<<endl;
        new_connect(graph, present_edges, cut_edges, gomoryhu_parents, chosen_edge_tgt, target_nid, outfile);
    }

}

void GraphManagerNew::connect(GraphNew * graph, set<int>& present_edges, vector <set<int> >& cut_edges, map<pair<int, int>, int>& cut_edge_index, int source_nid, int target_nid) {
    int index = cut_edge_index[make_pair(source_nid, target_nid)];

    //vector<int> curr_min_cut = minCutMatrix[source_nid-1][target_nid-1];
    set<int> curr_min_cut = cut_edges[index];
    set<int>::iterator set_itr;
    cout << "Current min cut contains edges:" << endl;

    for (set_itr = curr_min_cut.begin(); set_itr != curr_min_cut.end(); set_itr++) {
        cout << (*set_itr) << endl;
    }
    cout << endl;

    // display graph drawn so far and edges in min-cut between current pair of nodes in red
    cout << "Choose an edge:" << endl;
    int chosen_edge_id;
    cin >> chosen_edge_id;
    EdgeNew * chosen_edge = graph->get_edge_from_eid(chosen_edge_id);
    if (!graph->edge_has_subtype(chosen_edge_id, "dummy_d_to_u")) {
        present_edges.insert(chosen_edge->get_edge_id());
    }
    if (source_nid != chosen_edge->get_source())
        connect(graph, present_edges, cut_edges, cut_edge_index, source_nid, chosen_edge->get_source());

    if (target_nid != chosen_edge->get_target())
        connect(graph, present_edges, cut_edges, cut_edge_index, chosen_edge->get_target(), target_nid);
}

void GraphManagerNew::get_min_cut_edges_from_ghtree(GraphNew * graph, GraphNew * ugraph, vector< vector< bool > >& closure_matrix, vector<set<int> >& cut_edges, vector<int>& gomoryhu_parents, vector<bool>& selected_mincut_vec, int source_useq_num, int target_useq_num, set<int>& directed_cut_eids) {
    
    static int m = 1;
    
    int s = source_useq_num;
    int t = target_useq_num;
    
    
    set<int> S;
    set<int> T;

    //int parent = gomoryhu_parents[0];

    while (s != gomoryhu_parents[s]) {
        S.insert(s);
        s = gomoryhu_parents[s];
    }
    while (t != gomoryhu_parents[t]) {
        T.insert(t);
        t = gomoryhu_parents[t];
    }

    //cout << "Size: " << S.size() << " " << T.size() << endl;
    
    set<int> S_union_T;
    set<int> S_intersection_T;

    set_union(S.begin(), S.end(), T.begin(), T.end(), inserter(S_union_T, S_union_T.begin()));
    set_intersection(S.begin(), S.end(), T.begin(), T.end(), inserter(S_intersection_T, S_intersection_T.begin()));

    //cout << "Union: " << S_union_T.size() << " Intersection: " << S_intersection_T.size() << endl;
    
    
    set<int> M;
    set_difference(S_union_T.begin(), S_union_T.end(), S_intersection_T.begin(), S_intersection_T.end(), inserter(M, M.begin()));

    set<int> directed_cut_eids_temp;
    
    set<int> mincut_set_ueids = cut_edges[*M.begin()];
    //m = *M.begin();
    
    set<int> mincut_set_eids;
    
    if (s != t)
        assert (!mincut_set_ueids.empty());
    
    int first_mincut_set_total_flow = 0;
    float first_mincut_set_total_flow_float = 0.0;
    
    
    get_directed_cut4(graph, ugraph, GET_NODE_ID(ugraph, source_useq_num), GET_NODE_ID(ugraph, target_useq_num), closure_matrix, mincut_set_ueids, directed_cut_eids);
    
    mincut_set_eids = directed_cut_eids;
    for(auto i = mincut_set_eids.begin(); i != mincut_set_eids.end(); i++) {
        //assert (!ugraph->edge_has_subtype(*i, "dummy_d_to_u"));
        int eid = *i;
        //int eid = ugraph->get_other_value1_in_edge(*i);
        
        //mincut_set_eids.insert(eid);
        
        
        int curr_capacity = graph->get_edge_weight(*i);
        first_mincut_set_total_flow = first_mincut_set_total_flow + curr_capacity;
        
        float curr_capacity_float = graph->get_edge_weight_float(*i);
        first_mincut_set_total_flow_float = first_mincut_set_total_flow_float + curr_capacity_float;
    }
    
    //cout << "Size of M: " << M.size() << endl;
    
    for (set<int>::iterator iter = std::next(M.begin(),1); iter != M.end(); iter++) {
        set<int> curr_set_ueids = cut_edges[*iter];
        
        if (s != t)
            assert (!curr_set_ueids.empty());
        
        directed_cut_eids.clear();
        
        get_directed_cut4(graph, ugraph, GET_NODE_ID(ugraph, source_useq_num), GET_NODE_ID(ugraph, target_useq_num), closure_matrix, curr_set_ueids, directed_cut_eids);
        
        
        set<int> curr_set_eids = directed_cut_eids;
        
        
        int curr_set_total_flow = 0;
        float curr_set_total_flow_float = 0.0;
        
        char pause;
        for (auto i = curr_set_eids.begin(); i != curr_set_eids.end(); i++) {

            assert (!graph->edge_has_subtype(*i, "dummy_d_to_u"));            
            
            int curr_capacity = graph->get_edge_weight(*i);
            curr_set_total_flow = curr_set_total_flow + curr_capacity;
            
            float curr_capacity_float = graph->get_edge_weight_float(*i);
            curr_set_total_flow_float = curr_set_total_flow_float + curr_capacity_float;
                
        }
        
#ifdef USE_FLOAT_EDGE_WEIGHTS_FOR_MINCUT
        if ( (curr_set_total_flow_float < first_mincut_set_total_flow_float) && (curr_set_total_flow_float > 0.0)) {// && (!selected_mincut_vec[m]) ) {
            mincut_set_eids = curr_set_eids;
            first_mincut_set_total_flow_float = curr_set_total_flow_float;
            
        }
#else
        if ( (curr_set_total_flow < first_mincut_set_total_flow) && (curr_set_total_flow > 0)) {// && (!selected_mincut_vec[m]) ) {
            mincut_set_eids = curr_set_eids;
            first_mincut_set_total_flow = curr_set_total_flow;
            
        }
#endif
        
    }
    directed_cut_eids = mincut_set_eids;
    
    m++;
    //cout << source_useq_num << " " << target_useq_num << " " << directed_cut_eids.size() << endl;
    //selected_mincut_vec[m] = true;
    //assert (!directed_cut_eids.empty());
}


void GraphManagerNew::get_directed_cut2(GraphNew * graph, GraphNew * ugraph, int source_unid, int target_unid, set<int>& mincut_ueids, set<int>& directed_cut_eids) {
    
    int source_nid = ugraph->get_other_value1_from_node(source_unid);
    int target_nid = ugraph->get_other_value1_from_node(target_unid);
    
    
    set<int> mincut_eids;
    map<int, int> map_ueid_to_eid;
    
    for (auto e = mincut_ueids.begin(); e != mincut_ueids.end(); e++) {
        int eid = ugraph->get_other_value1_in_edge(*e);
        mincut_eids.insert(eid);
        map_ueid_to_eid.insert(pair<int, int>(*e, eid));
        
    }
    
    map<int, int> map_nid_to_bfs_index_frwd;
    map<int, int> map_nid_to_bfs_index_bkwd;
    
    vector<int> nids = graph->get_node_ids();
    for (auto i = nids.begin(); i != nids.end(); i++) {
        map_nid_to_bfs_index_frwd.insert(pair<int, int>(*i, 0));
        map_nid_to_bfs_index_bkwd.insert(pair<int, int>(*i, inf));
    }
    
    
    bfs_numbering2(graph, source_nid, FORWARD, map_nid_to_bfs_index_frwd);
    bfs_numbering2(graph, target_nid, BACKWARD, map_nid_to_bfs_index_bkwd);
    
    
    set<int> first_cut_ueids;
    
    // set value of target to inf  
    int source_index_value_backup = map_nid_to_bfs_index_frwd[source_nid]; 
    int target_index_value_backup = map_nid_to_bfs_index_frwd[target_nid]; 
    map_nid_to_bfs_index_frwd[source_nid] = 1;  
    map_nid_to_bfs_index_frwd[target_nid] = inf;  
    
    //assert (!mincut_ueids.empty());
    // filter cut edges   
    for (auto mincut_iter = mincut_ueids.begin(); mincut_iter != mincut_ueids.end(); mincut_iter++) {
        
        int curr_ueid = *mincut_iter;     
        int curr_eid = ugraph->get_other_value1_in_edge(curr_ueid);
        
#ifdef ONLY_INTERAC_EDGES_FOR_MINCUT     
        if (NOT_INTERAC_EDGE(graph, curr_eid))      
            continue;
#endif   
        int curr_eid_src = graph->get_source_node(curr_eid);      
        int curr_eid_tgt = graph->get_target_node(curr_eid);   
        
        if (map_nid_to_bfs_index_frwd[curr_eid_src] < map_nid_to_bfs_index_frwd[curr_eid_tgt]) { 
            if (!ugraph->edge_has_subtype(curr_ueid, "dummy_d_to_u")) {           
                first_cut_ueids.insert(curr_ueid);  
                
            }         
        }    
    }    
    
    // restore target index value   
    map_nid_to_bfs_index_frwd[source_nid] = source_index_value_backup;   
    map_nid_to_bfs_index_frwd[target_nid] = target_index_value_backup;   
    
    //assert (!first_cut_eids.empty());
    // reverse  
    
    // set value of source to inf     
    source_index_value_backup = map_nid_to_bfs_index_bkwd[source_nid]; 
    target_index_value_backup = map_nid_to_bfs_index_bkwd[target_nid]; 
    map_nid_to_bfs_index_bkwd[source_nid] = inf;  
    map_nid_to_bfs_index_bkwd[target_nid] = 1;  
    
    // filter cut edges        
    for (auto mincut_iter = first_cut_ueids.begin(); mincut_iter != first_cut_ueids.end(); mincut_iter++) {   
        
          int curr_ueid = *mincut_iter;            
          int curr_eid = ugraph->get_other_value1_in_edge(curr_ueid);
          
#ifdef ONLY_INTERAC_EDGES_FOR_MINCUT      
          if (NOT_INTERAC_EDGE(graph, curr_eid))        
              continue;
#endif        
          
          int curr_eid_src = graph->get_source_node(curr_eid);   
          int curr_eid_tgt = graph->get_target_node(curr_eid);   
          
          if (map_nid_to_bfs_index_bkwd[curr_eid_src] > map_nid_to_bfs_index_bkwd[curr_eid_tgt]) { 
              
                //if (!graph->edge_has_subtype(curr_eid, "dummy_d_to_u")) {             
                if (!ugraph->edge_has_subtype(curr_ueid, "dummy_d_to_u")) {             
                    
                    directed_cut_eids.insert(curr_eid);         
                      
                }       
          }  
    }    
    
    // restore target index value  
    map_nid_to_bfs_index_bkwd[source_unid] = source_index_value_backup;
    map_nid_to_bfs_index_bkwd[target_unid] = target_index_value_backup;
    //assert (!directed_cut_eids.empty());
}



void GraphManagerNew::get_directed_cut3(GraphNew * graph, GraphNew * ugraph, int source_unid, int target_unid, set<int>& mincut_ueids, set<int>& directed_cut_eids) {
    
    int source_nid;
    int target_nid;
//#ifdef COMPUTE_MINCUT_EDGES_FLAG
    source_nid = ugraph->get_other_value1_from_node(source_unid);
    target_nid = ugraph->get_other_value1_from_node(target_unid);
//#else
//    source_nid = source_unid;
//    target_nid = target_unid;
//#endif
    
    
    set<int> mincut_eids;
    map<int, int> map_ueid_to_eid;
    
    for (auto e = mincut_ueids.begin(); e != mincut_ueids.end(); e++) {
        int eid = ugraph->get_other_value1_in_edge(*e);
        mincut_eids.insert(eid);
        map_ueid_to_eid.insert(pair<int, int>(*e, eid));
        
    }
    
    map<int, int> map_nid_to_bfs_index_frwd;
    map<int, int> map_nid_to_bfs_index_bkwd;
    
    vector<int> unids = ugraph->get_node_ids();
    for (auto i = unids.begin(); i != unids.end(); i++) {
        map_nid_to_bfs_index_frwd.insert(pair<int, int>(*i, 0));
        map_nid_to_bfs_index_bkwd.insert(pair<int, int>(*i, 0));
    }
    
    
    bfs_numbering2(graph, source_nid, FORWARD, map_nid_to_bfs_index_frwd);
    bfs_numbering2(graph, target_nid, BACKWARD, map_nid_to_bfs_index_bkwd);
    
//    bfs_numbering3(ugraph, source_unid, FORWARD, map_unid_to_bfs_index_frwd);
//    bfs_numbering3(ugraph, target_unid, BACKWARD, map_unid_to_bfs_index_bkwd);
    
    for (auto mincut_iter = mincut_ueids.begin(); mincut_iter != mincut_ueids.end(); mincut_iter++) {
        int curr_ueid = *mincut_iter;  
        if (ugraph->edge_has_subtype(curr_ueid, "dummy_d_to_u")) {           
            continue;
        }
            
           
        int curr_eid = ugraph->get_other_value1_in_edge(curr_ueid);
        
#ifdef ONLY_INTERAC_EDGES_FOR_MINCUT     
        if (NOT_INTERAC_EDGE(ugraph, curr_ueid))      
            continue;
#endif   
        int curr_ueid_src = ugraph->get_source_node(curr_ueid);      
        int curr_ueid_tgt = ugraph->get_target_node(curr_ueid);   
        
        //if ((map_nid_to_bfs_index_frwd[source_nid] != 0) && (map_nid_to_bfs_index_bkwd[target_nid] != 0)) { 
        if ((map_nid_to_bfs_index_frwd[ugraph->get_other_value1_from_node(curr_ueid_src)] != 0) && (map_nid_to_bfs_index_bkwd[ugraph->get_other_value1_from_node(curr_ueid_tgt)] != 0)) { 
        //if ((map_unid_to_bfs_index_frwd[curr_ueid_tgt] != 0) && (map_unid_to_bfs_index_bkwd[curr_ueid_src] != 0)) { 
        
            //if (!ugraph->edge_has_subtype(curr_ueid, "dummy_d_to_u")) {           
                directed_cut_eids.insert(curr_eid);         
                
            //}         
        } 
    }    
       
#ifdef DEBUG_FLAG
    
    debug_log << "directed_cut_eids: " << source_nid << " and " << target_nid << " are " << endl;
    for (set<int>::iterator set_itr2 = directed_cut_eids.begin(); set_itr2 != directed_cut_eids.end(); set_itr2++) {
        debug_log << *set_itr2 << endl;
    }
    debug_log << endl;

#endif 
    


}


void GraphManagerNew::compute_transitive_closure(GraphNew * graph, vector< vector<bool> >& closure_matrix) {
    vector<int> nids = graph->get_node_ids();
    int n = nids.size();
    vector< vector< bool > > matrix_init(n, vector<bool>(n, false) );
    
    
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            
            if ((i == j) || graph->adj_matrix[i][j]) {
                matrix_init[i][j] = true;
            }
            else
                matrix_init[i][j] = false;
        }
    }
    
    
    
    vector< vector< bool > > matrix_temp(n, vector<bool>(n, false) );
    
    
    for (int k = 0; k < n; k++) {
        if (k == 0)
                matrix_temp = matrix_init;
        
        vector< vector< bool > > matrix_k(n, vector<bool>(n, false) );
        
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                matrix_k[i][j] = matrix_temp[i][j] || (matrix_temp[i][k] && matrix_temp[k][j]);
            }
        }
                
        
        matrix_temp = matrix_k;
        
        
    }
    
   
    closure_matrix = matrix_temp;
}


void GraphManagerNew::get_directed_cut4(GraphNew * graph, GraphNew * ugraph, int source_unid, int target_unid, vector< vector< bool > >& closure_matrix, set<int>& mincut_ueids, set<int>& directed_cut_eids) {
    
    // -- computing transitive closure
    vector<int> nids = graph->get_node_ids();
    int num_of_nodes = nids.size();
    int n = num_of_nodes;
   
//    vector< vector< bool > > closure_matrix(num_of_nodes, vector<bool>(num_of_nodes, false) );
    
    //compute_transitive_closure(graph, closure_matrix);
    
    set<int> mincut_eids;
   
    int source_unseq = GET_NODE_SEQ_NUM(ugraph, source_unid);
    int target_unseq = GET_NODE_SEQ_NUM(ugraph, target_unid);
    
    int source_nid_in_graph = ugraph->get_other_value1_from_node(source_unid);
    int target_nid_in_graph = ugraph->get_other_value1_from_node(target_unid);
    
    int source_nseq_in_graph = GET_NODE_SEQ_NUM(graph, source_nid_in_graph);
    int target_nseq_in_graph = GET_NODE_SEQ_NUM(graph, target_nid_in_graph);
    
    
    map<int, int> map_ueid_to_eid;
    
    for (auto e = mincut_ueids.begin(); e != mincut_ueids.end(); e++) {
        int eid = ugraph->get_other_value1_in_edge(*e);
        mincut_eids.insert(eid);
        map_ueid_to_eid.insert(pair<int, int>(*e, eid));
        
    }
    
    for (auto mincut_iter = mincut_ueids.begin(); mincut_iter != mincut_ueids.end(); mincut_iter++) {
        int curr_ueid = *mincut_iter;  
        if (ugraph->edge_has_subtype(curr_ueid, "dummy_d_to_u")) {           
            continue;
        }
            
           
        int curr_eid = ugraph->get_other_value1_in_edge(curr_ueid);
        
#ifdef ONLY_INTERAC_EDGES_FOR_MINCUT     
        if (NOT_INTERAC_EDGE(ugraph, curr_ueid))      
            continue;
#endif   
        int tail = ugraph->get_source_node(curr_ueid);      
        int head = ugraph->get_target_node(curr_ueid);   
        
        int edge_tail_unseq = GET_NODE_SEQ_NUM(ugraph, ugraph->get_other_value1_from_node(tail));
        int edge_head_unseq = GET_NODE_SEQ_NUM(ugraph, ugraph->get_other_value1_from_node(head));
    
        
    
//        if (closure_matrix[source_unseq][edge_tail_unseq] && closure_matrix[edge_head_unseq][target_unseq])
//            directed_cut_eids.insert(curr_eid);
        
        int tail_nid_in_graph = ugraph->get_other_value1_from_node(tail);
        int head_nid_in_graph = ugraph->get_other_value1_from_node(head);
        
        int tail_nseq_in_graph = GET_NODE_SEQ_NUM(graph, tail_nid_in_graph);
        int head_nseq_in_graph = GET_NODE_SEQ_NUM(graph, head_nid_in_graph);
        
        if (closure_matrix[source_nseq_in_graph][tail_nseq_in_graph] && closure_matrix[head_nseq_in_graph][target_nseq_in_graph])
            directed_cut_eids.insert(curr_eid);
    }
    
}
  


/*
void GraphManagerNew::get_directed_cut2(GraphNew * graph, GraphNew * ugraph, int source_nid, int target_nid, set<int>& mincut_eids, set<int>& directed_cut_eids) {

    set<int> mincut_eids_in_graph;
    map<int, int> ugraph_eid_to_graph_eid;

    map<int, int> map_nid_to_bfs_index_frwd;
    map<int, int> map_nid_to_bfs_index_bkwd;
    
    for (auto iter1 = mincut_eids.begin(); iter1 != mincut_eids.end(); iter1++) {
        mincut_eids_in_graph.insert(ugraph->get_other_value1_in_edge(*iter1));
        ugraph_eid_to_graph_eid.insert(pair<int, int>( *iter1, ugraph->get_other_value1_in_edge(*iter1)));
        
        map_nid_to_bfs_index_frwd.insert(pair<int, int>((graph->get_source_node(ugraph->get_other_value1_in_edge(*iter1))), inf));
        map_nid_to_bfs_index_frwd.insert(pair<int, int>((graph->get_target_node(ugraph->get_other_value1_in_edge(*iter1))), inf));
        
        map_nid_to_bfs_index_bkwd.insert(pair<int, int>((graph->get_source_node(ugraph->get_other_value1_in_edge(*iter1))), inf));
        map_nid_to_bfs_index_bkwd.insert(pair<int, int>((graph->get_target_node(ugraph->get_other_value1_in_edge(*iter1))), inf));
    }

    
    
    
//    source_nid = ugraph->get_other_value1_from_node(source_nid);
//    target_nid = ugraph->get_other_value1_from_node(target_nid);
    
    bfs_numbering2(graph, source_nid, FORWARD, map_nid_to_bfs_index_frwd);
    bfs_numbering2(graph, target_nid, BACKWARD, map_nid_to_bfs_index_bkwd);
    set<int> first_cut_eids;
    // set value of target to inf
////    if (map_nid_to_bfs_index_frwd.find(target_nid) == map_nid_to_bfs_index_frwd.end())
////        return;
    int target_index_value_backup = map_nid_to_bfs_index_frwd[target_nid];
    map_nid_to_bfs_index_frwd[target_nid] = inf;

    // filter cut edges
    for (auto mincut_iter = mincut_eids_in_graph.begin(); mincut_iter != mincut_eids_in_graph.end(); mincut_iter++) {
        int curr_eid = *mincut_iter;
        //curr_eid = ugraph->get_other_value1_in_edge(curr_eid);

#ifdef ONLY_INTERAC_EDGES_FOR_MINCUT
        if (NOT_INTERAC_EDGE(graph, curr_eid))
            continue;
#endif 
        int curr_eid_src = graph->get_source_node(curr_eid);
        int curr_eid_tgt = graph->get_target_node(curr_eid);

        if (map_nid_to_bfs_index_frwd[curr_eid_src] < map_nid_to_bfs_index_frwd[curr_eid_tgt]) {
            if (!graph->edge_has_subtype(curr_eid, "dummy_d_to_u")) {
                first_cut_eids.insert(curr_eid);
            }
        }
    }
    // restore target index value
    map_nid_to_bfs_index_frwd[target_nid] = target_index_value_backup;

    //cout << "first_cut_eids " << first_cut_eids.size() << endl;

    // reverse

    // set value of source to inf
////    if (map_nid_to_bfs_index_bkwd.find(source_nid) == map_nid_to_bfs_index_bkwd.end())
////        return;
    int source_index_value_backup = map_nid_to_bfs_index_bkwd[source_nid];
    map_nid_to_bfs_index_bkwd[source_nid] = inf;

    // filter cut edges
    for (auto mincut_iter = first_cut_eids.begin(); mincut_iter != first_cut_eids.end(); mincut_iter++) {
        int curr_eid = *mincut_iter;
        //curr_eid = ugraph->get_other_value1_in_edge(curr_eid);
#ifdef ONLY_INTERAC_EDGES_FOR_MINCUT
        if (NOT_INTERAC_EDGE(graph, curr_eid))
            continue;
#endif 
        int curr_eid_src = graph->get_source_node(curr_eid);
        int curr_eid_tgt = graph->get_target_node(curr_eid);


        if (map_nid_to_bfs_index_bkwd[curr_eid_src] > map_nid_to_bfs_index_bkwd[curr_eid_tgt]) {
            if (!graph->edge_has_subtype(curr_eid, "dummy_d_to_u")) {
                directed_cut_eids.insert(curr_eid);
                //directed_cut_eids.insert(ugraph_eid_to_graph_eid[curr_eid]);
            }
        }
    }
    // restore target index value
    map_nid_to_bfs_index_frwd[source_nid] = source_index_value_backup;

    //cout << "directed_cut_eids " << directed_cut_eids.size() << endl;

}*/

void GraphManagerNew::get_highest_weights_cuts(GraphNew * graph, GraphNew * ugraph, set<int>& mincut_eids, map<int, int>& nid_to_expr_value_map, set<int>& filtered_directed_cut_eids) {
    // copy map into vector of pairs and sort this vector
    vector <pair<int, int> > nid_weight_pairs;

    if (nid_to_expr_value_map.empty())
        return;

    for (auto temp = nid_to_expr_value_map.begin(); temp != nid_to_expr_value_map.end(); temp++) {
        nid_weight_pairs.push_back(pair<int, int>(temp->first, temp->second));
    }

    sort(nid_weight_pairs.begin(), nid_weight_pairs.end(), compare_pair_on_second_descending);
    int highest_weight = nid_weight_pairs.begin()->second;

    set<int> nids_with_highest_weight;
    for (auto iter = nid_weight_pairs.begin(); iter != nid_weight_pairs.end(); iter++) {
        int curr_weight = iter->second;
        if (curr_weight < highest_weight)
            break;
        else {
            assert(curr_weight == highest_weight);
            nids_with_highest_weight.insert(iter->first);
        }
    }

    for (auto iter = mincut_eids.begin(); iter != mincut_eids.end(); iter++) {
        int curr_src_nid = graph->get_source_node(ugraph->get_other_value1_in_edge(*iter));
        if (nids_with_highest_weight.find(curr_src_nid) != nids_with_highest_weight.end()) {
            filtered_directed_cut_eids.insert(*iter);
        }
    }

    if (filtered_directed_cut_eids.empty()) {
        filtered_directed_cut_eids = mincut_eids;
        //cout << "No differentially expressed edge in mincut" << endl;
    }

}

void GraphManagerNew::get_above_threshold_weights_cuts(GraphNew * wgraph, GraphNew * ugraph, set<int>& directed_cut_eids, map<int, float>& nid_to_expr_value_map, set<int>& filtered_directed_cut_eids, float threshold) {
    
    float fold_change_thres = threshold; //pow(2, threshold);
    vector <pair<int, int> > nid_weight_pairs;

    if (nid_to_expr_value_map.empty()) {
        filtered_directed_cut_eids = directed_cut_eids;
        return;
    }

    for (auto iter = directed_cut_eids.begin(); iter != directed_cut_eids.end(); iter++) {
        //cout << ugraph->get_all_display_ids_of_node(ugraph->get_source_node(*iter))[0] << "-" << ugraph->get_all_display_ids_of_node(ugraph->get_target_node(*iter))[0] << "\t";
        int curr_src_nid = wgraph->get_source_node(*iter);
        auto w_iter = nid_to_expr_value_map.find(curr_src_nid);
        
        if (w_iter != nid_to_expr_value_map.end()) {
            if (w_iter->second >= fold_change_thres) {
                filtered_directed_cut_eids.insert(*iter);
                
            }
            
        }
        
        int curr_tgt_nid = wgraph->get_source_node(*iter);
        w_iter = nid_to_expr_value_map.find(curr_tgt_nid);
        
        if (w_iter != nid_to_expr_value_map.end()) {
           
            if (w_iter->second >= fold_change_thres) {
                filtered_directed_cut_eids.insert(*iter);
                
            }
            
        }
    }
    

    if (filtered_directed_cut_eids.empty()) {
        filtered_directed_cut_eids = directed_cut_eids;
        //cout << "No differentially expressed edge in mincut" << endl;
    }
}


void GraphManagerNew::get_mincut_edges_with_up_reg_source(GraphNew * wgraph, GraphNew * ugraph, set<int>& directed_cut_eids, set<int>& up_reg_nids, set<int>& filtered_directed_cut_eids) {
    
    
    for (auto iter = directed_cut_eids.begin(); iter != directed_cut_eids.end(); iter++) {
        int curr_src_nid = wgraph->get_source_node(*iter);
        int curr_tgt_nid = wgraph->get_target_node(*iter);
        if (up_reg_nids.find(curr_src_nid) != up_reg_nids.end())
            filtered_directed_cut_eids.insert(*iter);
        
        else if (up_reg_nids.find(curr_tgt_nid) != up_reg_nids.end())
            filtered_directed_cut_eids.insert(*iter);
    }
    

    if (filtered_directed_cut_eids.empty()) {
        filtered_directed_cut_eids = directed_cut_eids;
        //cout << "No differentially expressed edge in mincut" << endl;
    }
}


void GraphManagerNew::bfs_numbering2(GraphNew * graph, int source_nid, int direction, map<int, int>& map_nid_to_bfs_index) {
    int index = 1;
    list<int> queue;
    set<int> visited;

    queue.push_back(source_nid);
    visited.insert(source_nid);

    map_nid_to_bfs_index[source_nid] = index;
    index++;

    while (!queue.empty()) {
        int curr_nid = queue.front();
        queue.pop_front();
//        visited.insert(curr_nid);
        vector<int> list;
        
        if (direction == FORWARD)
            list = graph->get_outlist(curr_nid);
        else if (direction == BACKWARD)
            list = graph->get_inlist(curr_nid);


        for (auto edge_itr = list.begin(); edge_itr != list.end(); edge_itr++) {
            int curr_neighbor;
            if (direction == FORWARD)
                curr_neighbor = graph->get_target_node(*edge_itr);
            else if (direction == BACKWARD)
                curr_neighbor = graph->get_source_node(*edge_itr);
            if (visited.find(curr_neighbor) == visited.end()) {
                queue.push_back(curr_neighbor);
                visited.insert(curr_neighbor);

//                map_nid_to_bfs_index[curr_neighbor] = index;
//                index++;

            }
            if (curr_neighbor != source_nid)
                map_nid_to_bfs_index[curr_neighbor] = index;
            
        }
        index++;
    }
}

void GraphManagerNew::bfs_numbering3(GraphNew * ugraph, int source_unid, int direction, map<int, int>& map_unid_to_bfs_index) {
    int index = 1;
    list<int> queue;
    set<int> visited;

    queue.push_back(source_unid);
    visited.insert(source_unid);

    while (!queue.empty()) {
        int curr_unid = queue.front();
        queue.pop_front();
        
        map_unid_to_bfs_index[curr_unid] = index;
        
        vector<int> list;
        
        if (direction == FORWARD)
            list = ugraph->get_outlist(curr_unid);
        else if (direction == BACKWARD)
            list = ugraph->get_inlist(curr_unid);


        for (auto edge_itr = list.begin(); edge_itr != list.end(); edge_itr++) {
            if (ugraph->edge_has_subtype(*edge_itr, "dummy_d_to_u")) {    
                continue;
            }
            int curr_neighbor;
            if (direction == FORWARD)
                curr_neighbor = ugraph->get_target_node(*edge_itr);
            else if (direction == BACKWARD)
                curr_neighbor = ugraph->get_source_node(*edge_itr);
            
            if (visited.find(curr_neighbor) == visited.end()) {
                queue.push_back(curr_neighbor);
                visited.insert(curr_neighbor);
            }
            
        }
        index++;
    }
}



void GraphManagerNew::bfs_numbering4(GraphNew * graph, int source_nid, int direction, map<int, bool>& map_nid_to_reachable_status, map<int, set<int> >& map_nid_reachable_thru_eids_set) {
    
    list<int> queue;
    set<int> visited;

    queue.push_back(source_nid);
    visited.insert(source_nid);

    map_nid_to_reachable_status[source_nid] = true;
    set<int> curr_set_of_reachble_through_eids;

    while (!queue.empty()) {
        int curr_nid = queue.front();
        queue.pop_front();
        vector<int> list;
        
        if (direction == FORWARD)
            list = graph->get_outlist(curr_nid);
        else if (direction == BACKWARD)
            list = graph->get_inlist(curr_nid);


        for (auto edge_itr = list.begin(); edge_itr != list.end(); edge_itr++) {
            int curr_edge = *edge_itr;
            int curr_neighbor;
            if (direction == FORWARD)
                curr_neighbor = graph->get_target_node(curr_edge);
            else if (direction == BACKWARD)
                curr_neighbor = graph->get_source_node(curr_edge);
            
            if (visited.find(curr_neighbor) == visited.end()) {
                queue.push_back(curr_neighbor);
                visited.insert(curr_neighbor);
            }
            
            if (curr_neighbor != source_nid) {
                map_nid_to_reachable_status[curr_neighbor] = true;
                curr_set_of_reachble_through_eids.insert(curr_edge);
                for (auto i = queue.begin(); i != queue.end(); i++) {
                    map_nid_reachable_thru_eids_set[curr_neighbor].insert(curr_edge);
                }
                //map_nid_reachable_thru_eids_set[curr_nid].insert(curr_edge);
            }
        }
        
        //map_nid_reachable_thru_eids_set.insert(pair<int, set<int> >(curr_nid, curr_set_of_reachble_through_eids));
        
    }
    
    
}


void GraphManagerNew::dfs_numbering4(GraphNew * graph, int source_nid, int direction, map<int, bool>& map_nid_to_reachable_status, map<int, set<int> >& map_nid_reachable_thru_eids_set) {

    vector<int> list;
    vector<int> stack;
    set<int> visited;

    visited.insert(source_nid);
    map_nid_to_reachable_status[source_nid] = true;
    
    stack.push_back(source_nid);


    while (!stack.empty()) {
        int curr_nid = stack.back();
        stack.pop_back();
        map_nid_to_reachable_status[curr_nid] = true;
        
        if (direction == FORWARD)
            list = graph->get_outlist(curr_nid);
        else if (direction == BACKWARD)
            list = graph->get_inlist(curr_nid);

        
        for (vector<int>::iterator vec_itr = list.begin(); vec_itr != list.end(); vec_itr++) {
            int curr_edge = *vec_itr;
            int curr_tgt_nid;
            if (direction == FORWARD)
                curr_tgt_nid = graph->get_target_node(curr_edge);
            else if (direction == BACKWARD)
                curr_tgt_nid = graph->get_source_node(curr_edge);
            
            
            map_nid_reachable_thru_eids_set[curr_tgt_nid].insert(*vec_itr);
            if (visited.find(curr_tgt_nid) == visited.end()) {
                stack.push_back(curr_tgt_nid);
                visited.insert(curr_tgt_nid);
                
            }
            for (auto i = stack.begin(); i != stack.end(); i++) {
                    map_nid_reachable_thru_eids_set[*i].insert(*vec_itr);
            }
        }
    }

    

}





// does a bfs numbering starting from source - keeps edges with source number < target number

void GraphManagerNew::get_directed_cut(GraphNew * graph, int source_nid, int target_nid, set<int>& mincut_eids, set<int>& directed_cut_eids) {


    // initial bfs from source
    map<int, int> map_nid_to_bfs_index;
    bfs_numbering(graph, source_nid, map_nid_to_bfs_index);

    // set value of target to inf
    //assert(map_nid_to_bfs_index.find(target_nid) != map_nid_to_bfs_index.end());
    if (map_nid_to_bfs_index.find(target_nid) == map_nid_to_bfs_index.end())
        return;
    int target_index_value_backup = map_nid_to_bfs_index[target_nid];
    map_nid_to_bfs_index[target_nid] = inf;

    // filter cut edges
    for (set<int>::iterator mincut_iter = mincut_eids.begin(); mincut_iter != mincut_eids.end(); mincut_iter++) {
        int curr_eid = *mincut_iter;

#ifdef ONLY_INTERAC_EDGES_FOR_MINCUT
        if (NOT_INTERAC_EDGE(graph, curr_eid))
            continue;
#endif 

        int curr_eid_src = graph->get_source_node(curr_eid);
        int curr_eid_tgt = graph->get_target_node(curr_eid);

        if (map_nid_to_bfs_index[curr_eid_src] < map_nid_to_bfs_index[curr_eid_tgt]) {
            //if ((!graph->edge_has_subtype(curr_eid, "dummy_u_to_d")) && (!graph->edge_has_subtype(curr_eid, "dummy_d_to_u"))) {
            if (!graph->edge_has_subtype(curr_eid, "dummy_d_to_u")) {
                directed_cut_eids.insert(curr_eid);
            }
        }
    }

    // restore target index value
    map_nid_to_bfs_index[target_nid] = target_index_value_backup;
}

void GraphManagerNew::bfs_numbering(GraphNew * graph, int source_nid, map<int, int>& map_nid_to_bfs_index) {
    int index = 1;
    list<int> queue;
    set<int> visited;

    queue.push_back(source_nid);
    visited.insert(source_nid);

    map_nid_to_bfs_index.insert(pair<int, int>(source_nid, index));
    index++;

    while (!queue.empty()) {
        int curr_source = queue.front();
        queue.pop_front();

        vector<int> out_list = graph->get_outlist(curr_source);

        for (vector<int>::iterator edge_itr = out_list.begin(); edge_itr != out_list.end(); edge_itr++) {
            int curr_target = graph->get_target_node(*edge_itr);

            if (visited.find(curr_target) == visited.end()) {
                queue.push_back(curr_target);
                visited.insert(curr_target);

                map_nid_to_bfs_index.insert(pair<int, int>(curr_target, index));
                index++;

            }
        }

    }
}

void GraphManagerNew::dfs_numbering(GraphNew * graph, int source_nid, map<int, int>& map_nid_to_dfs_index) {
    int index = 1;
    vector<int> stack;
    set<int> visited;

    visited.insert(source_nid);
    map_nid_to_dfs_index.insert(pair<int, int>(source_nid, index));
    index++;
    stack.push_back(source_nid);


    while (!stack.empty()) {
        int curr_nid = stack.back();
        stack.pop_back();
        //cout << "index: " << index << " nid: " << curr_nid << endl;
        map_nid_to_dfs_index.insert(pair<int, int>(curr_nid, index));
        index++;

        vector<int> outlist = graph->get_outlist(curr_nid);
        for (vector<int>::iterator vec_itr = outlist.begin(); vec_itr != outlist.end(); vec_itr++) {
            int curr_tgt_nid = graph->get_target_node(*vec_itr);
            if (visited.find(curr_tgt_nid) == visited.end()) {
                stack.push_back(curr_tgt_nid);
                visited.insert(curr_tgt_nid);

            }
        }
    }

//    for (map<int, int>::iterator map_itr = map_nid_to_dfs_index.begin(); map_itr != map_nid_to_dfs_index.end(); map_itr++) {
//        cout << (*map_itr).first << "--" << (*map_itr).second << endl;
//    }

}

void GraphManagerNew::connect_with_dfs_numbering(GraphNew * graph, set<int>& present_edges, vector <set<int> >& fwd_cut_edges, vector <set<int> >& bkd_cut_edges, vector<int>& gomoryhu_parents, int source_nid, int target_nid, map<int, int>& map_nid_to_dfs_index, ofstream& outfile) {

    int node_u_in_tree;
    int is_src_side;
    //set<int> curr_min_cut = getMinCutEdges(graph, cut_edges, gomoryhu_parents, GET_NODE_SEQ_NUM(graph, source_nid), GET_NODE_SEQ_NUM(graph, target_nid), node_u_in_tree, is_src_side, outfile);
    set<int> curr_min_cut = getMinCutEdges_directed(graph, fwd_cut_edges, bkd_cut_edges, gomoryhu_parents, GET_NODE_SEQ_NUM(graph, source_nid), GET_NODE_SEQ_NUM(graph, target_nid), node_u_in_tree, is_src_side, outfile);

    set<int>::iterator set_itr;

    int source_index = map_nid_to_dfs_index[source_nid];
    int target_index = map_nid_to_dfs_index[target_nid];
    cout << "Current min cut contains edges:" << endl;
    for (set_itr = curr_min_cut.begin(); set_itr != curr_min_cut.end(); set_itr++) {
        // filtering out min cut edges based on dfs numbering
        int curr_src_index = map_nid_to_dfs_index[graph->get_source_node(*set_itr)];
        int curr_tgt_index = map_nid_to_dfs_index[graph->get_target_node(*set_itr)];
        if ((curr_src_index >= source_index) && (curr_tgt_index <= target_index)) {
            cout << (*set_itr) << endl;
        }
    }
    cout << endl;



    cout << "Choose an edge:" << endl;
    int chosen_edge_id;
    cin >> chosen_edge_id;
    EdgeNew * chosen_edge = graph->get_edge_from_eid(chosen_edge_id);
    present_edges.insert(chosen_edge->get_edge_id());


    if (source_nid != chosen_edge->get_source())
        connect_with_dfs_numbering(graph, present_edges, fwd_cut_edges, bkd_cut_edges, gomoryhu_parents, source_nid, chosen_edge->get_source(), map_nid_to_dfs_index, outfile);
    //connect(graph, present_edges, minCutMatrix, source_nid, chosen_edge->get_source());

    if (target_nid != chosen_edge->get_target())
        connect_with_dfs_numbering(graph, present_edges, fwd_cut_edges, bkd_cut_edges, gomoryhu_parents, chosen_edge->get_target(), target_nid, map_nid_to_dfs_index, outfile);
    //connect(graph, present_edges, minCutMatrix, chosen_edge->get_target(), target_nid);    
}

void GraphManagerNew::disconnect(GraphNew * graph, GraphNew * ghtree, int src_nid, int tgt_nid, set<int>& set_S, set<int>& set_T, set<int>& set_W,
        set<int>& present_edges, vector <set<int> >& cut_edges, vector<int>& gomoryhu_parents) {


    int src_nid_in_ghtree = ghtree->get_nid_from_rep_id(ghtree->get_rep_id_from_id(graph->get_rep_id_from_nid(src_nid)));

    set<int> selected_gh_edges;


    // set intersection of S and T
    set<int> S_union_T;
    set_union(set_S.begin(), set_S.end(), set_T.begin(), set_T.end(), inserter(S_union_T, S_union_T.begin()));

    // BFS loop
    list<int> BFS_queue;
    set<int> visited_nodes;
    BFS_queue.push_back(src_nid_in_ghtree);
    while (!BFS_queue.empty()) {

        int src_nid_in_ghtree = BFS_queue.front();
        visited_nodes.insert(src_nid_in_ghtree);
        BFS_queue.pop_front();

        vector<int> outlist = ghtree->get_outlist(src_nid_in_ghtree);
        for (vector<int>::iterator out_itr = outlist.begin(); out_itr != outlist.end(); out_itr++) {
            int tgt_nid_in_ghtree = ghtree->get_target_node(*out_itr);

            // if current node is on the S side
            if (set_S.find(src_nid_in_ghtree) != set_S.end()) {
                // if node is in W, mark GH edge and do not proceed from that node
                if (set_W.find(tgt_nid_in_ghtree) != set_W.end()) {
                    selected_gh_edges.insert(*out_itr);
                }                    // else if node is in T, mark GH edge and proceed
                else if (set_T.find(tgt_nid_in_ghtree) != set_T.end()) {
                    selected_gh_edges.insert(*out_itr);
                    if (visited_nodes.find(tgt_nid_in_ghtree) == visited_nodes.end()) {
                        BFS_queue.push_back(tgt_nid_in_ghtree);
                    }
                }                    // else, add node to set S and proceed
                else if (set_S.find(tgt_nid_in_ghtree) == set_S.end()) {
                    set_S.insert(tgt_nid_in_ghtree);
                    if (visited_nodes.find(tgt_nid_in_ghtree) == visited_nodes.end()) {
                        BFS_queue.push_back(tgt_nid_in_ghtree);
                    }
                } else
                    continue;
            }                // if current node is on T side
            else if (set_T.find(src_nid_in_ghtree) != set_T.end()) {
                // if node is in W, mark GH edge and do not proceed from that node
                if (set_W.find(tgt_nid_in_ghtree) != set_W.end()) {
                    selected_gh_edges.insert(*out_itr);
                }                    // else if node is in T, mark GH edge and proceed
                else if (set_S.find(tgt_nid_in_ghtree) != set_S.end()) {
                    selected_gh_edges.insert(*out_itr);
                    if (visited_nodes.find(tgt_nid_in_ghtree) == visited_nodes.end()) {
                        BFS_queue.push_back(tgt_nid_in_ghtree);
                    }
                }                    // else, add node to set S and proceed
                else if (set_T.find(tgt_nid_in_ghtree) == set_T.end()) {
                    set_T.insert(tgt_nid_in_ghtree);
                    if (visited_nodes.find(tgt_nid_in_ghtree) == visited_nodes.end()) {
                        BFS_queue.push_back(tgt_nid_in_ghtree);
                    }
                } else
                    continue;
            } else // target node neither in S nor in T
                continue;

        }
    }

    assert(visited_nodes.size() == S_union_T.size());

    vector<int> eids_in_select_gh_edges;
    set<int> temp_set;

    // get cut edges from flagged GH tree edges
    for (set<int>::iterator set_itr = selected_gh_edges.begin(); set_itr != selected_gh_edges.end(); set_itr++) {
        int src_nid_in_graph = ghtree->get_source_node(*set_itr);
        int tgt_nid_in_graph = ghtree->get_target_node(*set_itr);

        set<int> eids_from_gh_edge = my_getMinCutEdges(graph, cut_edges, gomoryhu_parents, src_nid_in_graph, tgt_nid_in_graph);
        for (set<int>::iterator set_itr2 = eids_from_gh_edge.begin(); set_itr2 != eids_from_gh_edge.end(); set_itr2++) {
            eids_in_select_gh_edges.push_back(*set_itr2);
            temp_set.insert(*set_itr2);
        }

    }


    // remove duplicates in cut edges
    vector<int> cut_edges_in_graph;
    for (set<int>::iterator set_itr = temp_set.begin(); set_itr != temp_set.end(); set_itr++) {
        if (std::count(eids_in_select_gh_edges.begin(), eids_in_select_gh_edges.end(), *set_itr) <= 1) {
            cut_edges_in_graph.push_back(*set_itr);
        }
    }


    // BFS avoiding cut edges

}

void GraphManagerNew::disconnect2(GraphNew * graph, GraphNew * ghtree, set<int>& set_S, set<int>& set_T,
        set<int>& present_edges, vector <set<int> >& cut_edges, vector<int>& gomoryhu_parents) {


    set<int> selected_gh_edges_S_to_T;
    set<int> selected_gh_edges_T_to_S;

    for (auto itr = set_S.begin(); itr != set_S.end(); itr++) {

        int src_nid_in_ghtree = ghtree->get_nid_from_rep_id(ghtree->get_rep_id_from_id(graph->get_rep_id_from_nid(*itr)));

        // BFS loop
        list<int> BFS_queue;
        set<int> visited_nodes;
        BFS_queue.push_back(src_nid_in_ghtree);

        while (!BFS_queue.empty()) {
            int curr_nid_in_ghtree = BFS_queue.front();
            visited_nodes.insert(curr_nid_in_ghtree);
            BFS_queue.pop_front();

            vector<int> outlist = ghtree->get_outlist(curr_nid_in_ghtree);
            for (auto out_itr = outlist.begin(); out_itr != outlist.end(); out_itr++) {
                int tgt_nid_in_ghtree = ghtree->get_target_node(*out_itr);
                int tgt_nid_in_graph = graph->get_nid_from_rep_id(ghtree->get_rep_id_from_nid(tgt_nid_in_ghtree));
                // if node is in set T, mark gh edge and do not proceed
                if (set_T.find(tgt_nid_in_graph) != set_T.end()) {
                    selected_gh_edges_S_to_T.insert(*out_itr);

                } else { // proceed
                    if (visited_nodes.find(tgt_nid_in_ghtree) == visited_nodes.end()) {
                        BFS_queue.push_back(tgt_nid_in_ghtree);
                    }
                }
            }

        }
    }

    cout << selected_gh_edges_S_to_T.size() << endl;

    for (auto itr = set_T.begin(); itr != set_T.end(); itr++) {

        int src_nid_in_ghtree = ghtree->get_nid_from_rep_id(ghtree->get_rep_id_from_id(graph->get_rep_id_from_nid(*itr)));
        // BFS loop
        list<int> BFS_queue;
        set<int> visited_nodes;
        BFS_queue.push_back(src_nid_in_ghtree);

        while (!BFS_queue.empty()) {
            int curr_nid_in_ghtree = BFS_queue.front();
            visited_nodes.insert(curr_nid_in_ghtree);
            BFS_queue.pop_front();

            vector<int> outlist = ghtree->get_outlist(curr_nid_in_ghtree);
            for (auto out_itr = outlist.begin(); out_itr != outlist.end(); out_itr++) {
                int tgt_nid_in_ghtree = ghtree->get_target_node(*out_itr);
                int tgt_nid_in_graph = graph->get_nid_from_rep_id(ghtree->get_rep_id_from_nid(tgt_nid_in_ghtree));
                // if node is in set T, mark gh edge and do not proceed
                if (set_S.find(tgt_nid_in_graph) != set_S.end()) {
                    selected_gh_edges_T_to_S.insert(*out_itr);

                } else { // proceed
                    if (visited_nodes.find(tgt_nid_in_ghtree) == visited_nodes.end()) {
                        BFS_queue.push_back(tgt_nid_in_ghtree);
                    }
                }
            }

        }
    }

    cout << selected_gh_edges_T_to_S.size() << endl;

    vector<int> eids_in_select_gh_edges;
    set<int> temp_set;

    // get cut edges from flagged GH tree edges
    for (set<int>::iterator set_itr = selected_gh_edges_S_to_T.begin(); set_itr != selected_gh_edges_S_to_T.end(); set_itr++) {
        int src_nid_in_ghtree = ghtree->get_source_node(*set_itr);
        int tgt_nid_in_ghtree = ghtree->get_target_node(*set_itr);
        int src_nid_in_graph = graph->get_nid_from_rep_id(ghtree->get_rep_id_from_nid(src_nid_in_ghtree));
        int tgt_nid_in_graph = graph->get_nid_from_rep_id(ghtree->get_rep_id_from_nid(tgt_nid_in_ghtree));
        int node_u_in_tree; // represents the u of the u-v cut in the GH-tree
        int is_src_side;
        ofstream outfile;
        ostringstream filename;
        filename << static_cast<unsigned long> (::time(0)) << ".dat";
        outfile.open(filename.str());
        set<int> eids_from_gh_edge = getMinCutEdges(graph, cut_edges, gomoryhu_parents, GET_NODE_SEQ_NUM(graph, src_nid_in_graph), GET_NODE_SEQ_NUM(graph, tgt_nid_in_graph), node_u_in_tree, is_src_side, outfile);
        for (set<int>::iterator set_itr2 = eids_from_gh_edge.begin(); set_itr2 != eids_from_gh_edge.end(); set_itr2++) {
            eids_in_select_gh_edges.push_back(*set_itr2);
            temp_set.insert(*set_itr2);
            cout << *set_itr2 << " ";
        }
        cout << endl;

    }
    // remove duplicates in cut edges
    vector<int> cut_edges_in_graph1;
    for (set<int>::iterator set_itr = temp_set.begin(); set_itr != temp_set.end(); set_itr++) {
        if (std::count(eids_in_select_gh_edges.begin(), eids_in_select_gh_edges.end(), *set_itr) <= 1) {
            cut_edges_in_graph1.push_back(*set_itr);
            cout << graph->get_source_node(*set_itr) << " --- " << graph->get_target_node(*set_itr) << endl;
        }
    }

    cout << endl;
    eids_in_select_gh_edges.clear();
    temp_set.clear();

    // get cut edges from flagged GH tree edges
    for (set<int>::iterator set_itr = selected_gh_edges_T_to_S.begin(); set_itr != selected_gh_edges_T_to_S.end(); set_itr++) {
        int src_nid_in_ghtree = ghtree->get_source_node(*set_itr);
        int tgt_nid_in_ghtree = ghtree->get_target_node(*set_itr);
        int src_nid_in_graph = graph->get_nid_from_rep_id(ghtree->get_rep_id_from_nid(src_nid_in_ghtree));
        int tgt_nid_in_graph = graph->get_nid_from_rep_id(ghtree->get_rep_id_from_nid(tgt_nid_in_ghtree));
        int node_u_in_tree; // represents the u of the u-v cut in the GH-tree
        int is_src_side;
        ofstream outfile;
        ostringstream filename;
        filename << static_cast<unsigned long> (::time(0)) << ".dat";
        outfile.open(filename.str());
        set<int> eids_from_gh_edge = getMinCutEdges(graph, cut_edges, gomoryhu_parents, GET_NODE_SEQ_NUM(graph, src_nid_in_graph), GET_NODE_SEQ_NUM(graph, tgt_nid_in_graph), node_u_in_tree, is_src_side, outfile);
        for (set<int>::iterator set_itr2 = eids_from_gh_edge.begin(); set_itr2 != eids_from_gh_edge.end(); set_itr2++) {
            eids_in_select_gh_edges.push_back(*set_itr2);
            temp_set.insert(*set_itr2);
            cout << *set_itr2 << " ";
        }
        cout << endl;

    }
    // remove duplicates in cut edges
    vector<int> cut_edges_in_graph2;
    for (set<int>::iterator set_itr = temp_set.begin(); set_itr != temp_set.end(); set_itr++) {
        if (std::count(eids_in_select_gh_edges.begin(), eids_in_select_gh_edges.end(), *set_itr) <= 1) {
            cut_edges_in_graph2.push_back(*set_itr);
            cout << graph->get_source_node(*set_itr) << " ---- " << graph->get_target_node(*set_itr) << endl;
        }
    }

    if (cut_edges_in_graph1.size() <= cut_edges_in_graph2.size()) {

    }
}


//returns id of the newly constructed reachability graph otherwise returns -1

int GraphManagerNew::bounded_reach(int gid, int direction, vector<string>& source_nodes_set, vector<string>& excluded_nodes_set, int bound) {
    int new_gid = -1;

    GraphNew* graph = get_graph(gid);
    if (graph == NULL) {
        cerr << "Error: there is no graph for id " << gid << endl;
        return -1;
    }
    if (bound < 0) {
        cerr << "Error: bound is " << bound << "(negative value), can't do reachability with negative bounds" << endl;
        return -1;
    }

    if (direction != FORWARD && direction != BACKWARD && direction != FORWARD_BACKWARD) {
        cerr << "Error: incorrect direction entry" << endl;
        return -1;
    }

    std::vector<int> source_node_ids, excluded_node_ids;

    std::vector<std::string>::iterator vec_str_itr;

    for (vec_str_itr = source_nodes_set.begin(); vec_str_itr != source_nodes_set.end(); vec_str_itr++) {
        string rid = graph->get_rep_id_from_id(*vec_str_itr);
        if (rid == "") {
            cerr << "Error: one of the source nodes " + *vec_str_itr << " has no rep id in the graph" << endl;
            continue;
        }
        int nid = graph->get_nid_from_rep_id(rid);
        if (nid == -1) {
            cerr << "Error: one of the source nodes " + *vec_str_itr << " has a rep id but no node id for it in the graph.\n"; // You have left a bug in the code -- fix it" << endl;
            continue;
        }
        source_node_ids.push_back(nid);
    }

    for (vec_str_itr = excluded_nodes_set.begin(); vec_str_itr != excluded_nodes_set.end(); vec_str_itr++) {
        string rid = graph->get_rep_id_from_id(*vec_str_itr);
        if (rid == "") {
            cerr << "Error: one of the excluded nodes " + *vec_str_itr << " has no rep id in the graph" << endl;
            continue;
        }
        int nid = graph->get_nid_from_rep_id(rid);
        if (nid == -1) {
            cerr << "Error: one of the excluded nodes " + *vec_str_itr << " has a rep id but no node id for it in the graph.\n"; // You have made a bug in the code -- fix it" << endl;
            continue;
        }
        excluded_node_ids.push_back(nid);
    }

    //new id for the new graph
    GraphNew* graph_ptr = new GraphNew;
    new_gid = ++GraphManagerNew::graph_id_count;
    graph_ptr->set_graph_id(new_gid);
    add_graph(new_gid, graph_ptr);

    // populate adjacency matrix
    //fill_adj_matrix_for_graph(graph_ptr);
    
    //maintain a BFSish queue of nodes
    std::list<int> BFS_queue;

    //testing remove later:
    ofstream fout("rch_test");

    //maintain a set of visited nodes for reachability from source nodes
    set<int> visited_nodes;
    //maintain min distances of all nodes in the graph from source nodes (all initialized to max value of int but source nodes themselves set to 0)
    map<int, int> distances_from_source;
    vector<int> NIDSg = graph->get_node_ids();

    for (vector<int>::iterator node_itr = NIDSg.begin(); node_itr != NIDSg.end(); node_itr++) {
        distances_from_source[*node_itr] = std::numeric_limits<int>::max();
        //distances_from_source[*node_itr] = -1;
    }

    for (vector<int>::iterator source_node_itr = source_node_ids.begin(); source_node_itr != source_node_ids.end(); source_node_itr++) {
        //reach begins from source node if source node is not in the exclude list
        if (find(excluded_node_ids.begin(), excluded_node_ids.end(), *source_node_itr) == excluded_node_ids.end()) {


            distances_from_source[*source_node_itr] = 0;
            BFS_queue.push_back(*source_node_itr);
        }
    }

    string filename;
    
    if (direction == FORWARD)
        filename = "bound_rch_fwd";
    else
        filename = "bound_rch_bkwd";
    
    ofstream ffout(filename.c_str());
    
    
    int loop_count = 0;
    //the BFSish loop based on queue emptiness
    while (!BFS_queue.empty()) {
#ifdef DEBUG_FLAG
        fout << "Queue size: " << BFS_queue.size() << endl;
#endif
        int nid = BFS_queue.front();
        visited_nodes.insert(nid);
        BFS_queue.pop_front();

        
        ffout << endl << loop_count << ": " << nid << "(" << graph->get_rep_id_from_nid(nid) << "): ";
        loop_count++;
        string rid = graph->get_rep_id_from_nid(nid);
        int nid_new = graph_ptr->get_nid_from_rep_id(rid);

        //if the reachability graph already has a node corresponding to this rid then there is no need to create such a node
        //o/w duplicate this node into the new graph
        if (nid_new == -1) {
            //#ifdef DUP_CHECK_FLAG_SET
            //            nid_new = duplicate_node(graph_ptr, graph, nid, false);
            //#else
            //            nid_new = duplicate_node(graph_ptr, graph, nid);
            //#endif                                     
            nid_new = duplicate_node(graph_ptr, graph, nid, false);

        }

        vector<int> edge_list_in, edge_list_out;
        edge_list_in = graph->get_inlist(nid);

        edge_list_out = graph->get_outlist(nid);

        if (direction == FORWARD || direction == FORWARD_BACKWARD) {
            for (vector<int>::iterator edge_itr = edge_list_out.begin(); edge_itr != edge_list_out.end(); ++edge_itr) {

#ifdef ONLY_INTERAC_EDGES_FOR_MINCUT
                if (NOT_INTERAC_EDGE(graph, *edge_itr))
                    continue;
#endif                

                int target_node = graph->get_target_node(*edge_itr);
                //if the target node in the outlist edges is not to be excluded and is not already visisted
                if (find(excluded_node_ids.begin(), excluded_node_ids.end(), target_node) == excluded_node_ids.end()) {
                    /*int temp_distance = distances_from_source[nid]+1;
                      int old_distance = distances_from_source[target_node];
                      int new_distance = min(temp_distance, old_distance);
                      distances_from_source[target_node] = new_distance;*/


                    int new_distance = distances_from_source[nid] + 1;
                    int old_distance = distances_from_source[target_node];
                    distances_from_source[target_node] = min(new_distance, old_distance);
#ifdef DEBUG_FLAG
                    fout << "Distance: " << new_distance << ", node: " << graph->get_rep_id_from_nid(target_node) << endl;
#endif

                    // ---- ignore inhibition edges in the first two steps from source
                    // ---- added by sukanya on 13 May 2017
//                    if ( (graph->edge_has_subtype(*edge_itr, "inhibition") || (graph->edge_has_subtype(*edge_itr, "repression")) ) && new_distance <= bound)
//                        continue;                    
                    // ----
                    
                    
                    
                    //if(new_distance <= bound){
                    if (old_distance == std::numeric_limits<int>::max() && new_distance <= bound) {
                        //if(visited_nodes.find(target_node) == visited_nodes.end() && find(BFS_queue.begin(), BFS_queue.end(), target_node) == BFS_queue.end()){//if not visited and not already in the queue push it
                        BFS_queue.push_back(target_node);
                        ffout << target_node << " ";
                        //}
                    }

                    /*if(visited_nodes.find(target_node) == visited_nodes.end()){//if not visited
                      BFS_queue.push_back(target_node);
                      }*/
                    if (distances_from_source[target_node] <= bound) {

                        //#ifdef DUP_CHECK_FLAG_SET
                        //                        duplicate_edge(graph_ptr, graph, *edge_itr, false);
                        //#else
                        //                        duplicate_edge(graph_ptr, graph, *edge_itr);
                        //#endif                                                                 
                        duplicate_edge(graph_ptr, graph, *edge_itr);





                        //#ifdef ASSOC_DISSOC_EDGE_COPY_FLAG_SET                                                                 
                        //                        //handle association/dissociation edges
                        //                        bool is_assoc = false, is_dissoc = false;
                        //                        /*if(graph_ptr->edge_has_subtype(*edge_itr, "association")){
                        //                                is_assoc = true;
                        //                        }
                        //                        if(graph_ptr->edge_has_subtype(*edge_itr, "dissociation")){
                        //                                is_dissoc = true;
                        //                        }*/
                        //                        if (graph->edge_has_subtype(*edge_itr, "association")) {
                        //                            is_assoc = true;
                        //                        }
                        //                        if (graph->edge_has_subtype(*edge_itr, "dissociation")) {
                        //                            is_dissoc = true;
                        //                        }
                        //                        if (is_assoc || is_dissoc) {
                        //
                        //                            //get the edge id for the opposite edge (undirected edge modeled as two directed edges in opposite directions)
                        //                            //vector<int> outlist_target_node = graph_ptr->get_outlist(target_node);
                        //                            vector<int> outlist_target_node = graph->get_outlist(target_node);
                        //                            int call_count = 0;
                        //                            for (vector<int>::iterator out_itr = outlist_target_node.begin(); out_itr != outlist_target_node.end(); ++out_itr) {
                        //                                /*if(graph_ptr->get_target_node(*out_itr) == nid && (graph_ptr->edge_has_subtype(*out_itr, "association")||graph_ptr->edge_has_subtype(*out_itr, "dissociation"))){
                        //                                        duplicate_edge(graph_ptr, graph, *out_itr);
                        //                                }*/
                        //                                if (graph->get_target_node(*out_itr) == nid && (graph->edge_has_subtype(*out_itr, "association") || graph->edge_has_subtype(*out_itr, "dissociation"))) {
                        ////#ifdef DUP_CHECK_FLAG_SET
                        ////                                    duplicate_edge(graph_ptr, graph, *out_itr, false);
                        ////#else
                        ////                                    duplicate_edge(graph_ptr, graph, *out_itr);
                        ////#endif
                        //                                        duplicate_edge(graph_ptr, graph, *out_itr);
                        //                                        call_count++;
                        //                                }
                        //                            }
                        //#ifdef ASSERT_FLAG 
                        //                            cout << "Calls to duplicate edge: " << call_count << endl;
                        //                            assert (call_count == 1);
                        //#endif
                        //                        }
                        //
                        //                            
                        //#endif                                                                 
                    }
                }
            }
        }

        if (direction == BACKWARD || direction == FORWARD_BACKWARD) {
            for (vector<int>::iterator edge_itr = edge_list_in.begin(); edge_itr != edge_list_in.end(); ++edge_itr) {

#ifdef ONLY_INTERAC_EDGES_FOR_MINCUT
                if (NOT_INTERAC_EDGE(graph, *edge_itr))
                    continue;
#endif                 

                int local_source_node = graph->get_source_node(*edge_itr);
                if (find(excluded_node_ids.begin(), excluded_node_ids.end(), local_source_node) == excluded_node_ids.end()) {
                    /*int temp_distance = distances_from_source[nid]+1;
                      int old_distance = distances_from_source[local_source_node];
                      int new_distance = min(temp_distance, old_distance);
                      distances_from_source[local_source_node] = new_distance;*/

                    int new_distance = distances_from_source[nid] + 1;
                    int old_distance = distances_from_source[local_source_node];
                    distances_from_source[local_source_node] = min(new_distance, old_distance);

                    //if(new_distance <= bound){
                    if (old_distance == std::numeric_limits<int>::max() && new_distance <= bound) {
                        //if(visited_nodes.find(local_source_node) == visited_nodes.end() && find(BFS_queue.begin(), BFS_queue.end(), local_source_node) == BFS_queue.end()){//if not visited and not already in the queue push it
                        BFS_queue.push_back(local_source_node);
                        ffout << local_source_node << "(" << graph->get_rep_id_from_nid(local_source_node) << "): ";
                        //}
                    }
                    /*if(visited_nodes.find(local_source_node) == visited_nodes.end()){//if not visited
                      BFS_queue.push_back(local_source_node);
                      }*/

                    if (distances_from_source[local_source_node] <= bound) {
                        //#ifdef DUP_CHECK_FLAG_SET
                        //                        duplicate_edge(graph_ptr, graph, *edge_itr, false);
                        //#else
                        //                        duplicate_edge(graph_ptr, graph, *edge_itr);
                        //#endif								 
                        duplicate_edge(graph_ptr, graph, *edge_itr);
                        //#ifdef ASSOC_DISSOC_EDGE_COPY_FLAG_SET
                        //                        //handle undirected edges
                        //                        bool is_assoc, is_dissoc;
                        //                        /*if(graph_ptr->edge_has_subtype(*edge_itr, "association")){
                        //                                is_assoc = true;
                        //                        }
                        //                        if(graph_ptr->edge_has_subtype(*edge_itr, "dissociation")){
                        //                                is_dissoc = true;
                        //                        }*/
                        //                        if (graph->edge_has_subtype(*edge_itr, "association")) {
                        //                            is_assoc = true;
                        //                        }
                        //                        if (graph->edge_has_subtype(*edge_itr, "dissociation")) {
                        //                            is_dissoc = true;
                        //                        }
                        //                        if (is_assoc || is_dissoc) {
                        //                            //get the edge id for the opposite edge (undirected edge modeled as two directed edges in posite directions)
                        //                            //vector<int> inlist_local_source_node = graph_ptr->get_inlist(local_source_node);
                        //                            vector<int> inlist_local_source_node = graph->get_inlist(local_source_node);
                        //                            for (vector<int>::iterator in_itr = inlist_local_source_node.begin(); in_itr != inlist_local_source_node.end(); ++in_itr) {
                        //                                /*if(graph_ptr->get_source_node(*in_itr) == nid && (graph_ptr->edge_has_subtype(*in_itr, "association")||graph_ptr->edge_has_subtype(*in_itr, "dissociation"))){
                        //                                        duplicate_edge(graph_ptr, graph, *in_itr);
                        //                                }*/
                        //                                if (graph->get_source_node(*in_itr) == nid && (graph->edge_has_subtype(*in_itr, "association") || graph->edge_has_subtype(*in_itr, "dissociation"))) {
                        //
                        ////#ifdef DUP_CHECK_FLAG_SET
                        ////                                    duplicate_edge(graph_ptr, graph, *in_itr, false);
                        ////#else
                        ////                                    duplicate_edge(graph_ptr, graph, *in_itr);
                        ////#endif                                                                                     
                        //                                        duplicate_edge(graph_ptr, graph, *in_itr);
                        //
                        //                                }
                        //                            }
                        //                        }
                        //#endif
                    }
                }
            }
        }
        
        
    }

#ifdef REMOVE_CYCLE_FLAG
    if (direction == FORWARD) {
        char input_rm_cycles;
        cout << "Do you want to remove cycles in the reachable graph?" << endl;
        cout << "Enter 'y' or 'Y' for yes, any other key for no: ";
        cin >> input_rm_cycles;
        if (input_rm_cycles == 'y' || input_rm_cycles == 'Y') {
            set<int> edges_to_remove = graph_ptr->edges_to_remove_cycles(source_nodes_set);

            for (set<int>::iterator rm_edge_itr = edges_to_remove.begin(); rm_edge_itr != edges_to_remove.end(); ++rm_edge_itr) {
                //cout << graph_ptr->get_rep_id_from_nid(graph_ptr->get_source_node(*rm_edge_itr)) << "==>" << graph_ptr->get_rep_id_from_nid(graph_ptr->get_target_node(*rm_edge_itr)) << endl;
                graph_ptr->remove_edge(*rm_edge_itr);
                edge_id_to_graph_id.erase(*rm_edge_itr);
            }
        }
    } else if (direction == BACKWARD) {
        char output_rm_cycles;
        cout << "Do you want to remove cycles in the reachable graph?" << endl;
        cout << "Enter 'y' or 'Y' for yes, any other key for no: ";
        cin >> output_rm_cycles;
        if (output_rm_cycles == 'y' || output_rm_cycles == 'Y') {
            set<int> edges_to_remove = graph_ptr->edges_to_remove_cycles_backwards(source_nodes_set);

            for (set<int>::iterator rm_edge_itr = edges_to_remove.begin(); rm_edge_itr != edges_to_remove.end(); ++rm_edge_itr) {
                //cout << graph_ptr->get_rep_id_from_nid(graph_ptr->get_source_node(*rm_edge_itr)) << "==>" << graph_ptr->get_rep_id_from_nid(graph_ptr->get_target_node(*rm_edge_itr)) << endl;
                graph_ptr->remove_edge(*rm_edge_itr);
                edge_id_to_graph_id.erase(*rm_edge_itr);
            }
        }
    }
#endif
    // add component edges from components to complexes
    // adding these edges again these should not depend on reachability bound
    ////graph_ptr->add_component_edges_for_complexes(this);

    //for genesis:
    stringstream ss;
    ss << bound;
    string direction_str;
    if (direction == FORWARD) {
        direction_str = "FORWARD";
    } else if (direction == BACKWARD) {
        direction_str = "BACKWARD";
    }
    if (direction == FORWARD_BACKWARD) {
        direction_str = "UNDIRECTED";
    }

    string source_nodes_str = ", source nodes :";
    for (vector<string>::iterator itr = source_nodes_set.begin(); itr != source_nodes_set.end(); ++itr) {
        source_nodes_str += " " + *itr;
    }

    string excluded_nodes_str = ", excluded nodes :";
    for (vector<string>::iterator itr = excluded_nodes_set.begin(); itr != excluded_nodes_set.end(); ++itr) {
        excluded_nodes_str += " " + *itr;
    }

    string oper = "bounded reach: bound = " + ss.str() + ", direction = " + direction_str + source_nodes_str + excluded_nodes_str;
    list<int> empty_list;
    empty_list.push_back(gid);
    add_graph_genesis(new_gid, oper, empty_list);
    return new_gid;
}


 int GraphManagerNew::bounded_forward_backward_reach(int gid, set<string>& source_nodes_set, set<string>& target_nodes_set, set<string>& excluded_nodes_set, int bound, int target_act_expr_flag) {
    int new_gid = -1;

    GraphNew* graph = get_graph(gid);
    if (graph == NULL) {
        cerr << "Error: there is no graph for id " << gid << endl;
        return -1;
    }
    if (bound < 0) {
        cerr << "Error: bound " << bound << " is invalid" << endl;
        return -1;
    }

    
    vector<int> source_node_nids, target_node_nids, excluded_node_nids;

    set<string>::iterator set_str_itr;

    for (set_str_itr = source_nodes_set.begin(); set_str_itr != source_nodes_set.end(); set_str_itr++) {
        string curr_node_id = *set_str_itr;
        string repid = graph->get_rep_id_from_id(curr_node_id);
        if (repid == "") {
            cerr << "Source node " << curr_node_id << " has no rep id in graph " << gid << ". Ignoring." << endl;
            continue;
        }
        int nid = graph->get_nid_from_rep_id(repid);
        assert (nid > 0);
        
        source_node_nids.push_back(nid);
    }

    for (set_str_itr = target_nodes_set.begin(); set_str_itr != target_nodes_set.end(); set_str_itr++) {
        string curr_node_id = *set_str_itr;
        string repid = graph->get_rep_id_from_id(curr_node_id);
        if (repid == "") {
            cerr << "Target node " << curr_node_id << " has no rep id in graph " << gid << ". Ignoring." << endl;
            continue;
        }
        int nid = graph->get_nid_from_rep_id(repid);
        assert (nid > 0);
        
        target_node_nids.push_back(nid);
    }
    
    for (set_str_itr = excluded_nodes_set.begin(); set_str_itr != excluded_nodes_set.end(); set_str_itr++) {
        string curr_node_id = *set_str_itr;
        string repid = graph->get_rep_id_from_id(curr_node_id);
        if (repid == "") {
            cerr << "Excluded node " << curr_node_id << " has no rep id in graph " << gid << ". Ignoring exclusion"<< endl;
            continue;
        }
        int nid = graph->get_nid_from_rep_id(repid);
        assert (nid > 0);
        
        excluded_node_nids.push_back(nid);
        
        
    }
    
    

    //new id for the new forward reachable graph
    GraphNew* new_fwd_rch_graph = new GraphNew;
    int new_fwd_gid = ++GraphManagerNew::graph_id_count;
    new_fwd_rch_graph->set_graph_id(new_fwd_gid);
    add_graph(new_fwd_gid, new_fwd_rch_graph);
    
    
    list<int> BFS_queue;
    
    set<int> nodes_retained_from_fwd_pass;
    set<int> nodes_retained_from_bkwd_pass;
    
    map<int, int> distances_from_source;
    map<int, int> distances_from_target;
    vector<int> graph_nids = graph->get_node_ids();

    // initialize distance from source of all nids to inf
    for (vector<int>::iterator node_itr = graph_nids.begin(); node_itr != graph_nids.end(); node_itr++) {
        distances_from_source[*node_itr] = inf;
    }
    
    // initialize distance from source of source to 0
    for (vector<int>::iterator source_node_itr = source_node_nids.begin(); source_node_itr != source_node_nids.end(); source_node_itr++) {
        int curr_src_nid = *source_node_itr;
        if (find(excluded_node_nids.begin(), excluded_node_nids.end(), curr_src_nid) == excluded_node_nids.end()) {
            
            distances_from_source[curr_src_nid] = 0;
            assert (curr_src_nid > 0);
            BFS_queue.push_back(curr_src_nid);
        }
    }
    
    ofstream fout("fb_rch");
    int loop_count = 0;
    // forward numbering of nodes

    int edges_to_target = 0, edges_to_target_excluded = 0;
	
    while (!BFS_queue.empty()) {
        int nid = BFS_queue.front();
        fout << endl << loop_count << ": " << nid << ": ";
        loop_count++;
        
        nodes_retained_from_fwd_pass.insert(nid);
        BFS_queue.pop_front();

        
//        if (distances_from_source[nid] == bound) {
//            continue;
//        }
        
        vector<int> outlist = graph->get_outlist(nid);
        
        for (auto out_edge_iter = outlist.begin(); out_edge_iter != outlist.end(); out_edge_iter++) {
            
#ifdef ONLY_INTERAC_EDGES_FOR_MINCUT
            if (NOT_INTERAC_EDGE(graph, *out_edge_iter))
                continue;
#endif
            int curr_target_nid = graph->get_target_node(*out_edge_iter);
	    
	    // Added by Supratik and Akshay: June 8, 2019
	    if (std::find(target_node_nids.begin(), target_node_nids.end(), curr_target_nid) != target_node_nids.end()) {
	      std::vector<std::string> edge_subt_vec = graph->get_edge_subtypes_of_edge(*out_edge_iter);
	      // cout << "Found ";
	      // for (auto subt_str = edge_subt_vec.begin(); subt_str != edge_subt_vec.end(); subt_str++) {
	      // 	cout << *subt_str << " ";
	      // }
	      // cout << "edge to target.";

	      edges_to_target++;
	      
	      if (((target_act_expr_flag == 1) && // exclude "expression"/"repression"`
		   EDGE_IS_EXPR_REPR(graph, (*out_edge_iter))) ||
		  ((target_act_expr_flag == 2) && // exclude "activation"/"inhibition"/"phosporylation"
		   EDGE_IS_ACT_INH_PHOS(graph, (*out_edge_iter)))) {
		
		// cout << "(exlcuded)" << endl;
		edges_to_target_excluded++;
		continue;
	      }
	      // else
	      // 	cout << endl;
	    }

	    
            if (find(excluded_node_nids.begin(), excluded_node_nids.end(), curr_target_nid) == excluded_node_nids.end()) {
                int new_distance = distances_from_source[nid] + 1;
                int curr_distance = distances_from_source[curr_target_nid];
                distances_from_source[curr_target_nid] = min(new_distance, curr_distance);

                if ((distances_from_source[curr_target_nid] <= bound) && (std::find(BFS_queue.begin(), BFS_queue.end(), curr_target_nid) == BFS_queue.end()) && (nodes_retained_from_fwd_pass.find(curr_target_nid) == nodes_retained_from_fwd_pass.end())) {
                    assert (curr_target_nid > 0);
                    BFS_queue.push_back(curr_target_nid);
                    fout << curr_target_nid << "(" << graph->get_rep_id_from_nid(curr_target_nid) << "): ";
                }
            }
        }
        
        
    }
    
    assert (BFS_queue.empty());

    cout << edges_to_target_excluded << " out of " << edges_to_target << " edges to target excluded due to choice of activation/expression edges to target." << endl;
    if (edges_to_target_excluded == edges_to_target) {
      cerr << "All edges to target excluded due to choice of activation/expression edges to target.  Cannot reach target." << endl;
      return -1;
    }
    
    // nodes to_retain in forward pass
    set<int> nodes_to_retain_in_fwd_pass;
    vector<int> nids = graph->get_node_ids();
    
//    for (auto nid_iter = nids.begin(); nid_iter != nids.end(); nid_iter++) {
    for (auto nid_iter = nodes_retained_from_fwd_pass.begin(); nid_iter != nodes_retained_from_fwd_pass.end(); nid_iter++) {
        int curr_nid = *nid_iter;
        if (distances_from_source[curr_nid] <= bound) {
            nodes_to_retain_in_fwd_pass.insert(curr_nid);
        }
    }
    cout << "fwd nodes " << nodes_to_retain_in_fwd_pass.size() << endl;
    // edges to retain in forward pass
    set<int> edges_to_retain_in_fwd_pass;
    vector<int> eids = graph->get_edge_ids();
    cout << "eids " << eids.size() << endl;
    for (auto eid_iter = eids.begin(); eid_iter != eids.end(); eid_iter++) {
        int curr_eid = *eid_iter;
        int eid_src = graph->get_source_node(curr_eid);
        int eid_tgt = graph->get_target_node(curr_eid);
        if (nodes_to_retain_in_fwd_pass.find(eid_src) == nodes_to_retain_in_fwd_pass.end())
            continue;
        if (nodes_to_retain_in_fwd_pass.find(eid_tgt) == nodes_to_retain_in_fwd_pass.end())
            continue;

#ifdef ONLY_INTERAC_EDGES_FOR_MINCUT
            if (NOT_INTERAC_EDGE(graph, curr_eid))
                continue;
#endif

	    // Added by Supratik and Akshay: June 8, 2019
	    if (std::find(target_node_nids.begin(), target_node_nids.end(), eid_tgt) != target_node_nids.end()) {
	      if (((target_act_expr_flag == 1) && // exclude "expression"/"repression"`
		   EDGE_IS_EXPR_REPR(graph, curr_eid)) ||
		  ((target_act_expr_flag == 2) && // exclude "activation"/"inhibition"/"phosporylation"
		   EDGE_IS_ACT_INH_PHOS(graph, curr_eid))) {
		continue;
	      }
	    }
		
	
        edges_to_retain_in_fwd_pass.insert(curr_eid);
        
        
        
    }
    // create forward graph
    
    cout << "edges " << edges_to_retain_in_fwd_pass.size() << endl;
    for (auto e = edges_to_retain_in_fwd_pass.begin(); e != edges_to_retain_in_fwd_pass.end(); e++) {

      // Commented out by Supratik and Akshay: June 8, 2019
      // Because we have already inserted the check when edges_to_retain_in_fwd_pass is
      // populated
      //
      // #ifdef ONLY_INTERAC_EDGES_FOR_MINCUT
      //         if (NOT_INTERAC_EDGE(graph, *e))
      //             continue;
      // #endif        
    
        duplicate_edge(new_fwd_rch_graph, graph, *e);
        //int new_edge = duplicate_edge_without_splitting_nodes(new_fwd_rch_graph, graph, *e, true);
        //assert (new_edge > 0);
    }
    
    cout << "Forward reachable graph id: " << new_fwd_gid << " has "  << new_fwd_rch_graph->get_node_ids().size() << " nodes " << new_fwd_rch_graph->get_edge_ids().size() << " edges " << endl;
    
    
    
    

    //new id for the new backward reachable graph
    GraphNew* new_bkwd_rch_graph = new GraphNew;
    int new_bkwd_gid = ++GraphManagerNew::graph_id_count;
    new_bkwd_rch_graph->set_graph_id(new_bkwd_gid);
    add_graph(new_bkwd_gid, new_bkwd_rch_graph);
    
    
    vector<int> nids_in_fwd_graph = new_fwd_rch_graph->get_node_ids();
    
    // initialize distance from target of all nids to inf
    for (vector<int>::iterator node_itr = nids_in_fwd_graph.begin(); node_itr != nids_in_fwd_graph.end(); node_itr++) {
        distances_from_target[*node_itr] = inf;
    }
    
    // initialize distance from target of target to 0
    bool flag_target_reached = false;
    for (vector<int>::iterator target_node_itr = target_node_nids.begin(); target_node_itr != target_node_nids.end(); target_node_itr++) {
        int curr_tgt_nid = *target_node_itr;
        if (find(excluded_node_nids.begin(), excluded_node_nids.end(), curr_tgt_nid) == excluded_node_nids.end()) {
            int curr_tgt_nid_in_fwd_graph = new_fwd_rch_graph->get_nid_from_rep_id(graph->get_rep_id_from_nid(curr_tgt_nid));
            if (curr_tgt_nid_in_fwd_graph == -1) {
                cerr << "Target " << graph->get_rep_id_from_nid(curr_tgt_nid) << " not forward reachable from any of the given sources " << endl;
                continue;
            }
            else {
                flag_target_reached = true;
            }
            
            distances_from_target[curr_tgt_nid_in_fwd_graph] = 0;
            BFS_queue.push_back(curr_tgt_nid_in_fwd_graph);
            
        }
    }
    
    if (!flag_target_reached) {
        cout << "None of the targets reachable from source. Exiting." << endl;
        return -1;
    }
    
    // backward numbering of nodes
    loop_count = 0;
    ofstream fout1("fb_rch_back");
    
    while (!BFS_queue.empty()) {
        
    
        int nid = BFS_queue.front();
        
        fout1 << endl << loop_count << ": " <<  new_fwd_rch_graph->get_rep_id_from_nid(nid) << " ";
        loop_count++;
        
        nodes_retained_from_bkwd_pass.insert(nid);
        BFS_queue.pop_front();
        
        
        
       
        
        
//        if (distances_from_target[nid] == bound) {
//            continue;
//        }
        
        vector<int> inlist = new_fwd_rch_graph->get_inlist(nid);
        
        for (auto in_edge_iter = inlist.begin(); in_edge_iter != inlist.end(); in_edge_iter++) {
#ifdef ONLY_INTERAC_EDGES_FOR_MINCUT
            if (NOT_INTERAC_EDGE(new_fwd_rch_graph, *in_edge_iter))
                continue;
#endif             
            int curr_source_nid = new_fwd_rch_graph->get_source_node(*in_edge_iter);
                                       
            int temp_nid = graph->get_nid_from_rep_id(new_fwd_rch_graph->get_rep_id_from_nid(curr_source_nid));
            assert (temp_nid > 0);
            if (find(excluded_node_nids.begin(), excluded_node_nids.end(), temp_nid) == excluded_node_nids.end()) {
                
                int new_distance = distances_from_target[nid] + 1;
                int curr_distance = distances_from_target[curr_source_nid];
                distances_from_target[curr_source_nid] = min(new_distance, curr_distance);

                if ((distances_from_target[curr_source_nid] <= bound) && (std::find(BFS_queue.begin(), BFS_queue.end(), curr_source_nid) == BFS_queue.end()) && (nodes_retained_from_bkwd_pass.find(curr_source_nid) == nodes_retained_from_bkwd_pass.end())) {  
                    assert (curr_source_nid > 0);
                    BFS_queue.push_back(curr_source_nid);
                    fout1 << graph->get_nid_from_rep_id(new_fwd_rch_graph->get_rep_id_from_nid(curr_source_nid)) <<  "(" << new_fwd_rch_graph->get_rep_id_from_nid(curr_source_nid) << "): ";
                }
            }
        }
    }
    
    assert (BFS_queue.empty());

    set<int> nodes_to_retain_in_bkwd_pass;
    
    
//    for (auto nid_iter = nids_in_fwd_graph.begin(); nid_iter != nids_in_fwd_graph.end(); nid_iter++) {
    for (auto nid_iter = nodes_retained_from_bkwd_pass.begin(); nid_iter != nodes_retained_from_bkwd_pass.end(); nid_iter++) {
        int curr_nid = *nid_iter;
        int temp_nid = graph->get_nid_from_rep_id(new_fwd_rch_graph->get_rep_id_from_nid(curr_nid));
        assert (temp_nid > 0);
        if (distances_from_source[temp_nid] + distances_from_target[curr_nid] <= bound) {
//        if (distances_from_target[curr_nid] <= bound) {
            nodes_to_retain_in_bkwd_pass.insert(curr_nid);
        }
    }
    
    set<int> edges_to_retain_in_bkwd_pass;
    vector<int> eids_in_fwd_graph = new_fwd_rch_graph->get_edge_ids();
    for (auto eid_iter = eids_in_fwd_graph.begin(); eid_iter != eids_in_fwd_graph.end(); eid_iter++) {
        int curr_eid = *eid_iter;
        int eid_src = new_fwd_rch_graph->get_source_node(curr_eid);
        int eid_tgt = new_fwd_rch_graph->get_target_node(curr_eid);
        if (nodes_to_retain_in_bkwd_pass.find(eid_src) == nodes_to_retain_in_bkwd_pass.end())
            continue;
        if (nodes_to_retain_in_bkwd_pass.find(eid_tgt) == nodes_to_retain_in_bkwd_pass.end())
            continue;
        
        int temp_nid = graph->get_nid_from_rep_id(new_fwd_rch_graph->get_rep_id_from_nid(eid_src));
        assert (temp_nid > 0);
        if (distances_from_source[temp_nid] + distances_from_target[eid_tgt] + 1 <= bound) {
            edges_to_retain_in_bkwd_pass.insert(curr_eid);
        }
    }
    
    for (auto e = edges_to_retain_in_bkwd_pass.begin(); e != edges_to_retain_in_bkwd_pass.end(); e++) {
        
#ifdef ONLY_INTERAC_EDGES_FOR_MINCUT
        if (NOT_INTERAC_EDGE(new_fwd_rch_graph, *e))
            continue;
#endif        
    
        duplicate_edge(new_bkwd_rch_graph, new_fwd_rch_graph, *e);
        //int new_edge = duplicate_edge_without_splitting_nodes(new_bkwd_rch_graph, new_fwd_rch_graph, *e, true);
        //assert (new_edge > 0);
        
        
    }
    
    
    
//    cout << "Backward map" << endl;
//    for (auto m1 = distances_from_target.begin(); m1 != distances_from_target.end(); m1++) {
//        cout << new_fwd_rch_graph->get_rep_id_from_nid(m1->first) << " " << m1->second << endl;        
//    }
    
    cout << "New graph " << new_bkwd_gid << " has " << new_bkwd_rch_graph->get_node_ids().size() << " nodes " << new_bkwd_rch_graph->get_edge_ids().size() <<  " edges" << endl;
    return new_bkwd_gid;
}


void GraphManagerNew::print_all_paths(int gid, set<string>& source_nodes_set, set<string>& target_nodes_set, map<int, vector<string> >& path_id_to_path_map, map<int, vector<int> >& path_id_to_eids_map, string out_filename) {
    GraphNew* graph = get_graph(gid);
    if (graph == NULL) {
        cerr << "Error: there is no graph with id " << gid << endl;
        return;
    }

    set<int> source_node_nids;
    set<int> target_node_nids;


    for (auto itr = source_nodes_set.begin(); itr != source_nodes_set.end(); itr++) {
        string curr_id = *itr;
        
        string repid = graph->get_rep_id_from_id(curr_id);
        if (repid == "")
            continue;
        int curr_nid = graph->get_nid_from_rep_id(repid);
        if (curr_nid == -1) {
            cerr << "Error: " + repid << " has a rep id but no nid" << endl;
            continue;
        }
        
        source_node_nids.insert(curr_nid);
    }

    
    for (auto itr = target_nodes_set.begin(); itr != target_nodes_set.end(); itr++) {
        string curr_id = *itr;
        string repid = graph->get_rep_id_from_id(curr_id);
        if (repid == "")
            continue;
        int curr_nid = graph->get_nid_from_rep_id(repid);
        if (curr_nid == -1) {
            cerr << "Error: " + repid << " has a rep id but no nid" << endl;
            continue;
        }
        target_node_nids.insert(curr_nid);
    }

    
    
    ofstream fout(out_filename.c_str());
    // for each source
    for (auto itr = source_node_nids.begin(); itr != source_node_nids.end(); itr++) {
        int curr_nid = *itr;
        print_all_paths_from_source(graph, curr_nid, target_node_nids, path_id_to_path_map, path_id_to_eids_map, fout);
    }
    fout.close();
    cout << "Written " << path_id_to_path_map.size() << " paths to file" << endl;
}

void GraphManagerNew::print_all_paths_from_source(GraphNew * graph, int source_nid, set<int>& target_node_nids, map<int, vector<string> >& path_id_to_path_map, map<int, vector<int> >& path_id_to_eids_map, ofstream& fout) {
    
    
    //cout << "source " << graph->get_rep_id_from_nid(source_nid) << endl;
    static map<int, bool> visited;
    vector<string> path;
    vector<string> path_with_repids;
    vector<int> path_with_eids;
    
    print_all_paths_from_source_recursively(graph, source_nid, "", target_node_nids, visited, path, path_with_repids, path_id_to_path_map, path_with_eids, path_id_to_eids_map, fout);
}

void GraphManagerNew::print_all_paths_from_source_recursively(GraphNew * graph, int source_nid, string types, set<int>& target_node_nids, map<int, bool>& visited, vector<string> path, vector<string> path_with_repids, map<int, vector<string> >& path_id_to_path_map, vector<int>& path_with_eids, map<int, vector<int> >& path_id_to_eids_map, ofstream& fout) {
    static int path_counter = 0;
    static set<int> printed_path_ids;
    
    visited[source_nid] = true;

    //cout << "source nid " << source_nid << endl;
    path.push_back(types);
    path.push_back(graph->get_all_display_ids_of_node(source_nid)[0]);

    path_with_repids.push_back(types);
    path_with_repids.push_back(graph->get_rep_id_from_nid(source_nid));


    int curr_nid = source_nid;
    
    if ((target_node_nids.find(curr_nid) != target_node_nids.end()) || (graph->get_outlist(curr_nid).empty())) {
    //if (target_node_nids.find(curr_nid) != target_node_nids.end()) { // shows sub paths separately
    //if (graph->get_outlist(curr_nid).empty()) { // use this, if you do not want to see sub paths separately
        print_curr_path(graph, path, path_with_eids, visited, target_node_nids, fout);
        fout << endl;

        vector<string> curr_path_repids;
        for (auto path_iter = path_with_repids.begin(); path_iter != path_with_repids.end(); path_iter++) {
            curr_path_repids.push_back(*path_iter);
        }

        path_counter++;
        path_id_to_path_map[path_counter] = curr_path_repids;
        path_id_to_eids_map[path_counter] = path_with_eids;
        
        printed_path_ids.insert(path_counter);
        
       
     
        
    }
    

    vector<int> outlist;
    if (target_node_nids.find(curr_nid) == target_node_nids.end())
        outlist = graph->get_outlist(curr_nid);
    
    
    
    for (auto iter = outlist.begin(); iter != outlist.end(); iter++) {
        path_with_eids.push_back(*iter);

        vector<string> types_vec = graph->get_edge_subtypes_of_edge(*iter);
        string types = concatenate_strings2(types_vec, " ");

        int curr_tgt = graph->get_target_node(*iter);
        
        
        if (visited.find(curr_tgt) == visited.end()) {
            print_all_paths_from_source_recursively(graph, curr_tgt, types, target_node_nids, visited, path, path_with_repids, path_id_to_path_map, path_with_eids, path_id_to_eids_map, fout);
        } else if (visited[curr_tgt] == false) {
            print_all_paths_from_source_recursively(graph, curr_tgt, types, target_node_nids, visited, path, path_with_repids, path_id_to_path_map, path_with_eids, path_id_to_eids_map, fout);
        }
    }


    path.pop_back();
    path_with_repids.pop_back();
    path_with_eids.pop_back();

    visited[source_nid] = false;
}

void GraphManagerNew::print_curr_path(GraphNew * graph, vector<string>& path, vector<int>& eids, map<int, bool>& visited, set<int>& target_node_nids, ofstream& fout) {
    for (auto iter = path.begin(); iter != path.end(); iter++) {
        string curr_disp_name = (*iter);
        fout << curr_disp_name << "\t";

    }
    fout << endl;
//    for (auto iter = eids.begin(); iter != eids.end(); iter++) {
//        int curr_eid = *iter;
//        fout << graph->get_rep_id_from_nid(graph->get_source_node(curr_eid)) << "--" << graph->get_rep_id_from_nid(graph->get_target_node(curr_eid)) << "\t";
//    }
//    fout << endl;
}

void GraphManagerNew::print_all_paths_rank_ordered(GraphNew * graph, set<int>& nodes_nids_for_rank_ordering, map<int, float>& nid_to_expr_value_map, map<int, vector<string> >& path_id_to_path_with_edges_map, vector<int>& path_ids_sorted_by_size, vector<int>& path_ids_sorted_by_enrchmnt, map<int, vector<int> >& path_id_to_eids_map, string ranked_paths_out_filename) {
    
    //int nfkb_nid = graph->get_nid_from_rep_id(graph->get_rep_id_from_id("hsa4790"));
    int max_length = 0;
    vector <pair<int, int> > path_id_to_path_size_map;
    vector <pair<int, int> > path_id_to_num_of_enriched_nodes;
    map<int, int> path_id_to_common_nodes_count_map;
    vector<int> rank_ordered_path_ids;
    ofstream fout(ranked_paths_out_filename.c_str());

    for (auto path_iter = path_id_to_path_with_edges_map.begin(); path_iter != path_id_to_path_with_edges_map.end(); path_iter++) {
        
        int curr_path_id = path_iter->first;
        vector<string> curr_path = path_iter->second;
        set<int> path_has_nodes;
        set<int> path_has_enriched_nodes;
        for (auto repid_iter = curr_path.begin(); repid_iter != curr_path.end(); repid_iter++) {
            string curr_repid = *repid_iter;
            int curr_nid = graph->get_nid_from_rep_id(curr_repid);
            if (curr_nid == -1)
                continue;
            else {
                path_has_nodes.insert(curr_nid);
                if (nodes_nids_for_rank_ordering.find(curr_nid) != nodes_nids_for_rank_ordering.end()) {
                    path_has_enriched_nodes.insert(curr_nid);
                }
            }
            
        }
        
//        if (path_has_nodes.find(nfkb_nid) == path_has_nodes.end())
//            continue;
        
        int enrichment = 0;
        
        for (auto i = path_id_to_eids_map[curr_path_id].begin(); i != path_id_to_eids_map[curr_path_id].end(); i++) {
            int src_nid = graph->get_source_node(*i);
            int expr_val = (int) nid_to_expr_value_map[src_nid]; // taking only source for each edge
            enrichment = enrichment + expr_val;
        }
        
        path_id_to_common_nodes_count_map[curr_path_id] = enrichment;
        
        int normalized_path_size = (int) ceil (100 * ((float) path_has_enriched_nodes.size() / (float) curr_path.size()) );
        
        path_id_to_path_size_map.push_back(pair<int,int>(curr_path_id, path_has_nodes.size()));
        path_id_to_num_of_enriched_nodes.push_back(pair<int,int>(curr_path_id, enrichment));
        
        if (max_length < path_has_nodes.size())
            max_length = path_has_nodes.size();
    }
    

    cout << path_id_to_path_with_edges_map.size() << endl;
    
    // copy map into vector of pairs and sort this vector
    vector<pair<int, int> > path_id_enrchment_pairs;
    map<int, int> path_id_enrchment_map;
    
    sort(path_id_to_path_size_map.begin(), path_id_to_path_size_map.end(), compare_pair_on_second_ascending);
    
    for (auto temp = path_id_to_path_size_map.begin(); temp != path_id_to_path_size_map.end(); temp++) {
        path_id_enrchment_pairs.push_back(pair<int, int>(temp->first, path_id_to_common_nodes_count_map[temp->first]));
        path_id_enrchment_map.insert(pair<int, int>(temp->first, path_id_to_common_nodes_count_map[temp->first]));
    }


    vector<int> doubly_sorted_path_ids;
    //sort(path_id_enrchment_pairs.begin(), path_id_enrchment_pairs.end(), compare_pair_on_second_descending);

    
    for (int curr_size = 0; curr_size <= max_length; curr_size++) {
        
        vector<pair<int, int> > path_id_to_path_enrch_of_same_size;
        for (auto path_id_iter = path_id_to_path_size_map.begin(); path_id_iter != path_id_to_path_size_map.end(); path_id_iter++) {
            
            if (path_id_iter->second == curr_size) {
                path_id_to_path_enrch_of_same_size.push_back(pair<int, int>(path_id_iter->first, path_id_enrchment_map[path_id_iter->first]));
            }
            
        }
        
//        if (path_id_to_path_enrch_of_same_size.empty())
//            continue;
            

        sort(path_id_to_path_enrch_of_same_size.begin(), path_id_to_path_enrch_of_same_size.end(), compare_pair_on_second_descending);

        for (auto t = path_id_to_path_enrch_of_same_size.begin(); t != path_id_to_path_enrch_of_same_size.end(); t++){
            doubly_sorted_path_ids.push_back(t->first);
        }
            
        
    }
    
        
    //assert (path_id_to_path_with_edges_map.size() == doubly_sorted_path_ids.size());
    
    
    
    // actual printing happens here
    for (auto ranked_path_map_iter = doubly_sorted_path_ids.begin(); ranked_path_map_iter != doubly_sorted_path_ids.end(); ranked_path_map_iter++) {
        int curr_path_id = *ranked_path_map_iter;
        vector<string> curr_path = path_id_to_path_with_edges_map[curr_path_id];
        path_ids_sorted_by_size.push_back(curr_path_id);
        for (auto path_iter = curr_path.begin(); path_iter != curr_path.end(); path_iter++) {
            string curr_repid = graph->get_rep_id_from_id(graph->get_rep_id_from_id(*path_iter));

            if (curr_repid != "")
                fout << graph->get_all_display_ids_of_node(graph->get_nid_from_rep_id(curr_repid))[0] << "\t";
            else
                fout << *path_iter << "\t";
        }

        fout << endl;
    }
    
    sort(path_id_to_num_of_enriched_nodes.begin(), path_id_to_num_of_enriched_nodes.end(), compare_pair_on_second_descending);
    for (auto i = path_id_to_num_of_enriched_nodes.begin(); i != path_id_to_num_of_enriched_nodes.end(); i++) {
        path_ids_sorted_by_enrchmnt.push_back(i->first);
    }

    fout.close();
}

int GraphManagerNew::select_operation_on_graph(int gid, set<string>& nodes_set) {

    GraphNew* graph = get_graph(gid);
    if (graph == NULL) {
        cerr << "Error: there is no graph with id " << gid << endl;
        return -1;
    }



    //new id for the new graph
    int new_gid = -1;
    GraphNew* graph_ptr = new GraphNew;
    new_gid = ++GraphManagerNew::graph_id_count;
    graph_ptr->set_graph_id(new_gid);
    add_graph(new_gid, graph_ptr);

    
    // get node repids from ids
    std::set<string> node_repids_set;
    std::set<std::string>::iterator set_itr;

    for (set_itr = nodes_set.begin(); set_itr != nodes_set.end(); set_itr++) {
        string rep_id = graph->get_rep_id_from_id(*set_itr);
        assert (rep_id != "");
        node_repids_set.insert(rep_id);
        

    }
    


    vector<int> eids = graph->get_edge_ids();
    for (auto eids_iter = eids.begin(); eids_iter != eids.end(); eids_iter++) {
        int curr_eid = *eids_iter;

#ifdef ONLY_INTERAC_EDGES_FOR_MINCUT
        if (NOT_INTERAC_EDGE(graph, curr_eid))
            continue;
#endif
        int source_nid = graph->get_source_node(curr_eid);
        string source_rep_id = graph->get_rep_id_from_nid(source_nid);

        if (node_repids_set.find(source_rep_id) == node_repids_set.end())
            continue;

        int target_nid = graph->get_target_node(curr_eid);
        string target_rep_id = graph->get_rep_id_from_nid(target_nid);

        if (node_repids_set.find(target_rep_id) == node_repids_set.end())
            continue;


        // duplicate edge
        int new_eid = duplicate_edge(graph_ptr, graph, curr_eid, true);

    }

    
    // populate adjacency matrix
    //fill_adj_matrix_for_graph(graph_ptr);
    
    // genesis
    string oper = "select";
    list<int> empty_list;
    empty_list.push_back(gid);
    add_graph_genesis(new_gid, oper, empty_list);
    return new_gid;
}

int GraphManagerNew::select_subgraph(int gid, set<string>& nodes_set) {
    int new_gid = -1;

    GraphNew* graph = get_graph(gid);
    if (graph == NULL) {
        cerr << "Error: there is no graph with id " << gid << endl;
        return -1;
    }

    // get node nids from ids
    std::set<int> node_nid_set;
    std::set<std::string>::iterator set_itr;

    for (set_itr = nodes_set.begin(); set_itr != nodes_set.end(); set_itr++) {
        string rep_id = graph->get_rep_id_from_id(*set_itr);
        if (rep_id != "") {
            int nid = graph->get_nid_from_rep_id(rep_id);
            node_nid_set.insert(nid);
        }

    }
    cout << "Number of entries in select file: " << node_nid_set.size() << endl;

    //new id for the new graph
    GraphNew* graph_ptr = new GraphNew;
    new_gid = ++GraphManagerNew::graph_id_count;
    graph_ptr->set_graph_id(new_gid);
    add_graph(new_gid, graph_ptr);
    
    //maintain a BFS queue of nodes
    std::list<int> BFS_queue;
    set<int> visited_nodes;
    vector<int> NIDSg = graph->get_node_ids();

    for (set<int>::iterator node_itr = node_nid_set.begin(); node_itr != node_nid_set.end(); node_itr++) {
        //reach begins from source node if source node is not in the exclude list

        BFS_queue.push_back(*node_itr);

    }

    //the BFS loop based on queue emptiness
    while (!BFS_queue.empty()) {
        int nid = BFS_queue.front();
        visited_nodes.insert(nid);
        BFS_queue.pop_front();

        string rid = graph->get_rep_id_from_nid(nid);
        int nid_new = graph_ptr->get_nid_from_rep_id(rid);

        //if the reachability graph already has a node corresponding to this rid then there is no need to create such a node
        //o/w duplicate this node into the new graph
        if (nid_new == -1) {
#ifdef DUP_CHECK_FLAG_SET
            nid_new = duplicate_node(graph_ptr, graph, nid, false);
#else
            nid_new = duplicate_node(graph_ptr, graph, nid);
#endif                                     


        }

        vector<int> edge_list_in, edge_list_out;
        edge_list_in = graph->get_inlist(nid);

        edge_list_out = graph->get_outlist(nid);


        for (vector<int>::iterator edge_itr = edge_list_out.begin(); edge_itr != edge_list_out.end(); ++edge_itr) {

            int target_node = graph->get_target_node(*edge_itr);

            if (node_nid_set.find(target_node) != node_nid_set.end()) {
                if (visited_nodes.find(target_node) == visited_nodes.end()) {
                    BFS_queue.push_back(target_node);

                }
                duplicate_edge(graph_ptr, graph, *edge_itr);

            }

        }



    }

    
    // populate adjacency matrix
    //fill_adj_matrix_for_graph(graph_ptr);


    string oper = "select";
    list<int> empty_list;
    empty_list.push_back(gid);
    add_graph_genesis(new_gid, oper, empty_list);
    return new_gid;
}

int GraphManagerNew::get_subgraph_with_edge_ids(GraphNew * graph, set<int> present_edges) {
    int new_gid = -1;
    int gid = graph->get_graph_id();

    if (graph == NULL) {
        cerr << "Error: there is no graph with id " << gid << endl;
        return -1;
    }

    //new id for the new graph
    GraphNew* graph_ptr = new GraphNew;
    new_gid = ++GraphManagerNew::graph_id_count;
    graph_ptr->set_graph_id(new_gid);
    add_graph(new_gid, graph_ptr);


    
    for (set<int>::iterator itr = present_edges.begin(); itr != present_edges.end(); itr++) {
        int new_eid = duplicate_edge(graph_ptr, graph, *itr);
        
    }
    
    
    // populate adjacency matrix
    //fill_adj_matrix_for_graph(graph_ptr);
    

    return new_gid;
}

void GraphManagerNew::read_pairs_file(GraphNew * graph, string pairs_filename, vector<pair<int, int> >& pairs, set<int>& nids_as_source, set<int>& nids_as_target) {

    ifstream ifs(pairs_filename.c_str());
    if (!ifs.is_open()) {
        cerr << "File " << pairs_filename << " could not be opened" << endl;
        return;
    }

    string line;
    while (getline(ifs, line)) {
        string src_id, tgt_id;
        stringstream ss(line);
        ss >> src_id >> tgt_id;
        int src_nid = graph->get_nid_from_rep_id(graph->get_rep_id_from_id(src_id));
        if (src_nid == -1)
            continue;
        int tgt_nid = graph->get_nid_from_rep_id(graph->get_rep_id_from_id(tgt_id));
        if (tgt_nid == -1)
            continue;
        pairs.push_back(pair<int, int>(src_nid, tgt_nid));
        nids_as_source.insert(src_nid);
        nids_as_target.insert(tgt_nid);

    }

}

void GraphManagerNew::read_data_file_into_map(GraphNew * graph, string up_reg_filename, string down_reg_filename, unordered_map<string, bool>& data_map) {
    string id;
    ifstream ifs_up(up_reg_filename.c_str());
    ifstream ifs_down(down_reg_filename.c_str());


    if (!ifs_up.is_open()) {
        cerr << "File " + up_reg_filename + " could not be opened." << endl;
        return;
    }
    if (!ifs_down.is_open()) {
        cerr << "File " + down_reg_filename + " could not be opened." << endl;
        return;
    }
    while (ifs_up >> id) {
        string repid = graph->get_rep_id_from_id(id);
        if (repid != "") {
            data_map.insert(pair<string, bool>(repid, true));
        }
    }
    ifs_up.close();
    while (ifs_down >> id) {
        string repid = graph->get_rep_id_from_id(id);
        if (repid != "") {
            data_map.insert(pair<string, bool>(repid, false));
        }
    }
    ifs_down.close();

}

void GraphManagerNew::read_data_file_into_set_of_ints(GraphNew * graph, string filename, set<int>& nids) {
    string id;
    ifstream ifs(filename.c_str());


    if (!ifs.is_open()) {
        cerr << "File " + filename + " could not be opened." << endl;
        return;
    }

    while (ifs >> id) {
        string repid = graph->get_rep_id_from_id(id);
        if (repid != "") {
            nids.insert(graph->get_nid_from_rep_id(repid));
        }
    }
    ifs.close();

}

void GraphManagerNew::get_hsa_from_name(string filename) {
    string id;
    float fold_change;
    
    ifstream ifs(filename.c_str());

    string outfile = "down_reg";
    ofstream ofs(outfile.c_str());

    if (!ifs.is_open()) {
        cerr << "File " + filename + " could not be opened." << endl;
        return;
    }

    while (ifs >> id) {
        string repid = kegg_hsa_id_to_display_name_map[id];
        //if (repid != "") {
            ofs << repid << "\t" << id;
            ifs >> fold_change;
            ofs << "\t" << fold_change << endl;
        //}
        
    }
    ifs.close();
    ofs.close();
}



void GraphManagerNew::read_edge_data_file_into_set_of_ints(GraphNew * graph, string edges_filename, set<int>& eids_matched) {
    string line;
    ifstream ifs(edges_filename.c_str());


    if (!ifs.is_open()) {
        cerr << "File " + edges_filename + " could not be opened." << endl;
        return;
    }

    // read relaxed_edges_file
    set<string> all_edge_labels_in_file;
    set<string> all_src_repids_to_check;
    string edge_type;
    while (getline(ifs, line)) {
        string src_id, tgt_id;
        stringstream ss(line);
        ss >> src_id >> tgt_id >> edge_type;
        
        string src_repid = graph->get_rep_id_from_id(src_id);
        if (src_repid == "")
            continue;
        string tgt_repid = graph->get_rep_id_from_id(tgt_id);
        if (tgt_repid == "")
            continue;
        
        string edge_label_in_file = src_repid + "__" + tgt_repid + "__" + edge_type;
        
        all_edge_labels_in_file.insert(edge_label_in_file);
    }
    
    vector<int> eids = graph->get_edge_ids();
    for (auto eid_iter = eids.begin(); eid_iter != eids.end(); eid_iter++) {
        int curr_eid = *eid_iter;
        string src = graph->get_rep_id_from_nid(graph->get_source_node(curr_eid));
        string tgt = graph->get_rep_id_from_nid(graph->get_target_node(curr_eid));
        vector<string> types = graph->get_edge_subtypes_of_edge(curr_eid);
        string type = concatenate_strings2(types, "_");
        
        string label_to_check = src + "__" + tgt + "__" + type;
        
        if (all_edge_labels_in_file.find(label_to_check) != all_edge_labels_in_file.end()) {
            eids_matched.insert(curr_eid);
        }
    }
        
//    for (auto iter = all_src_repids_to_check.begin(); iter != all_src_repids_to_check; iter++) {
//        int curr_nid = graph->get_nid_from_rep_id(*iter);
//        if (curr_nid == "-1")
//            continue;
//        
//        vector<int> outlist = graph->get_oulist(curr_nid);
//        if (outlist.empty())
//            continue;
//        
//        
//        vector<string> edges_for_source;
//        for (auto e = outlist.begin(); e != outlist.end(); e++) {
//            int curr_eid = *e;
//            string full_edge_label;
//            string all_edge_types;
//            vector<string> edge_types = graph->get_edge_subtypes_of_edge(curr_eid);
//            if (edge_types.empty())
//                all_edge_types = "-";
//            else
//                all_edge_types = concatenate_strings2(edge_types, ",");
//            
//            full_edge_label = graph->get_repid_from_nid(graph->get_source_node(curr_eid)) + "__" + graph->get_repid_from_nid(graph->get_target_node(curr_eid)) + "__" + all_edge_types;
//            
//            edges_for_source.push_back(full_edge_label);
//            
//        }
//        
//        
//    }
    ifs.close();
}

void GraphManagerNew::read_data_file_into_set_of_strings(GraphNew * graph, string filename, set<string>& repids) {
    string id;
    ifstream ifs(filename.c_str());


    if (!ifs.is_open()) {
        cerr << "File " + filename + " could not be opened." << endl;
        return;
    }

    while (ifs >> id) {
        string repid = graph->get_rep_id_from_id(id);
        if (repid != "") {
            repids.insert(graph->get_rep_id_from_id(repid));
        }
    }
    ifs.close();

}

void GraphManagerNew::get_fold_change_from_log_values(string log_value_filename, string output_filename) {
    ifstream fin(log_value_filename.c_str());
    ofstream fout(output_filename.c_str());

    if (!fin.is_open()) {
        cerr << "File " + log_value_filename + " could not be opened." << endl;
        return;
    }

    string line;

    while (getline(fin, line)) {
        stringstream l(line);
        string entry1, entry2;
        l >> entry1 >> entry2;

        if (entry2 == "-")
            continue;

        float log_value = stof(entry1);
        float fold_change = pow(2, log_value);
        string hsa_id = "hsa" + entry2;

        fout << hsa_id << "\t" << fold_change << "\n";
    }
    fin.close();
    fout.close();

}

void GraphManagerNew::read_fold_change_values_into_map(GraphNew * graph, map<int, float>& nid_to_expr_value_map, string fold_change_filename, int offset) {
    ifstream fin(fold_change_filename.c_str());

    if (!fin.is_open()) {
        cerr << "File " + fold_change_filename + " could not be opened." << endl;
        return;
    }

    string line;
    while (getline(fin, line)) {
        stringstream l(line);
        string entry1, entry2;
        l >> entry1 >> entry2;

        if (entry2 == "-")
            continue;

        string hsaid = entry1;
        string rep_id = graph->get_rep_id_from_id(hsaid);

        if (rep_id == "")
            continue;

        int nid = graph->get_nid_from_rep_id(rep_id);
        assert(nid != -1);

        float fold_change = stof(entry2);
        
        nid_to_expr_value_map[nid] = fold_change + offset;

    }
    fin.close();
    
}

int GraphManagerNew::get_data_consistent_subgraph(GraphNew * graph, string up_reg_filename, string down_reg_filename, bool create_subgraph_flag) {
    unordered_map<string, bool> data_map;
    unordered_map<string, bool>::iterator data_map_iter;
    read_data_file_into_map(graph, up_reg_filename, down_reg_filename, data_map);

    string filename = "up_reg";
    ofstream up_out(filename.c_str());
    filename = "down_reg";
    ofstream down_out(filename.c_str());
    set<string> up_set, down_set;

    GraphNew * new_graph;
    int new_gid = -1;
    if (create_subgraph_flag) {
        new_graph = new GraphNew();
        new_gid = ++GraphManagerNew::graph_id_count;
        new_graph->set_graph_id(new_gid);
        add_graph(new_gid, new_graph);
        
        // populate adjacency matrix
        //fill_adj_matrix_for_graph(new_graph);
    }

    vector<int> eids = graph->get_edge_ids();
    for (auto eids_iter = eids.begin(); eids_iter != eids.end(); eids_iter++) {
        int curr_eid = *eids_iter;
        int source_nid = graph->get_source_node(curr_eid);
        string source_rep_id = graph->get_rep_id_from_nid(source_nid);
        data_map_iter = data_map.find(source_rep_id);
        if (data_map_iter != data_map.end()) {
            if (data_map_iter->second)
                up_set.insert(data_map_iter->first);

            if (!data_map_iter->second)
                down_set.insert(data_map_iter->first);

        }


#ifdef ONLY_INTERAC_EDGES_FOR_MINCUT
        if (create_subgraph_flag) {
            if (NOT_INTERAC_EDGE(graph, curr_eid))
                continue;
        }
#endif        
        int target_nid = graph->get_target_node(curr_eid);
        string target_rep_id = graph->get_rep_id_from_nid(target_nid);
        data_map_iter = data_map.find(target_rep_id);
        if (data_map_iter != data_map.end()) {

            // target node is up regulated and edge has inhibition/repression subtype
            if (data_map_iter->second) {
                if (create_subgraph_flag) {
                    if (graph->edge_has_subtype(curr_eid, "inhibition") || graph->edge_has_subtype(curr_eid, "repression"))
                        continue;
                }
                up_set.insert(data_map_iter->first);
            }

            // target node is down regulated and edge has subtype activation/expression
            if (!data_map_iter->second) {
                if (create_subgraph_flag) {
                    if (graph->edge_has_subtype(curr_eid, "activation") || graph->edge_has_subtype(curr_eid, "expression"))
                        continue;
                }
                down_set.insert(data_map_iter->first);

            }

        }

        if (create_subgraph_flag) {
            // duplicate edge
            int new_eid = duplicate_edge(new_graph, graph, curr_eid, true);
        }
    }

    for (auto iter = up_set.begin(); iter != up_set.end(); iter++)
        up_out << *iter << endl;
    for (auto iter = down_set.begin(); iter != down_set.end(); iter++)
        down_out << *iter << endl;

    if (create_subgraph_flag) {
        //for genesis
        string oper = "Created data consistent graph from ";
        list<int> gid_list;
        gid_list.push_back(graph->get_graph_id());
        add_graph_genesis(new_gid, oper, gid_list);
        return new_gid;
    } else
        return new_gid;
}


void GraphManagerNew::get_data_overlap(GraphNew * graph, string up_reg_filename, string down_reg_filename) {
    unordered_map<string, bool> data_map;
    unordered_map<string, bool>::iterator data_map_iter;
    read_data_file_into_map(graph, up_reg_filename, down_reg_filename, data_map);

    string filename = "up_reg";
    ofstream up_out(filename.c_str());
    filename = "down_reg";
    ofstream down_out(filename.c_str());
    set<string> up_set, down_set;

    vector<int> nids = graph->get_node_ids();
    
    for (auto n = nids.begin(); n != nids.end(); n++) {
        int curr_nid = *n;
        string curr_rep_id = graph->get_rep_id_from_nid(curr_nid);
        
        if (data_map.find(curr_rep_id) == data_map.end())
            continue;
            
        if (data_map[curr_rep_id])
            up_set.insert(curr_rep_id);
        
        if (!data_map[curr_rep_id])
            down_set.insert(curr_rep_id);
        
    }
        
    set<string> common_repids;
    set_intersection(up_set.begin(), up_set.end(), down_set.begin(), down_set.end(), inserter(common_repids, common_repids.begin()));
    
    set<string> up_set_unique, down_set_unique;
    set_difference(up_set.begin(), up_set.end(), common_repids.begin(), common_repids.end(), inserter(up_set_unique, up_set_unique.begin()));
    set_difference(down_set.begin(), down_set.end(), common_repids.begin(), common_repids.end(), inserter(down_set_unique, down_set_unique.begin()));
    
    

    for (auto iter = up_set_unique.begin(); iter != up_set_unique.end(); iter++)
        up_out << *iter << endl;
    for (auto iter = down_set_unique.begin(); iter != down_set_unique.end(); iter++)
        down_out << *iter << endl;

    up_out.close();
    down_out.close();
    
    
    cout << "Up nodes: " << up_set_unique.size() << endl;
    cout << "Down nodes: " << down_set_unique.size() << endl;
}




//int GraphManagerNew::put_weight_on_graph_edges(GraphNew * graph, vector<string>& source_nodes_set, vector<string>& target_nodes_set, string fold_change_filename) {
//    //return weight_inverse_of_dist(graph, source_nodes_set, target_nodes_set);
//    return weight_by_expression_values(graph, source_nodes_set, target_nodes_set, fold_change_filename);
//}

int GraphManagerNew::put_weight_on_graph_edges(GraphNew * graph, vector<string>& source_nodes_set, vector<string>& target_nodes_set, string fold_change_filename, vector<float>& vec_coeff, vector<float>& vec_order) {
    
    GraphNew * wgraph = new GraphNew;
    int weighted_gid = ++GraphManagerNew::graph_id_count;
    wgraph->set_graph_id(weighted_gid);
    add_graph(weighted_gid, wgraph);
    
    
    
    assign_weight_by_inverse_of_distance(0, graph, wgraph, source_nodes_set, FORWARD);
    assign_weight_by_inverse_of_distance(1, graph, wgraph, target_nodes_set, BACKWARD);
    assign_weight_by_expression_values(2, 3, graph, wgraph, fold_change_filename);
    
    
    
    
    vector<int> eids = wgraph->get_edge_ids();
    
    int num_of_elems = wgraph->get_weight_tuple_for_edge(*eids.begin()).size();
    
    
    if (vec_coeff.size() < num_of_elems) {
        cout << "Warning: Insufficient coefficients provided. Filling with 1." << endl;
        vec_coeff.resize(num_of_elems, 1.0);
    }
    
    if (vec_order.size() < num_of_elems) {
        cout << "Warning: Insufficient power values provided. Filling with 1." << endl;
        vec_order.resize(num_of_elems, 1.0);
    }
    
    //all user provided coeffs are 0
    int count_zero_coeff = std::count (vec_coeff.begin(), vec_coeff.end(), 0);
    if (count_zero_coeff == vec_coeff.size()) { //all user provided coeffs are 0
        cout << "No non-zero coefficients provided. Proceeding with weight 1 on all edges" << endl;
        for (auto e = eids.begin(); e != eids.end(); e++) {
            wgraph->set_edge_weight(*e, 1);
            wgraph->set_edge_weight_float(*e, 1.0);
        }
        
        
        // populate adjacency matrix
        //fill_adj_matrix_for_graph(wgraph);
    
        string oper = "weighted graph ";
        list<int> empty_list;
        empty_list.push_back(graph->get_graph_id());
        add_graph_genesis(weighted_gid, oper, empty_list);
    
        return weighted_gid;
    }
    
    
    
    assert (graph->get_edge_ids().size() == wgraph->get_edge_ids().size());
    
    
    for (auto e = eids.begin(); e != eids.end(); e++) {
        int curr_eid = *e;
        
        int index = 0;
        int weight = 0;
        float flt_weight = 0.0;
        
        vector<float> vec_elems = wgraph->get_weight_tuple_for_edge(curr_eid);
        
        int num_of_elements = vec_elems.size();
        for (auto elem = vec_elems.begin(); elem != vec_elems.end(); elem++) {
            
            float w = *elem;
            
            if (w== 0.0)
                w = 1 / pow(10, PRECISION);
            float exp = vec_order[index];
        
            w = (vec_coeff[index] * pow(w,exp));
            
//            if (w < 0)
//                w = 0.0;
//            else if (1/w == inff)
//                w = 0.0;
//            else if (w == inff)
//                w = 20.5; // max fold change -- added by sukanya on 26 Jun 2017
            ////wgraph->set_weight_factor_at_tuple_index_for_edge(*e, index, w);///////////// take out later
            
//            if (w < inff)
                flt_weight = flt_weight + w;
                
            
            index++;
        }
        
            
        
        
//        for (auto elem = 1; elem <= num_of_elements; elem++) {
//            float exp = vec_order[index];
//            float w = 0.0;
//            flt_weight = 0.0;            
//            
//            if (vec_elems[index] == 0) {
//                w = 0.0;
//                wgraph->set_weight_factor_at_tuple_index_for_edge(*e, index, w);
//            }
//        
//            //else {
//            if (exp < 0) {
//                w = (vec_coeff[index] * (1 / pow(vec_elems[index],fabs(exp)) ) );
//                
//            }
//            else {
//                w = (vec_coeff[index] * pow(vec_elems[index],exp));
//                
//            }
//            cout << "w: " << w << endl;
//           
//            if (w < 0)
//                w = 0.0;
//            else if (1/w == inff)
//                w = 0.0;
//            else if (w == inff)
//                w = 20.5; // max fold change -- added by sukanya on 26 Jun 2017
//            ////wgraph->set_weight_factor_at_tuple_index_for_edge(*e, index, w);///////////// take out later
//            
//            if (w < inff)
//                flt_weight = flt_weight + w;
//             
//            cout << "float weight: " << flt_weight << endl;
//            //}
//            index++;
//        }
//        
        
        weight = (int) ceil(flt_weight);
        //weight = (int) ceil( pow(10, PRECISION) / flt_weight );
       
        if (weight <= 0) {
            weight = 0;
        }
        
        if (flt_weight <= 0.0) {
            flt_weight = 0.0;
        }
////        if (weight == inf)
////            weight = 1;
        
        //assert (weight >= 0);
        //assert (flt_weight >= 0.0);
        wgraph->set_edge_weight(curr_eid, weight);
        wgraph->set_edge_weight_float(curr_eid, flt_weight);
        
       
    }
    
    // populate adjacency matrix
    //fill_adj_matrix_for_graph(wgraph);
    
    // for genesis
    string oper = "weighted graph ";
    list<int> empty_list;
    empty_list.push_back(graph->get_graph_id());
    add_graph_genesis(weighted_gid, oper, empty_list);
    
    return weighted_gid;
}


void GraphManagerNew::assign_weight_by_inverse_of_distance(int tuple_index, GraphNew * graph, GraphNew * wgraph, vector<string>& source_nodes_set, int direction) {
    
    
    int bound = std::numeric_limits<int>::max();
    
    float dist_min = (float) bound; //inff;
    float dist_max = 1.0 / pow(10, PRECISION); //
    
    vector<int> source_node_ids;
    
    for (auto iter = source_nodes_set.begin(); iter != source_nodes_set.end(); iter++) {
        string curr_id = *iter;
        string curr_repid = graph->get_rep_id_from_id(curr_id);
        if (curr_repid == "") {
            cerr << "Node " << curr_id << " has no repid in graph" << endl;
            continue;
        }
        
        int curr_nid = graph->get_nid_from_rep_id(curr_repid);
        if (curr_nid == -1) {
            cerr << "Node " << curr_id << " has no nid in graph";
            continue;
        }
        source_node_ids.push_back(curr_nid);
    }
    
    
    list<int> BFS_queue;
    set<int> visited_nodes;
    
    map<int, int> distances_map;
    
    
    vector<int> NIDs = graph->get_node_ids();
    
    for (auto nid_iter = NIDs.begin(); nid_iter != NIDs.end(); nid_iter++) {
        int curr_nid = *nid_iter;
        distances_map[curr_nid] = std::numeric_limits<int>::max();
        
    }
    
    
    for (auto source_nid_iter = source_node_ids.begin(); source_nid_iter != source_node_ids.end(); source_nid_iter++) {
        int curr_src_nid = *source_nid_iter;
        distances_map[curr_src_nid] = 1;
        BFS_queue.push_back(curr_src_nid);
    }
    
    
    
    
    while (!BFS_queue.empty()) {
        int curr_nid = BFS_queue.front();
        visited_nodes.insert(curr_nid);
        BFS_queue.pop_front();
        
        string repid = graph->get_rep_id_from_nid(curr_nid);
        int new_nid = wgraph->get_nid_from_rep_id(graph->get_rep_id_from_id(repid));
        
        if (new_nid == -1) {
            new_nid = duplicate_node(wgraph, graph, curr_nid);
            
        }
        
        vector<int> edge_inlist, edge_outlist;
        edge_inlist = graph->get_inlist(curr_nid);
        edge_outlist = graph->get_outlist(curr_nid);
        
        
        if (direction == FORWARD) {
            for (vector<int>::iterator edge_itr = edge_outlist.begin(); edge_itr != edge_outlist.end(); ++edge_itr) {

                int curr_edge_id = *edge_itr;
                int new_eid = -1; 
#ifdef ONLY_INTERAC_EDGES_FOR_MINCUT
                if (NOT_INTERAC_EDGE(graph, *edge_itr))
                    continue;
#endif                
                
                int target_node = graph->get_target_node(curr_edge_id);
                

                int new_distance = distances_map[curr_nid] + 1;
                int old_distance = distances_map[target_node];
                distances_map[target_node] = min(new_distance, old_distance);
                
                
                if (new_distance <= bound) {
                    if (visited_nodes.find(target_node) == visited_nodes.end()) {
                        BFS_queue.push_back(target_node);
                    }

                }

                new_eid = duplicate_edge(wgraph, graph, curr_edge_id);
                wgraph->set_other_value1_in_edge(new_eid, curr_edge_id);
                
                
                float curr_dist = (float) distances_map[curr_nid];
                                
                if (curr_dist <= dist_min)
                    dist_min = curr_dist;
                
                if (curr_dist >= dist_max)
                    dist_max = curr_dist;
                
                wgraph->set_weight_factor_at_tuple_index_for_edge(new_eid, tuple_index, curr_dist);
                
            }
            
        }
      
        if (direction == BACKWARD) {
            for (vector<int>::iterator edge_itr = edge_inlist.begin(); edge_itr != edge_inlist.end(); ++edge_itr) {

                int curr_edge_id = *edge_itr;
                int new_eid = -1; 
                
#ifdef ONLY_INTERAC_EDGES_FOR_MINCUT
                if (NOT_INTERAC_EDGE(graph, curr_edge_id))
                    continue;
#endif          
                
                int local_source_node = graph->get_source_node(curr_edge_id);
                
                int new_distance = distances_map[curr_nid] + 1;
                int old_distance = distances_map[local_source_node];
                distances_map[local_source_node] = min(new_distance, old_distance);

                
                if (new_distance <= bound) {
                    if (visited_nodes.find(local_source_node) == visited_nodes.end()) {
                        BFS_queue.push_back(local_source_node);
                    }

                }

                new_eid = duplicate_edge(wgraph, graph, curr_edge_id);
                wgraph->set_other_value1_in_edge(new_eid, curr_edge_id);
                
                float curr_dist = (float) distances_map[curr_nid];
                                
                if (curr_dist <= dist_min)
                    dist_min = curr_dist;
                
                if (curr_dist >= dist_max)
                    dist_max = curr_dist;
                
                wgraph->set_weight_factor_at_tuple_index_for_edge(new_eid, tuple_index, curr_dist);
                
            }
            
        }
      
        
    }
       
    assert (BFS_queue.empty());

    
    // normalization
            
    vector<int> edge_eids = wgraph->get_edge_ids();
    for (auto eid_iter = edge_eids.begin(); eid_iter != edge_eids.end(); eid_iter++){
        int curr_edge = *eid_iter;
        
        float curr_factor_value = wgraph->get_weight_factor_at_tuple_index_for_edge(curr_edge, tuple_index);
        
        float normalized_value = NORMALIZE(curr_factor_value, dist_min, dist_max);

        wgraph->set_weight_factor_at_tuple_index_for_edge(curr_edge, tuple_index, normalized_value);
        
    }
    

}

void GraphManagerNew::assign_weight_by_expression_values(int index_src, int index_tgt, GraphNew * graph, GraphNew * wgraph, string fold_change_filename) {
    
   
    float min_value = std::numeric_limits<float>::max();
    float max_value = 1.0 / pow(10, PRECISION);
    
    
    
    map<int, float> nid_to_expr_value_map;
    read_fold_change_values_into_map(wgraph, nid_to_expr_value_map, fold_change_filename, 0);
            
    
    vector<int> graph_eids = wgraph->get_edge_ids();
   
    
    for (vector<int>::iterator eid_iter = graph_eids.begin(); eid_iter != graph_eids.end(); eid_iter++) {
        int curr_eid = *eid_iter;
        
        
        
        int curr_src_nid = wgraph->get_source_node(curr_eid);
        int curr_tgt_nid = wgraph->get_target_node(curr_eid);
        
        float src_expr_value = 1.0;
        float tgt_expr_value = 1.0;
        
        map<int, float>::iterator map_itr = nid_to_expr_value_map.find(curr_src_nid);
        if (map_itr != nid_to_expr_value_map.end())
            src_expr_value = abs(map_itr->second);
        
        map_itr = nid_to_expr_value_map.find(curr_tgt_nid);
        if (map_itr != nid_to_expr_value_map.end())
            tgt_expr_value = abs(map_itr->second);
        
        
        if (src_expr_value <= tgt_expr_value) {
            if (src_expr_value <= min_value)
                min_value = src_expr_value;
            if (max_value <= tgt_expr_value)
                max_value = tgt_expr_value;
        }
        else  {
            if (tgt_expr_value <= min_value)
                min_value = tgt_expr_value;
            if (max_value <= src_expr_value)
                max_value = src_expr_value;
        }
        

        wgraph->set_weight_factor_at_tuple_index_for_edge(curr_eid, index_src, src_expr_value);
        wgraph->set_weight_factor_at_tuple_index_for_edge(curr_eid, index_tgt, tgt_expr_value);
    }
   
    
    // normalization
    
//    if (max_value == min_value)    {
//        for (auto ne = graph_eids.begin(); ne != graph_eids.end(); ne++){
//            wgraph->set_weight_factor_at_tuple_index_for_edge(*ne, index_src, 1.0);
//            wgraph->set_weight_factor_at_tuple_index_for_edge(*ne, index_tgt, 1.0);
//        }
//        return ;
//    }
//    
        
    float src_expr_value = 1.0;
    float tgt_expr_value = 1.0;
    float normalized_value = 1.0;

    
    vector<int> edge_eids = wgraph->get_edge_ids();
    for (auto eid_iter = edge_eids.begin(); eid_iter != edge_eids.end(); eid_iter++){
        int curr_edge = *eid_iter;
        
        src_expr_value = wgraph->get_weight_factor_at_tuple_index_for_edge(curr_edge, index_src);
        normalized_value = NORMALIZE(src_expr_value, min_value, max_value);
                
        wgraph->set_weight_factor_at_tuple_index_for_edge(curr_edge, index_src, normalized_value);
        
        
        tgt_expr_value = wgraph->get_weight_factor_at_tuple_index_for_edge(curr_edge, index_tgt);
        normalized_value = NORMALIZE(tgt_expr_value, min_value, max_value);
        
        wgraph->set_weight_factor_at_tuple_index_for_edge(curr_edge, index_tgt, normalized_value);
        
       
    }
    
    
}



void GraphManagerNew::print_all_graph_manager_info() {
    string file_name;
    cout << "Enter the file to store all graph information" << endl;
    cin >> file_name;
    ofstream fout(file_name.c_str());

    if (fout.is_open()) {
        fout << "Global id to rep id map\n";
        print_map(all_id_map, fout);
        fout << endl;
        fout << "graph id to graph pointer map\n";
        print_map(graph_id_to_graph_map, fout);
        fout << endl;
        fout << "node_id_to_graph_id\n";
        print_map(node_id_to_graph_id, fout);
        fout << endl;
        fout << "edge_id_to_graph_id\n";
        print_map(edge_id_to_graph_id, fout);
        fout << endl;
        for (std::map<int, graph_genesis_new>::iterator itr = graph_id_to_genesis_map.begin(); itr != graph_id_to_genesis_map.end(); ++itr) {
            print_genesis_new(itr->first, fout);
        }
        fout.close();
    } else {
        cerr << "File " + file_name + " couldn't be opened" << endl;
    }
}

/*
   void GraphManagerNew::read_graph_xml_file_as_it_is(std::string input_file){
   GraphNew* graph_ptr = new GraphNew;
   int gid = ++GraphManagerNew::graph_id_count;
   graph_ptr->set_graph_id(gid);
   add_graph(gid, graph_ptr);
   XMLParser *my_parser = new XMLParser();//for parsing input xml file from KEGG
   my_parser->fill_graph_from_xml_file_as_it_is(graph_ptr, input_file, this);
   }
 */

int GraphManagerNew::read_graph_xml_file(std::string input_file, int thres,  vector<string>& MAPK_merged_ids, map<string, set<string> >& MAPK_node_to_pathway_id_map, bool tool_written) {
    GraphNew* graph_ptr = new GraphNew;
    int gid = ++GraphManagerNew::graph_id_count;
    graph_ptr->set_graph_id(gid);
    add_graph(gid, graph_ptr);
    
       
    XMLParser *my_parser = new XMLParser(); //for parsing input xml file from KEGG
    if (my_parser->fill_graph_from_xml_file(graph_ptr, input_file, this, thres, MAPK_merged_ids, MAPK_node_to_pathway_id_map, tool_written)) {
        //add component edges from components to complexes
        if (!tool_written) {
            graph_ptr->add_component_edges_for_complexes(this);
        }
        
        // populate adjacency matrix
        //fill_adj_matrix_for_graph(graph_ptr);

        // genesis
        list<int> empty_list;
        string oper = "read_graph from file: " + input_file;
        add_graph_genesis(gid, oper, empty_list);
        cout << "Read graph: " << gid << " from file " << input_file << endl;
        return gid;
    } else {
        --GraphManagerNew::graph_id_count;
        return -1;
    }
}

//void GraphManagerNew::create_map_from_sbml(string filename) {
//    SBMLParser *my_sbml_parser = new SBMLParser();
//    string map_file = "rmap.txt";
//    ofstream fout(map_file.c_str());
//
//    ifstream ifs(filename.c_str());
//    string file;
//
//    if (fout.is_open()) {
//        while (getline(ifs, file)) {
//            (*my_sbml_parser).create_map_from_sbml_file(fout, file);
//        }
//
//    } else {
//        cout << "Could not open file for writing" << endl;
//    }
//
//
//
//}

//int GraphManagerNew::read_graph_from_sbml(string sbmlfile) {
//
//    GraphNew* graph_ptr = new GraphNew;
//    int gid = ++GraphManagerNew::graph_id_count;
//    graph_ptr->set_graph_id(gid);
//    add_graph(gid, graph_ptr);
//    
//    // populate adjacency matrix
//    //fill_adj_matrix_for_graph(graph_ptr);
//    
//    SBMLParser *my_sbml_parser = new SBMLParser();
//
//    bool success = (*my_sbml_parser).fill_graph_from_sbml_file(graph_ptr, sbmlfile, this);
//
//    if (success) {
//        //add component edges from components to complexes
//        //graph_ptr->add_component_edges_for_complexes(this);
//        graph_ptr->add_component_edges_for_complexes_sbml(this);
//        // genesis
//        list<int> empty_list;
//        string oper = "read_graph from file: " + sbmlfile;
//        add_graph_genesis(gid, oper, empty_list);
//        cout << "Read graph: " << gid << " from file " << sbmlfile << endl;
//        return gid;
//    } else {
//        --GraphManagerNew::graph_id_count;
//        return -1;
//    }
//
//
//}

bool GraphManagerNew::fill_ppin_from_file(GraphNew* graph_ptr, string filename, GraphManagerNew* graph_man) {
    ifstream input_file(filename.c_str());
    string delim = "\t";
    string line;
    while (getline(input_file, line)) {
        // remove invalid characters
        char chars[] = ":";
        for (unsigned int i = 0; i < strlen(chars); ++i) {
            line.erase(std::remove(line.begin(), line.end(), chars[i]), line.end());
        }
        list<string> tokens;
        split_string_into_list(line, delim, tokens);
        string source_rep_id = tokens.front();
        tokens.pop_front();
        string source_display_name = tokens.front();
        tokens.pop_front();
        string target_rep_id = tokens.front();
        tokens.pop_front();
        string target_display_name = tokens.front();

        string node_type = "gene";
        int source_node_id = graph_ptr->check_if_node_already_created(source_rep_id);

        if (source_node_id == -1) {
            source_node_id = graph_ptr->create_new_node();

            //if failed to create node
            if (source_node_id == -1) {
                cerr << "Problem creating node in PPIN" << endl;
                destroy_graph(graph_ptr);
                return false;
            }
            graph_ptr->add_node_id(source_node_id);
            graph_ptr->add_rep_id_for_node(source_node_id, source_rep_id);
            graph_man->add_node_id_graph_id(source_node_id, graph_ptr->get_graph_id());
            graph_ptr->add_id_for_node(source_node_id, source_rep_id);
            graph_ptr->add_id_rep_id(source_rep_id, source_rep_id);
            graph_ptr->add_node_type(source_node_id, node_type);
            graph_ptr->add_display_id_for_node(source_node_id, source_display_name);
        }

        int target_node_id = graph_ptr->check_if_node_already_created(target_rep_id);
        if (target_node_id == -1) {
            target_node_id = graph_ptr->create_new_node();
            //if failed to create node
            if (target_node_id == -1) {
                cerr << "Problem creating node in PPIN" << endl;
                destroy_graph(graph_ptr);
                return false;
            }
            graph_ptr->add_node_id(target_node_id);
            graph_ptr->add_rep_id_for_node(target_node_id, target_rep_id);
            graph_man->add_node_id_graph_id(target_node_id, graph_ptr->get_graph_id());
            graph_ptr->add_id_for_node(target_node_id, target_rep_id);
            graph_ptr->add_id_rep_id(target_rep_id, target_rep_id);
            graph_ptr->add_node_type(target_node_id, node_type);
            graph_ptr->add_display_id_for_node(target_node_id, target_display_name);
        }

        string type = "PPrel";
        string subtype_ppin = "PPI";
        string pathway = "PPIN";
        vector<string> subtypes;
        subtypes.push_back(subtype_ppin);
        int eid = graph_ptr->check_if_edge_already_created(source_node_id, target_node_id, type, subtypes);
        if (eid == -1) {
            eid = graph_ptr->create_new_edge();
            if (eid == -1) {
                cerr << "Problem creating edge in PPIN" << endl;
                destroy_graph(graph_ptr);
                return false;
            }
            graph_ptr->add_edge_id(eid);
            graph_man->add_edge_id_graph_id(eid, graph_ptr->get_graph_id());
            graph_ptr->add_edge_type(eid, type);
            graph_ptr->add_edge_to_outlist_of_node(source_node_id, eid);
            graph_ptr->add_edge_to_inlist_of_node(target_node_id, eid);
            graph_ptr->add_source_node(eid, source_node_id);
            graph_ptr->add_target_node(eid, target_node_id);
            graph_ptr->add_subtype_for_edge(eid, subtype_ppin);
            graph_ptr->add_pathway_for_edge(eid, pathway);
        }
        // creating reverse edge
        int rev_eid = graph_ptr->check_if_edge_already_created(target_node_id, source_node_id, type, subtypes);

        if (rev_eid == -1) {
            rev_eid = graph_ptr->create_new_edge();
            if (rev_eid == -1) {
                cerr << "Problem creating reverse edge in PPIN" << endl;
                destroy_graph(graph_ptr);
                return false;
            }
            graph_ptr->add_edge_id(rev_eid);
            graph_man->add_edge_id_graph_id(rev_eid, graph_ptr->get_graph_id());
            graph_ptr->add_edge_type(rev_eid, type);
            graph_ptr->add_edge_to_outlist_of_node(target_node_id, rev_eid);
            graph_ptr->add_edge_to_inlist_of_node(source_node_id, rev_eid);
            graph_ptr->add_source_node(rev_eid, target_node_id);
            graph_ptr->add_target_node(rev_eid, source_node_id);
            graph_ptr->add_subtype_for_edge(rev_eid, subtype_ppin);
            graph_ptr->add_pathway_for_edge(rev_eid, pathway);
        }

    }

    return true;

}

int GraphManagerNew::create_graph_PPIN(string input_file) {
    GraphNew * graph_ptr = new GraphNew();
    int gid = ++GraphManagerNew::graph_id_count;
    graph_ptr->set_graph_id(gid);
    add_graph(gid, graph_ptr);
    
    // populate adjacency matrix
    //fill_adj_matrix_for_graph(graph_ptr);
    
    bool success = fill_ppin_from_file(graph_ptr, input_file, this);
    if (success) {
        list<int> empty_list;
        string oper = "read_ppin from file: " + input_file;
        add_graph_genesis(gid, oper, empty_list);
        return gid;
    } else {
        --GraphManagerNew::graph_id_count;
        return -1;
    }
}

bool GraphManagerNew::fill_htri_from_file(GraphNew* graph_ptr, string filename, GraphManagerNew* graph_man) {
    ifstream input_file(filename.c_str());
    string delim = "\t";
    string line;
    while (getline(input_file, line)) {
        // remove invalid characters
        char chars[] = ":";
        for (unsigned int i = 0; i < strlen(chars); ++i) {
            line.erase(std::remove(line.begin(), line.end(), chars[i]), line.end());
        }
        list<string> tokens;
        split_string_into_list(line, delim, tokens);
        string source_rep_id = tokens.front();
        tokens.pop_front();
        string source_display_name = tokens.front();
        tokens.pop_front();
        string target_rep_id = tokens.front();
        tokens.pop_front();
        string target_display_name = tokens.front();

        string node_type = "gene";
        int source_node_id = graph_ptr->check_if_node_already_created(source_rep_id);

        if (source_node_id == -1) {
            source_node_id = graph_ptr->create_new_node();

            //if failed to create node
            if (source_node_id == -1) {
                cerr << "Problem creating node in HTRI" << endl;
                destroy_graph(graph_ptr);
                return false;
            }
            graph_ptr->add_node_id(source_node_id);
            graph_ptr->add_rep_id_for_node(source_node_id, source_rep_id);
            graph_man->add_node_id_graph_id(source_node_id, graph_ptr->get_graph_id());
            graph_ptr->add_id_for_node(source_node_id, source_rep_id);
            graph_ptr->add_id_rep_id(source_rep_id, source_rep_id);
            graph_ptr->add_node_type(source_node_id, node_type);
            graph_ptr->add_display_id_for_node(source_node_id, source_display_name);
        }

        int target_node_id = graph_ptr->check_if_node_already_created(target_rep_id);
        if (target_node_id == -1) {
            target_node_id = graph_ptr->create_new_node();
            //if failed to create node
            if (target_node_id == -1) {
                cerr << "Problem creating node in HTRI" << endl;
                destroy_graph(graph_ptr);
                return false;
            }
            graph_ptr->add_node_id(target_node_id);
            graph_ptr->add_rep_id_for_node(target_node_id, target_rep_id);
            graph_man->add_node_id_graph_id(target_node_id, graph_ptr->get_graph_id());
            graph_ptr->add_id_for_node(target_node_id, target_rep_id);
            graph_ptr->add_id_rep_id(target_rep_id, target_rep_id);
            graph_ptr->add_node_type(target_node_id, node_type);
            graph_ptr->add_display_id_for_node(target_node_id, target_display_name);
        }

        string type = "GErel";
        string subtype_expr = "expression";
        string subtype_repr = "repression";
        string pathway = "HTRI";
        vector<string> subtypes1;
        vector<string> subtypes2;
        subtypes1.push_back(subtype_expr);
        subtypes2.push_back(subtype_repr);
        int eid = graph_ptr->check_if_edge_already_created(source_node_id, target_node_id, type, subtypes1);
        if (eid == -1) {
            eid = graph_ptr->create_new_edge();
            if (eid == -1) {
                cerr << "Problem creating expression edge in HTRI" << endl;
                destroy_graph(graph_ptr);
                return false;
            }
            graph_ptr->add_edge_id(eid);
            graph_man->add_edge_id_graph_id(eid, graph_ptr->get_graph_id());
            graph_ptr->add_edge_type(eid, type);
            graph_ptr->add_edge_to_outlist_of_node(source_node_id, eid);
            graph_ptr->add_edge_to_inlist_of_node(target_node_id, eid);
            graph_ptr->add_source_node(eid, source_node_id);
            graph_ptr->add_target_node(eid, target_node_id);
            graph_ptr->add_subtype_for_edge(eid, subtype_expr);
            graph_ptr->add_pathway_for_edge(eid, pathway);
        }
        eid = graph_ptr->check_if_edge_already_created(source_node_id, target_node_id, type, subtypes2);
        if (eid == -1) {
            eid = graph_ptr->create_new_edge();
            if (eid == -1) {
                cerr << "Problem creating repression edge in HTRI" << endl;
                destroy_graph(graph_ptr);
                return false;
            }
            graph_ptr->add_edge_id(eid);
            graph_man->add_edge_id_graph_id(eid, graph_ptr->get_graph_id());
            graph_ptr->add_edge_type(eid, type);
            graph_ptr->add_edge_to_outlist_of_node(source_node_id, eid);
            graph_ptr->add_edge_to_inlist_of_node(target_node_id, eid);
            graph_ptr->add_source_node(eid, source_node_id);
            graph_ptr->add_target_node(eid, target_node_id);
            graph_ptr->add_subtype_for_edge(eid, subtype_repr);
            graph_ptr->add_pathway_for_edge(eid, pathway);
        }

    }

    return true;

}

int GraphManagerNew::create_graph_HTRI(string input_file) {
    GraphNew * graph_ptr = new GraphNew();
    int gid = ++GraphManagerNew::graph_id_count;
    graph_ptr->set_graph_id(gid);
    add_graph(gid, graph_ptr);
    
    // populate adjacency matrix
    //fill_adj_matrix_for_graph(graph_ptr);
    
    bool success = fill_htri_from_file(graph_ptr, input_file, this);
    if (success) {
        list<int> empty_list;
        string oper = "read htri database from file: " + input_file;
        add_graph_genesis(gid, oper, empty_list);
        return gid;
    } else {
        --GraphManagerNew::graph_id_count;
        return -1;
    }
}

bool GraphManagerNew::fill_reactome_all_from_file(GraphNew* graph_ptr, string filename, GraphManagerNew* graph_man) {
    ifstream input_file(filename.c_str());
    string delim = "\t";
    string line;
    while (getline(input_file, line)) {
        // remove invalid characters
        char chars[] = ":";
        for (unsigned int i = 0; i < strlen(chars); ++i) {
            line.erase(std::remove(line.begin(), line.end(), chars[i]), line.end());
        }
        list<string> tokens;
        split_string_into_list(line, delim, tokens);
        string source_id = tokens.front();
        tokens.pop_front();
        //string source_display_name = tokens.front();
        tokens.pop_front();
        string target_id = tokens.front();
        tokens.pop_front();
        //string target_display_name = tokens.front();
        tokens.pop_front();
        string edge_annotation = tokens.front();
        tokens.pop_front();
        string edge_rep_id = tokens.front();
        //
        string edge_display_id = edge_rep_id;
        edge_rep_id.erase(edge_rep_id.begin(), edge_rep_id.begin() + 6);
        edge_rep_id = "reaction-" + edge_rep_id;

        //


        string node_type = "gene"; //"protein"
        string source_rep_id = source_id;
        map<string, string>::iterator all_id_iter = all_id_map.find(source_id);
        if (all_id_iter != all_id_map.end()) {
            source_rep_id = all_id_iter->second;
        }

        string target_rep_id = target_id;
        all_id_iter = all_id_map.find(target_id);
        if (all_id_iter != all_id_map.end()) {
            target_rep_id = all_id_iter->second;
        }

        string source_display_name = kegg_hsa_id_to_display_name_map[source_rep_id];
        string target_display_name = kegg_hsa_id_to_display_name_map[target_rep_id];
        //create edge only for reaction type
        if (edge_annotation == "reaction") {


            int source_node_id = graph_ptr->check_if_node_already_created(source_rep_id);

            if (source_node_id == -1) {
                source_node_id = graph_ptr->create_new_node();

                //if failed to create node
                if (source_node_id == -1) {
                    cerr << "Problem creating node in Reactome full" << endl;
                    destroy_graph(graph_ptr);
                    return false;
                }
                graph_ptr->add_node_id(source_node_id);
                graph_ptr->add_rep_id_for_node(source_node_id, source_rep_id);
                graph_man->add_node_id_graph_id(source_node_id, graph_ptr->get_graph_id());
                graph_ptr->add_id_for_node(source_node_id, source_rep_id);
                graph_ptr->add_id_rep_id(source_rep_id, source_rep_id);
                graph_ptr->add_node_type(source_node_id, node_type);
                graph_ptr->add_display_id_for_node(source_node_id, source_display_name);
            }

            int target_node_id = graph_ptr->check_if_node_already_created(target_rep_id);
            if (target_node_id == -1) {
                target_node_id = graph_ptr->create_new_node();
                //if failed to create node
                if (target_node_id == -1) {
                    cerr << "Problem creating node in Reactome full" << endl;
                    destroy_graph(graph_ptr);
                    return false;
                }
                graph_ptr->add_node_id(target_node_id);
                graph_ptr->add_rep_id_for_node(target_node_id, target_rep_id);
                graph_man->add_node_id_graph_id(target_node_id, graph_ptr->get_graph_id());
                graph_ptr->add_id_for_node(target_node_id, target_rep_id);
                graph_ptr->add_id_rep_id(target_rep_id, target_rep_id);
                graph_ptr->add_node_type(target_node_id, node_type);
                graph_ptr->add_display_id_for_node(target_node_id, target_display_name);
            }

            //int reaction_node_id = graph_ptr->check_if_node_already_created(edge_rep_id);
            //if(reaction_node_id == -1){
            int reaction_node_id = graph_ptr->create_new_node();
            //if failed to create node
            if (reaction_node_id == -1) {
                cerr << "Problem creating reaction node in Reactome full" << endl;
                destroy_graph(graph_ptr);
                return false;
            }
            string edge_type = "reaction";

            graph_ptr->add_node_id(reaction_node_id);
            graph_ptr->add_rep_id_for_node(reaction_node_id, edge_rep_id);
            graph_man->add_node_id_graph_id(reaction_node_id, graph_ptr->get_graph_id());
            graph_ptr->add_id_for_node(reaction_node_id, edge_rep_id);
            graph_ptr->add_id_rep_id(edge_rep_id, edge_rep_id);
            graph_ptr->add_node_type(reaction_node_id, edge_type);
            graph_ptr->add_display_id_for_node(reaction_node_id, edge_display_id);
            graph_ptr->add_description_for_node(reaction_node_id, edge_display_id);
            //}



            string pathway = "Reactome_all";
            vector<string> subtypes;
            subtypes.push_back(edge_annotation);

            //int eid = graph_ptr->check_if_edge_already_created(source_node_id, target_node_id, edge_type, subtypes); // no need for this check for this file

            //if (eid == -1){
            //eid = graph_ptr->create_new_edge();
            int eid = graph_ptr->create_new_edge();
            if (eid == -1) {
                cerr << "Problem creating edge in Reactome full" << endl;
                destroy_graph(graph_ptr);
                return false;
            }
            graph_ptr->add_edge_id(eid);
            graph_man->add_edge_id_graph_id(eid, graph_ptr->get_graph_id());
            graph_ptr->add_edge_type(eid, edge_type);
            graph_ptr->add_edge_to_outlist_of_node(source_node_id, eid);
            graph_ptr->add_edge_to_inlist_of_node(reaction_node_id, eid);
            graph_ptr->add_source_node(eid, source_node_id);
            graph_ptr->add_target_node(eid, reaction_node_id);
            graph_ptr->add_subtype_for_edge(eid, edge_annotation);
            graph_ptr->add_pathway_for_edge(eid, pathway);
            //}

            int rev_eid = graph_ptr->create_new_edge();
            if (rev_eid == -1) {
                cerr << "Problem creating reverse edge in Reactome full" << endl;
                destroy_graph(graph_ptr);
                return false;
            }
            graph_ptr->add_edge_id(rev_eid);
            graph_man->add_edge_id_graph_id(rev_eid, graph_ptr->get_graph_id());
            graph_ptr->add_edge_type(rev_eid, edge_type);
            graph_ptr->add_edge_to_outlist_of_node(reaction_node_id, rev_eid);
            graph_ptr->add_edge_to_inlist_of_node(source_node_id, rev_eid);
            graph_ptr->add_source_node(rev_eid, reaction_node_id);
            graph_ptr->add_target_node(rev_eid, source_node_id);
            graph_ptr->add_subtype_for_edge(rev_eid, edge_annotation);
            graph_ptr->add_pathway_for_edge(rev_eid, pathway);




            eid = graph_ptr->create_new_edge();
            if (eid == -1) {
                cerr << "Problem creating edge in Reactome full" << endl;
                destroy_graph(graph_ptr);
                return false;
            }
            graph_ptr->add_edge_id(eid);
            graph_man->add_edge_id_graph_id(eid, graph_ptr->get_graph_id());
            graph_ptr->add_edge_type(eid, edge_type);
            graph_ptr->add_edge_to_outlist_of_node(reaction_node_id, eid);
            graph_ptr->add_edge_to_inlist_of_node(target_node_id, eid);
            graph_ptr->add_source_node(eid, reaction_node_id);
            graph_ptr->add_target_node(eid, target_node_id);
            graph_ptr->add_subtype_for_edge(eid, edge_annotation);
            graph_ptr->add_pathway_for_edge(eid, pathway);
            //}

            rev_eid = graph_ptr->create_new_edge();
            if (rev_eid == -1) {
                cerr << "Problem creating reverse edge in Reactome full" << endl;
                destroy_graph(graph_ptr);
                return false;
            }
            graph_ptr->add_edge_id(rev_eid);
            graph_man->add_edge_id_graph_id(rev_eid, graph_ptr->get_graph_id());
            graph_ptr->add_edge_type(rev_eid, edge_type);
            graph_ptr->add_edge_to_outlist_of_node(target_node_id, rev_eid);
            graph_ptr->add_edge_to_inlist_of_node(reaction_node_id, rev_eid);
            graph_ptr->add_source_node(rev_eid, target_node_id);
            graph_ptr->add_target_node(rev_eid, reaction_node_id);
            graph_ptr->add_subtype_for_edge(rev_eid, edge_annotation);
            graph_ptr->add_pathway_for_edge(rev_eid, pathway);

        }
    }

    return true;

}

int GraphManagerNew::create_graph_reactome_all(string input_file) {
    GraphNew * graph_ptr = new GraphNew();
    int gid = ++GraphManagerNew::graph_id_count;
    graph_ptr->set_graph_id(gid);
    add_graph(gid, graph_ptr);
    
    // populate adjacency matrix
    //fill_adj_matrix_for_graph(graph_ptr);
    
    bool success = fill_reactome_all_from_file(graph_ptr, input_file, this);
    if (success) {
        list<int> empty_list;
        string oper = "read Reactome all interactions network from file: " + input_file;
        add_graph_genesis(gid, oper, empty_list);
        return gid;
    } else {
        --GraphManagerNew::graph_id_count;
        return -1;
    }
}

int GraphManagerNew::add_phenotype_edges(string filename) {
    GraphNew * graph_ptr = new GraphNew();
    int gid = ++GraphManagerNew::graph_id_count;
    graph_ptr->set_graph_id(gid);
    add_graph(gid, graph_ptr);

    // populate adjacency matrix
    //fill_adj_matrix_for_graph(graph_ptr);
    
    ifstream input_file(filename.c_str());
    string delim = "\t";
    string line;
    while (getline(input_file, line)) {
        // remove invalid characters
        char chars[] = ":";
        for (unsigned int i = 0; i < strlen(chars); ++i) {
            line.erase(std::remove(line.begin(), line.end(), chars[i]), line.end());
        }
        list<string> tokens;
        split_string_into_list(line, delim, tokens);
        string source_rep_id = tokens.front();
        tokens.pop_front();
        string source_node_type = tokens.front();
        tokens.pop_front();
        string target_rep_id = tokens.front();
        tokens.pop_front();
        string target_node_type = tokens.front();
        tokens.pop_front();
        string pathway = tokens.front();


        string source_display_name = this->get_display_names_from_rep_id(source_rep_id);
        string target_display_name = this->get_display_names_from_rep_id(target_rep_id);
        int source_node_id = graph_ptr->check_if_node_already_created(source_rep_id);

        if (source_node_id == -1) {
            source_node_id = graph_ptr->create_new_node();

            //if failed to create node
            if (source_node_id == -1) {
                cerr << "Problem creating phenotype node" << endl;
                destroy_graph(graph_ptr);
                return false;
            }
            graph_ptr->add_node_id(source_node_id);
            graph_ptr->add_rep_id_for_node(source_node_id, source_rep_id);
            this->add_node_id_graph_id(source_node_id, graph_ptr->get_graph_id());
            graph_ptr->add_id_for_node(source_node_id, source_rep_id);
            graph_ptr->add_id_rep_id(source_rep_id, source_rep_id);
            graph_ptr->add_node_type(source_node_id, source_node_type);
            graph_ptr->add_display_id_for_node(source_node_id, source_display_name);
        }

        int target_node_id = graph_ptr->check_if_node_already_created(target_rep_id);
        if (target_node_id == -1) {
            target_node_id = graph_ptr->create_new_node();
            //if failed to create node
            if (target_node_id == -1) {
                cerr << "Problem creating phenotype node" << endl;
                destroy_graph(graph_ptr);
                return false;
            }
            graph_ptr->add_node_id(target_node_id);
            graph_ptr->add_rep_id_for_node(target_node_id, target_rep_id);
            this->add_node_id_graph_id(target_node_id, graph_ptr->get_graph_id());
            graph_ptr->add_id_for_node(target_node_id, target_rep_id);
            graph_ptr->add_id_rep_id(target_rep_id, target_rep_id);
            graph_ptr->add_node_type(target_node_id, target_node_type);
            graph_ptr->add_display_id_for_node(target_node_id, target_display_name);
        }

        string type = "Phenotype";
        string subtype = "indirect";

        vector<string> subtypes;
        subtypes.push_back(subtype);
        int eid = graph_ptr->check_if_edge_already_created(source_node_id, target_node_id, type, subtypes);
        if (eid == -1) {
            eid = graph_ptr->create_new_edge();
            if (eid == -1) {
                cerr << "Problem creating phenotype edge" << endl;
                destroy_graph(graph_ptr);
                return false;
            }
            graph_ptr->add_edge_id(eid);
            this->add_edge_id_graph_id(eid, graph_ptr->get_graph_id());
            graph_ptr->add_edge_type(eid, type);
            graph_ptr->add_edge_to_outlist_of_node(source_node_id, eid);
            graph_ptr->add_edge_to_inlist_of_node(target_node_id, eid);
            graph_ptr->add_source_node(eid, source_node_id);
            graph_ptr->add_target_node(eid, target_node_id);
            graph_ptr->add_subtype_for_edge(eid, subtype);
            graph_ptr->add_pathway_for_edge(eid, pathway);
        }

    }
    return graph_ptr->get_graph_id();

}

void GraphManagerNew::destroy_graph(GraphNew* graph_ptr) {
    int gid = graph_ptr->get_graph_id();
    //cout << "destroying graph: " << gid << endl;

    //remove all edge-level information of this graph if any
    std::vector<int> edges_in_graph = graph_ptr->get_edge_ids();

    for (std::vector<int>::iterator edge_itr = edges_in_graph.begin(); edge_itr != edges_in_graph.end(); ++edge_itr) {
        delete_edge_id_graph_id(*edge_itr);
        EdgeNew* to_delete = graph_ptr->get_edge_from_eid(*edge_itr);
        if (to_delete) {
            delete to_delete;
        }
    }

    std::vector<int> nodes_in_graph = graph_ptr->get_node_ids();
    //remove all node-level information of this graph
    for (std::vector<int>::iterator node_itr = nodes_in_graph.begin(); node_itr != nodes_in_graph.end(); node_itr++) {
        delete_node_id_graph_id(*node_itr);
        NodeNew* to_delete = graph_ptr->get_node_from_nid(*node_itr);
        if (to_delete) {
            delete to_delete;
        }
    }
    //remove all graph-level information of this graph
    delete_graph_id_graph(gid);
    delete_from_map(graph_id_to_genesis_map, gid);
}

void GraphManagerNew::generate_constraints_using_rules_parser(int gid, list<rule_t* >& list_of_rules, t_ExpressionManager *em) {
    GraphNew* graph_ptr = get_graph(gid);
    if (graph_ptr == NULL) {
        cerr << "Error: no graph for graph id: " << gid << endl;
        return;
    }
    vector<t_Expression*> constraints_for_all_rules_vec; //stores constraints for all the rules
    int rule_num = 1;
    for (list<rule_t*>::iterator rule_itr = list_of_rules.begin(); rule_itr != list_of_rules.end(); rule_itr++) {
        rule_t* curr_rule_ptr = *rule_itr;
        t_Expression* cons_for_rule = get_constraints_for_rule(curr_rule_ptr, graph_ptr, em);
        if (cons_for_rule) {
            constraints_for_all_rules_vec.push_back(cons_for_rule);
        } else {
            cerr << "No constraints for rule: " << rule_num << endl;
        }
        rule_num++;
    }

    char include_DAG_reach_path_constraints;
    cout << "\nEnter 'y' or 'Y' to DAG reachable path constraints as well, or any other key to not: ";
    cin >> include_DAG_reach_path_constraints;

    if (include_DAG_reach_path_constraints == 'y' || include_DAG_reach_path_constraints == 'Y') {
        t_Expression* reach_path_constraints = graph_ptr->get_DAG_reach_path_constraints(em, this);
        if (reach_path_constraints == NULL) {
            cout << "Note: there are no path reach constraints" << endl;
        } else {
            constraints_for_all_rules_vec.push_back(reach_path_constraints);
        }
    }

    char reachability_at_constraint_solver_level;
    cout << "\nEnter 'y' or 'Y' to do reachability from perturbed node to differentially expressed nodes via constraint solving, or any other key to not: ";
    cin >> reachability_at_constraint_solver_level;

    if (reachability_at_constraint_solver_level == 'y' || reachability_at_constraint_solver_level == 'Y') {
        t_Expression* reach_constraint_solver_constraints = graph_ptr->get_reach_path_constraints(em, this);
        if (reach_constraint_solver_constraints == NULL) {
            cout << "Note: there are no constraints for doing constraint solving for reachability" << endl;
        } else {
            constraints_for_all_rules_vec.push_back(reach_constraint_solver_constraints);
        }
    }

    vector<t_Expression*>::iterator expr_vec_itr;
    /*assert(!constraints_for_all_rules_vec.empty());
      vector<t_Expression*>::iterator expr_vec_itr = constraints_for_all_rules_vec.begin();
      t_Expression* expr1 = *expr_vec_itr;
      assert(expr1);
      ++expr_vec_itr;
      while(expr_vec_itr != constraints_for_all_rules_vec.end()){
      t_Expression* expr2 = *expr_vec_itr;
      assert(expr2);
      expr1 = build_AND_constraints(expr1, expr2, 0, 0, em);
      ++expr_vec_itr;
      }*/

    /*char include_reach_path_constraints;
      cout << "\nEnter 'y' or 'Y' to reachable path constraints as well, or any other key to not: ";
      cin >> include_reach_path_constraints;

      if(include_reach_path_constraints == 'y' || include_reach_path_constraints == 'Y'){
      t_Expression* reach_path_constraints = graph_ptr->get_reach_path_constraints(em, this);
      if(reach_path_constraints == NULL){
      cout << "Note: there are no path reach constraints" << endl;
      }
      else{
      if(expr1 == NULL){
      expr1 = reach_path_constraints;
      }
      else{
      t_Expression* temp = build_AND_constraints(expr1, reach_path_constraints, 0, 0, em);
      expr1 = temp;
      }

      }
      }*/

    char choice;
    cout << "\nEnter 'y' to include microarray data in the constraints, \n or any other key to exclude microarray data ";
    cin >> choice;

    if (choice == 'y') {
        string micro_arr_decl;
        string micro_arr_assert;

        cout << "\nEnter the relative filepath to micro array declarations: ";
        cin >> micro_arr_decl;

        cout << "\nEnter the relative filepath to micro array assertions: ";
        cin >> micro_arr_assert;

        /*string micro_arr_decl = "psmd9_decl";
          string micro_arr_assert = "psmd9_assert";*/

        expr_vec_itr = constraints_for_all_rules_vec.begin();
        vector<t_Expression*> graph_micrarr_constraints = get_microarray_constraints(micro_arr_decl, micro_arr_assert, em);
        while (expr_vec_itr != constraints_for_all_rules_vec.end()) {
            graph_micrarr_constraints.push_back(*expr_vec_itr);
            ++expr_vec_itr;
        }

        char solve;
        cout << "\nEnter 'y' to solve the total constraints, \n or any other key to not ";
        cin >> solve;

        if (solve == 'y') {
            solve_constraints(graph_micrarr_constraints, em);
        }
    } else {
        char solve;
        cout << "\nEnter 'y' to solve constraints without microarray data, \n or any other key to not ";
        cin >> solve;

        if (solve == 'y') {
            solve_constraints(constraints_for_all_rules_vec, em);
        }
    }

    //following is just for writing to test_em file for inspection if needed
    t_Expression* expr1 = NULL;
    expr_vec_itr = constraints_for_all_rules_vec.begin();
    if (constraints_for_all_rules_vec.empty()) {
        cout << "Note: no constraints found for the given rules" << endl;
    } else {
        expr1 = *expr_vec_itr;
        assert(expr1);
        ++expr_vec_itr;
        while (expr_vec_itr != constraints_for_all_rules_vec.end()) {
            t_Expression* expr2 = *expr_vec_itr;
            assert(expr2);
            expr1 = build_AND_constraints(expr1, expr2, 0, 0, em);
            ++expr_vec_itr;
        }
    }
    t_Expression* constraints_all_rules = expr1; //got ANDing of all rules

    if (constraints_all_rules == NULL) {
        cout << "Note: no constraints generated, returning..." << endl;
    }

    //string test_constraints_out_file = "test";
    ofstream fout("test_em");

    if (fout.is_open()) {
        //em->printExpressionsToFileInSMT(constraints_all_rules, "test_smt");
        em->printExpressionToFileAsDAG("constraintsAllRules ", constraints_all_rules, fout);
        fout.close();
    } else {
        cerr << "\nUnable to open the output file test_em for constraints testing " << endl;
    }
}

t_Expression* GraphManagerNew::get_constraints_for_rule(rule_t* rule_ptr, GraphNew* graph_ptr, t_ExpressionManager* em) {
    //map<string, pair<quantifier_t, vector<Node*> > > antecedent_map;
    list_antecedent_t* antecedent_list = rule_ptr->antecedent;
    //set<map<string, Node*> * > set_tuples; //this set will store the final tuples obtained by going through all antecedents
    //set<map<string, Node*> > set_tuples; //this set will store the final tuples obtained by going through all antecedents (antecedents come before colon)
    //access_antecdents_for_filling_tuples(antecedent_list, set_tuples, graph);

    //static int i = 1;
    RuleTupleStoreNew tuple_store_obj(antecedent_list, graph_ptr, this); //tuples constructed in tuplle_store_obj
    //cout << "\nprinting tuples for rule: " << i << endl;
    //tuple_store_obj.print_all_tuples(graph_ptr);
    //++i;
    //for testing just print the tuples
    //print_all_tuples(set_tuples);

    /*consequent_t* consequent_curr_rule = rule_ptr->consequent;
      logical_stmt_t*  left_of_implication = consequent_curr_rule->left_of_implies;
      logical_stmt_t* right_of_implication = consequent_curr_rule->right_of_implies;*/
    //cout << "getting constraints for current rule" << endl;
    t_Expression* constraint_for_rule = tuple_store_obj.get_constraint_em(rule_ptr->consequent, em, this, graph_ptr);
    return constraint_for_rule;
    /*
       vector<t_Expression* > constraints_for_a_rule;//one element is the constraint for one tuple

       set<map<string, Node*> >::iterator set_tuples_itr;

    //go over each tuple and apply constraints on each tuple and fill it in the vector constraints_for_a_rule
    for(set_tuples_itr = set_tuples.begin(); set_tuples_itr != set_tuples.end(); ++set_tuples_itr){
    map<string, Node*> curr_tuple = *set_tuples_itr;
    t_Expression* constraint_for_current_tuple = get_constraint_for_tuple(curr_tuple, left_of_implication, right_of_implication, em);
    //em->printExpressionToFileAsDAG("curr_tuple", constraint_for_current_tuple, cout);
    constraints_for_a_rule.push_back(constraint_for_current_tuple);
    }*/

    //now constraints_for_a_rule contains all constraints for a rule pointed to by rule_ptr, all these need to be ANDed
}

set<int> GraphManagerNew::find_set_of_nodes_for_tuple(string& var_name, GraphNew* graph, set_nodes_t* set_nodes_parser, map<string, int>& tuple_ref) {
    //find the set of nodes as specified by set of nodes from the parser set_nodes_parser
    set<int> set_nodes_to_return;

    //base cases are the ones that have no operator in set_nodes_parser
    if (set_nodes_parser->opr == NONE_OPR) {
        //the case of returning all nodes in the graph
        if (set_nodes_parser->fun_name == ALL_NODES_FUN) {
            vector<int> NIDSg = graph->get_node_ids();
            set_nodes_to_return.insert(NIDSg.begin(), NIDSg.end());
        } else if (set_nodes_parser->fun_name == NODE_TYPE_FUN) {
            node_t node_type = set_nodes_parser->arg3_node;
            string node_type_str = get_node_type_str_from_node_type_parser(node_type);
            vector<int> NIDSg = graph->get_node_ids();
            for (vector<int>::iterator node_itr = NIDSg.begin(); node_itr != NIDSg.end(); ++node_itr) {
                if (graph->get_node_type(*node_itr) == node_type_str) {
                    set_nodes_to_return.insert(*node_itr);
                }
            }
        } else if (set_nodes_parser->fun_name == EDGE_TYPE_FUN || set_nodes_parser->fun_name == EDGE_SUBTYPE_FUN || set_nodes_parser->fun_name == EDGE_FUN) {
            if (tuple_ref.empty()) {
                cerr << "Error: existing tuples shouldn't be empty for EDGE(y,x,...), EDGE_TYPE(y,x,...) AND EDGE_SUBTYPE(y,x,...) cases, exiting . . ." << endl;
                exit(1);
            }
            string arg1(set_nodes_parser->arg1);
            string arg2(set_nodes_parser->arg2);

            map<string, int>::iterator map_itr;

            //curr_var_name becomes source node
            if (arg1 == var_name) {
                map_itr = tuple_ref.find(arg2);
                if (map_itr == tuple_ref.end()) {
                    cerr << "The argument variable " << arg2 << " couldn't be found, continuing . . ." << endl;
                } else {
                    if (set_nodes_parser->fun_name == EDGE_TYPE_FUN) {
                        edge_t edge_type = set_nodes_parser->arg3_edge;
                        get_source_nodes(set_nodes_to_return, map_itr->second, edge_type, graph);
                    } else if (set_nodes_parser->fun_name == EDGE_SUBTYPE_FUN) {
                        edge_subt edge_subtype = set_nodes_parser->arg3_edgesub;
                        get_source_nodes(set_nodes_to_return, map_itr->second, edge_subtype, graph);
                    } else if (set_nodes_parser->fun_name == EDGE_FUN) {
                        edge_t edge_type = set_nodes_parser->arg3_edge;
                        list_edge_subtypes_t* edge_sub_list = set_nodes_parser->arg4_edgesub_list;
                        get_source_nodes(set_nodes_to_return, map_itr->second, edge_type, edge_sub_list, graph);
                    }
                }
            }//curr_var_name becomes target node
            else if (arg2 == var_name) {
                map_itr = tuple_ref.find(arg1);
                if (map_itr == tuple_ref.end()) {
                    cerr << "The argument variable " << arg1 << " couldn't be found, continuing . . ." << endl;
                } else {
                    if (set_nodes_parser->fun_name == EDGE_TYPE_FUN) {
                        edge_t edge_type = set_nodes_parser->arg3_edge;
                        get_target_nodes(set_nodes_to_return, map_itr->second, edge_type, graph);
                    } else if (set_nodes_parser->fun_name == EDGE_SUBTYPE_FUN) {
                        edge_subt edge_subtype = set_nodes_parser->arg3_edgesub;
                        get_target_nodes(set_nodes_to_return, map_itr->second, edge_subtype, graph);
                    } else if (set_nodes_parser->fun_name == EDGE_FUN) {
                        edge_t edge_type = set_nodes_parser->arg3_edge;
                        list_edge_subtypes_t* edge_sub_list = set_nodes_parser->arg4_edgesub_list;
                        get_target_nodes(set_nodes_to_return, map_itr->second, edge_type, edge_sub_list, graph);
                    }
                }
            } else {
                cerr << "Error: current variable name doesn't match one of the arguments, exiting . . ." << endl;
                exit(1);
            }
        } else if (set_nodes_parser->fun_name == PRED_FUN || set_nodes_parser->fun_name == SUCC_FUN) {
            if (tuple_ref.empty()) {
                cerr << "Error: existing tuples shouldn't be empty for PRED(x) or SUCC(x) cases, exiting . . ." << endl;
                exit(1);
            }
            string arg1(set_nodes_parser->arg1);
            map<string, int>::iterator map_itr;
            map_itr = tuple_ref.find(arg1);

            if (set_nodes_parser->fun_name == SUCC_FUN) {
                vector<int> out_list = graph->get_outlist(map_itr->second);
                for (vector<int>::iterator out_itr = out_list.begin(); out_itr != out_list.end(); ++out_itr) {
                    set_nodes_to_return.insert(graph->get_target_node(*out_itr));
                }
            } else if (set_nodes_parser->fun_name == PRED_FUN) {
                vector<int> in_list = graph->get_inlist(map_itr->second);
                for (vector<int>::iterator in_itr = in_list.begin(); in_itr != in_list.end(); ++in_itr) {
                    set_nodes_to_return.insert(graph->get_source_node(*in_itr));
                }
            }
        } else if (set_nodes_parser->fun_name == NODE_INPUT_EDGE_TYPE_FUN || set_nodes_parser->fun_name == NODE_OUTPUT_EDGE_TYPE_FUN || set_nodes_parser->fun_name == NODE_INPUT_EDGE_SUBTYPE_FUN || set_nodes_parser->fun_name == NODE_OUTPUT_EDGE_SUBTYPE_FUN) {
            //go over each node and check if its incoming or outgoing edge as required satisfies the criteria and accordingly insert it into the set
            vector<int> NIDSg = graph->get_node_ids();
            for (vector<int>::iterator node_itr = NIDSg.begin(); node_itr != NIDSg.end(); ++node_itr) {
                bool insert_node = false; //when this tag is true then insert the current node
                if (set_nodes_parser->fun_name == NODE_INPUT_EDGE_TYPE_FUN) {
                    edge_t edge_type = set_nodes_parser->arg3_edge;
                    insert_node = node_has_input_edge_of_type(*node_itr, edge_type, graph);
                } else if (set_nodes_parser->fun_name == NODE_OUTPUT_EDGE_TYPE_FUN) {
                    edge_t edge_type = set_nodes_parser->arg3_edge;
                    insert_node = node_has_output_edge_of_type(*node_itr, edge_type, graph);
                } else if (set_nodes_parser->fun_name == NODE_INPUT_EDGE_SUBTYPE_FUN) {
                    edge_subt edge_subtype = set_nodes_parser->arg3_edgesub;
                    insert_node = node_has_input_edge_of_subtype(*node_itr, edge_subtype, graph);
                } else if (set_nodes_parser->fun_name == NODE_OUTPUT_EDGE_SUBTYPE_FUN) {
                    edge_subt edge_subtype = set_nodes_parser->arg3_edgesub;
                    insert_node = node_has_output_edge_of_subtype(*node_itr, edge_subtype, graph);
                }
                if (insert_node) {
                    set_nodes_to_return.insert(*node_itr);
                }
            }
        } else if (set_nodes_parser->fun_name == NONE_FUN) {
            cerr << "NONE_FUN seen, exiting . . ." << endl;
            exit(1);
        }
    }//for other case make recursive calls//for other case make recursive calls
    else if (set_nodes_parser->opr == OR_OPR || set_nodes_parser->opr == AND_OPR) {
        set<int> left_set = find_set_of_nodes_for_tuple(var_name, graph, set_nodes_parser->left, tuple_ref);
        set<int> right_set = find_set_of_nodes_for_tuple(var_name, graph, set_nodes_parser->right, tuple_ref);
        if (set_nodes_parser->opr == OR_OPR) {
            set_union(left_set.begin(), left_set.end(), right_set.begin(), right_set.end(), inserter(set_nodes_to_return, set_nodes_to_return.begin()));
        } else if (set_nodes_parser->opr == AND_OPR) {
            set_intersection(left_set.begin(), left_set.end(), right_set.begin(), right_set.end(), inserter(set_nodes_to_return, set_nodes_to_return.begin()));
        }
    } else if (set_nodes_parser->opr == NOT_OPR) {
        set<int> to_negate_set = find_set_of_nodes_for_tuple(var_name, graph, set_nodes_parser->left, tuple_ref);
        vector<int> NIDSg = graph->get_node_ids();
        set<int> universe_set(NIDSg.begin(), NIDSg.end());
        set_difference(universe_set.begin(), universe_set.end(), to_negate_set.begin(), to_negate_set.end(), inserter(set_nodes_to_return, set_nodes_to_return.begin()));
    }
    return set_nodes_to_return;
}

string GraphManagerNew::get_node_type_str_from_node_type_parser(node_t node_type) {
    if (node_type == GENE_NODE) {
        return string("gene");
    } else if (node_type == GROUP_NODE) {
        return string("group");
    } else if (node_type == COMPOUND_NODE) {
        return string("compound");
    } else if (node_type == NONE_NODE) {
        cerr << "Can't convert NONE_NODE to string, exiting . . ." << endl;
        exit(1);
    } else {
        cerr << "Unknown node type, bug???, exiting . . ." << endl;
        exit(1);
    }
}

string GraphManagerNew::get_edge_type_str_from_edge_type_parser(edge_t edge_type) {
    if (edge_type == PPREL_EDGE) {
        return string("PPrel");
    } else if (edge_type == ECREL_EDGE) {
        return string("ECrel");
    } else if (edge_type == GEREL_EDGE) {
        return string("GErel");
    } else if (edge_type == PCREL_EDGE) {
        return string("PCrel");
    } else if (edge_type == NONE_EDGE) {
        cerr << "Can't convert NONE_EDGE to string, bug??? exiting . . ." << endl;
        exit(1);
    } else {
        cerr << "Unknown edge type, bug???, exiting . . ." << endl;
        exit(1);
    }
}

string GraphManagerNew::get_edge_subtype_str_from_edge_subtype_parser(edge_subt edge_subtype) {
    if (edge_subtype == ACTIVE_EDGE) {
        return string("activation");
    } else if (edge_subtype == INHIBIT_EDGE) {
        return string("inhibition");
    } else if (edge_subtype == EXPRESS_EDGE) {
        return string("expression");
    } else if (edge_subtype == REPRESS_EDGE) {
        return string("repression");
    } else if (edge_subtype == INDIRECT_EDGE) {
        return string("indirect");
    } else if (edge_subtype == STATE_CHANGE_EDGE) {
        return string("state");
    } else if (edge_subtype == ASSOC_EDGE) {
        return string("association");
    } else if (edge_subtype == DISSOC_EDGE) {
        return string("dissociation");
    } else if (edge_subtype == MISSING_INTERACTION_EDGE) {
        return string("missing");
    } else if (edge_subtype == STATE_CHANGE_EDGE) {
        return string("state");
    } else if (edge_subtype == COMPONENT_EDGE) {
        return string("component");
    } else if (edge_subtype == NONE_EDGE_SUB) {
        cerr << "Can't convert NONE_EDGE_SUB to string, bug??? exiting . . ." << endl;
        exit(1);
    } else {
        cerr << "Unknown edge subtype, bug???, exiting . . ." << endl;
        exit(1);
    }
}

std::vector<std::string> GraphManagerNew::get_vector_edge_subtype_str_from_edge_subtype_parser_list(list_edge_subtypes_t* list_edge_subtypes) {
    vector<string> to_return;
    while (list_edge_subtypes) {
        string curr_subtype = get_edge_subtype_str_from_edge_subtype_parser(list_edge_subtypes->edge_subtype_data);
        to_return.push_back(curr_subtype);
        list_edge_subtypes = list_edge_subtypes->next;
    }
    return to_return;
}

std::vector<std::string> GraphManagerNew::get_non_negated_edge_subtypes(ANDed_edgesub_literals_t* ANDed_clause) {
    vector<string> to_return;
    while (ANDed_clause) {
        edge_subt_literal_t* curr_subtype_literal = ANDed_clause->curr_literal;
        if (curr_subtype_literal->opr == NONE_OPR) {
            string curr_subtype = get_edge_subtype_str_from_edge_subtype_parser(curr_subtype_literal->edge_subtype_data);
            to_return.push_back(curr_subtype);
        } else if (curr_subtype_literal->opr == AND_OPR || curr_subtype_literal->opr == OR_OPR) {
            cerr << "Error: can't have AND_OPR, OR_OPR for a liters, either NONE_OPR or NOT_OPR allowed --- bug!!!, exiting..." << endl;
            exit(1);
        }
        ANDed_clause = ANDed_clause->next;
    }
    return to_return;
}

std::vector<std::string> GraphManagerNew::get_negated_edge_subtypes(ANDed_edgesub_literals_t* ANDed_clause) {
    vector<string> to_return;
    while (ANDed_clause) {
        edge_subt_literal_t* curr_subtype_literal = ANDed_clause->curr_literal;
        if (curr_subtype_literal->opr == NOT_OPR) {
            string curr_subtype = get_edge_subtype_str_from_edge_subtype_parser(curr_subtype_literal->edge_subtype_data);
            to_return.push_back(curr_subtype);
        } else if (curr_subtype_literal->opr == AND_OPR || curr_subtype_literal->opr == OR_OPR) {
            cerr << "Error: can't have AND_OPR, OR_OPR for a liters, either NONE_OPR or NOT_OPR allowed --- bug!!!, exiting..." << endl;
            exit(1);
        }
        ANDed_clause = ANDed_clause->next;
    }
    return to_return;
}

//fill node_array with the the nodes that are the source nodes
//of the edges of edge_type directed to target_node_id

void GraphManagerNew::get_source_nodes(set<int>& source_node_array, int target_node_id, edge_t edge_type, GraphNew* graph_ptr) {
    vector<int> target_inlist = graph_ptr->get_inlist(target_node_id);
    string edge_type_str = get_edge_type_str_from_edge_type_parser(edge_type);
    for (vector<int>::iterator in_itr = target_inlist.begin(); in_itr != target_inlist.end(); ++in_itr) {
        if (graph_ptr->get_edge_type(*in_itr) == edge_type_str) {
            source_node_array.insert(graph_ptr->get_source_node(*in_itr));
        }
    }
}

//fill node_array with the the nodes that are the source nodes
//of the edges of subtype directed to target_node_id

void GraphManagerNew::get_source_nodes(set<int>& source_node_array, int target_node_id, edge_subt edge_subtype, GraphNew* graph_ptr) {
    vector<int> target_inlist = graph_ptr->get_inlist(target_node_id);
    string edge_sub_type_str = get_edge_subtype_str_from_edge_subtype_parser(edge_subtype);
    for (vector<int>::iterator in_itr = target_inlist.begin(); in_itr != target_inlist.end(); ++in_itr) {
        if (graph_ptr->edge_has_subtype(*in_itr, edge_sub_type_str)) {
            source_node_array.insert(graph_ptr->get_source_node(*in_itr));
        }
    }
}

//fill node_array with the the nodes that are the source nodes
//of the edges of type edge_type, directed to target_node_id and edge_sub_list is a subset of the subtypes in those edges

void GraphManagerNew::get_source_nodes(set<int>& source_node_array, int target_node_id, edge_t edge_type, list_edge_subtypes_t* edge_sub_list, GraphNew* graph_ptr) {
    vector<int> target_inlist = graph_ptr->get_inlist(target_node_id);
    for (vector<int>::iterator in_itr = target_inlist.begin(); in_itr != target_inlist.end(); ++in_itr) {
        if (edge_type_subtype_subset_match(*in_itr, edge_type, edge_sub_list, graph_ptr)) {
            source_node_array.insert(graph_ptr->get_source_node(*in_itr));
        }
    }
}

//fill node_array with the the nodes that are the target nodes
//of the edges of type emanating from source_node_id

void GraphManagerNew::get_target_nodes(set<int>& target_node_array, int source_node_id, edge_t edge_type, GraphNew* graph_ptr) {
    vector<int> source_outlist = graph_ptr->get_outlist(source_node_id);
    string edge_type_str = get_edge_type_str_from_edge_type_parser(edge_type);
    for (vector<int>::iterator out_itr = source_outlist.begin(); out_itr != source_outlist.end(); ++out_itr) {
        if (graph_ptr->get_edge_type(*out_itr) == edge_type_str) {
            target_node_array.insert(graph_ptr->get_target_node(*out_itr));
        }
    }
}

//fill node_array with the the nodes that are the target nodes
//of the edges of subtype emanating from source_node_id

void GraphManagerNew::get_target_nodes(set<int>& target_node_array, int source_node_id, edge_subt edge_subtype, GraphNew* graph_ptr) {
    vector<int> source_outlist = graph_ptr->get_outlist(source_node_id);
    string edge_sub_type_str = get_edge_subtype_str_from_edge_subtype_parser(edge_subtype);
    for (vector<int>::iterator out_itr = source_outlist.begin(); out_itr != source_outlist.end(); ++out_itr) {
        if (graph_ptr->edge_has_subtype(*out_itr, edge_sub_type_str)) {
            target_node_array.insert(graph_ptr->get_target_node(*out_itr));
        }
    }
}

//fill node_array with the the nodes that are the target nodes
//of the edges of type edge_type, emanating from source_node_id and edge_sub_list is a subset of the subtypes in those edges

void GraphManagerNew::get_target_nodes(set<int>& target_node_array, int source_node_id, edge_t edge_type, list_edge_subtypes_t* edge_sub_list, GraphNew* graph_ptr) {
    vector<int> source_outlist = graph_ptr->get_outlist(source_node_id);
    for (vector<int>::iterator out_itr = source_outlist.begin(); out_itr != source_outlist.end(); ++out_itr) {
        if (edge_type_subtype_subset_match(*out_itr, edge_type, edge_sub_list, graph_ptr)) {
            target_node_array.insert(graph_ptr->get_target_node(*out_itr));
        }
    }
}

bool GraphManagerNew::node_has_input_edge_of_type(int nid, edge_t edge_type, GraphNew* graph) {
    vector<int> inlist = graph->get_inlist(nid);
    string edge_type_str = get_edge_type_str_from_edge_type_parser(edge_type);

    for (vector<int>::iterator itr = inlist.begin(); itr != inlist.end(); ++itr) {
        if (graph->get_edge_type(*itr) == edge_type_str) {
            return true;
        }
    }
    return false;
}

bool GraphManagerNew::node_has_output_edge_of_type(int nid, edge_t edge_type, GraphNew* graph) {
    vector<int> outlist = graph->get_outlist(nid);
    string edge_type_str = get_edge_type_str_from_edge_type_parser(edge_type);

    for (vector<int>::iterator itr = outlist.begin(); itr != outlist.end(); ++itr) {
        if (graph->get_edge_type(*itr) == edge_type_str) {
            return true;
        }
    }
    return false;
}

bool GraphManagerNew::node_has_input_edge_of_subtype(int nid, edge_subt edge_subtype, GraphNew* graph) {
    vector<int> inlist = graph->get_inlist(nid);
    string edge_sub_type_str = get_edge_subtype_str_from_edge_subtype_parser(edge_subtype);
    for (vector<int>::iterator itr = inlist.begin(); itr != inlist.end(); ++itr) {
        if (graph->edge_has_subtype(*itr, edge_sub_type_str)) {
            return true;
        }
    }
    return false;
}

bool GraphManagerNew::node_has_output_edge_of_subtype(int nid, edge_subt edge_subtype, GraphNew* graph) {
    vector<int> outlist = graph->get_outlist(nid);
    string edge_sub_type_str = get_edge_subtype_str_from_edge_subtype_parser(edge_subtype);
    for (vector<int>::iterator itr = outlist.begin(); itr != outlist.end(); ++itr) {
        if (graph->edge_has_subtype(*itr, edge_sub_type_str)) {
            return true;
        }
    }
    return false;
}

t_Expression* GraphManagerNew::get_constraint_for_tuple(map<string, int>& curr_tuple_ref, logical_stmt_t* left_of_implication, logical_stmt_t* right_of_implication, t_ExpressionManager* em, GraphNew* graph) {
    t_Expression* left_expr = get_constraint_for_logic_stmt_and_tuple(curr_tuple_ref, left_of_implication, em, graph);
    t_Expression* right_expr = get_constraint_for_logic_stmt_and_tuple(curr_tuple_ref, right_of_implication, em, graph);

    assert(left_expr != NULL);
    assert(right_expr != NULL);
    //em->printExpressionToFileAsDAG("left_constraint", left_expr, cout);
    //em->printExpressionToFileAsDAG("right_constraint", right_expr, cout);

    t_Expression* implication_expr = NULL;
    implication_expr = build_OR_constraints(left_expr, right_expr, 1, 0, em); //this is basically implication left_expr -> right_expr
    assert(implication_expr != NULL);
    //em->printExpressionToFileAsDAG("implication_constraint", implication_expr, cout);
    return implication_expr;
}

t_Expression* GraphManagerNew::get_constraint_for_logic_stmt_and_tuple(map<string, int>& curr_tuple_ref, logical_stmt_t* logic_stmt, t_ExpressionManager* em, GraphNew* graph) {
    t_Expression* expression_to_return = NULL;
    map<string, int>::iterator tuple_itr;
    //base case
    if (logic_stmt->opr == NONE_OPR) {
        if (logic_stmt->fun_name2 == NODE_FUN2) {
            string arg1(logic_stmt->arg1);
            tuple_itr = curr_tuple_ref.find(arg1);
            if (tuple_itr == curr_tuple_ref.end()) {
                cerr << "There is no identifier " + arg1 + " in the tuples generated, exiting . . ." << endl;
                exit(1);
            } else if (logic_stmt->state_node == ACTIVATED_STATE || logic_stmt->state_node == INHIBITED_STATE || logic_stmt->state_node == REPRESSED_STATE || logic_stmt->state_node == OVEREXPRESSED_STATE) {// ACTIVATED_STATE, INHIBITED_STATE, REPRESSED_STATE, OVEREXPRESSED_STATE
                expression_to_return = get_node_constraint(tuple_itr->second, logic_stmt->state_node, em, graph);
            } else if (logic_stmt->state_node2 == DIFFER_EXPRESSED_STATE || logic_stmt->state_node2 == NOT_DIFFER_EXPRESSED_STATE) {//DIFFER_EXPRESSED_STATE, NOT_DIFFER_EXPRESSED_STATE
                expression_to_return = get_node_constraint(tuple_itr->second, logic_stmt->state_node2, em, graph);
            } else {
                cerr << "\nBUG: debug node state issues ";
                exit(1);
            }
        } else if (logic_stmt->fun_name2 == EDGE_FUN2 || logic_stmt->fun_name2 == EDGE_SUBTYPE_DNF_FUN2) {
            string arg1(logic_stmt->arg1);
            string arg2(logic_stmt->arg2);
            int node1, node2;
            tuple_itr = curr_tuple_ref.find(arg1);
            if (tuple_itr == curr_tuple_ref.end()) {
                cerr << "There is no identifier " + arg1 + " in the tuples generated, exiting . . ." << endl;
                exit(1);
            } else {
                node1 = tuple_itr->second;
            }
            tuple_itr = curr_tuple_ref.find(arg2);
            if (tuple_itr == curr_tuple_ref.end()) {
                cerr << "There is no identifier " + arg2 + " in the tuples generated, exiting . . ." << endl;
                exit(1);
            } else {
                node2 = tuple_itr->second;
            }
            if (logic_stmt->fun_name2 == EDGE_FUN2) {
                expression_to_return = get_edge_constraint(node1, node2, logic_stmt->state_edge, logic_stmt->arg3, logic_stmt->arg4_list, em, graph);
            } else if (logic_stmt->fun_name2 == EDGE_SUBTYPE_DNF_FUN2) {
                expression_to_return = get_edge_constraint(node1, node2, logic_stmt->state_edge, logic_stmt->arg3, logic_stmt->arg_DNF_edgesub, em, graph);
            }
        } else {
            cerr << "Empty logical statement . . ., exiting . . ." << endl;
            exit(1);
        }
    } else if (logic_stmt->opr == OR_OPR || logic_stmt->opr == AND_OPR) {
        t_Expression* left_of_operator_expr = get_constraint_for_logic_stmt_and_tuple(curr_tuple_ref, logic_stmt->left, em, graph);
        t_Expression* right_of_operator_expr = get_constraint_for_logic_stmt_and_tuple(curr_tuple_ref, logic_stmt->right, em, graph);

        if (logic_stmt->opr == OR_OPR) {
            expression_to_return = build_OR_constraints(left_of_operator_expr, right_of_operator_expr, 0, 0, em);
        } else if (logic_stmt->opr == AND_OPR) {
            expression_to_return = build_AND_constraints(left_of_operator_expr, right_of_operator_expr, 0, 0, em);
        }
    } else if (logic_stmt->opr == NOT_OPR) {
        t_Expression* expr_to_neg = get_constraint_for_logic_stmt_and_tuple(curr_tuple_ref, logic_stmt->left, em, graph);
        expression_to_return = em->createOneBitExpressionWithOneOperand(em->m_operatorLabelLogNOT, expr_to_neg);
    }
    return expression_to_return;
}

t_Expression* GraphManagerNew::get_node_constraint(int nid, node_state_t node_state, t_ExpressionManager* em, GraphNew* graph) {
    t_Expression* expression_to_return = NULL;
    TypeOfExpressionTuple te1 = {TYPE_UNSIGNED_BITVECTOR, 1};
    string node_variable;
    string repid = graph->get_rep_id_from_nid(nid);
    if (node_state == ACTIVATED_STATE) {
        node_variable = repid + "_active";
    } else if (node_state == INHIBITED_STATE) {
        node_variable = repid + "_active";
    } else if (node_state == OVEREXPRESSED_STATE) {
        node_variable = repid + "_over_expressed";
    } else if (node_state == REPRESSED_STATE) {
        node_variable = repid + "_over_expressed";
    } else {
        cerr << "Node state isn't set, exiting . . ." << endl;
        exit(1);
    }
    if (getExpressionMap.find(node_variable) == getExpressionMap.end()) {
        expression_to_return = em->createSymbol(node_variable, te1);
        getExpressionMap[node_variable] = expression_to_return;
        getCNFIndexMap[expression_to_return] = make_pair(node_variable, -1);
    } else {
        expression_to_return = getExpressionMap[node_variable];
    }

    if (node_state == INHIBITED_STATE || node_state == REPRESSED_STATE) {
        expression_to_return = em->createOneBitExpressionWithOneOperand(em->m_operatorLabelLogNOT, expression_to_return);
    }
    //em->printExpressionToFileAsDAG("expr_to_return", expression_to_return, cout);
    return expression_to_return;
}

t_Expression* GraphManagerNew::get_node_constraint(int nid, node_state2_t node2_state, t_ExpressionManager* em, GraphNew* graph) {
    t_Expression* expression_to_return = NULL;
    TypeOfExpressionTuple te1 = {TYPE_UNSIGNED_BITVECTOR, 1};
    string node_variable;
    string repid = graph->get_rep_id_from_nid(nid);
    if (node2_state == DIFFER_EXPRESSED_STATE || NOT_DIFFER_EXPRESSED_STATE) {
        node_variable = repid + "_expression_changes";
    } else {
        cerr << "Node state isn't set, exiting . . ." << endl;
        exit(1);
    }
    if (getExpressionMap.find(node_variable) == getExpressionMap.end()) {
        expression_to_return = em->createSymbol(node_variable, te1);
        getExpressionMap[node_variable] = expression_to_return;
        getCNFIndexMap[expression_to_return] = make_pair(node_variable, -1);
    } else {
        expression_to_return = getExpressionMap[node_variable];
    }

    if (node2_state == NOT_DIFFER_EXPRESSED_STATE)
        expression_to_return = em->createOneBitExpressionWithOneOperand(em->m_operatorLabelLogNOT, expression_to_return);
    //em->printExpressionToFileAsDAG("expr_to_return", expression_to_return, cout);
    return expression_to_return;
}

t_Expression* GraphManagerNew::get_edge_constraint(int node1, int node2, edge_state_t edge_state, edge_t edge_type, list_edge_subtypes_t* list_edge_subtypes, t_ExpressionManager* em, GraphNew* graph) {
    string repid_node1 = graph->get_rep_id_from_nid(node1);
    string repid_node2 = graph->get_rep_id_from_nid(node2);
    //first a check needs to be performed that the edge actually exists from node1 to node2
    bool edge_exists_from_node1_to_node2 = false;
    int edge_to_consider;
    vector<int> node1_outlist = graph->get_outlist(node1);
    vector<int>::iterator edge_set_itr;
    for (edge_set_itr = node1_outlist.begin(); edge_set_itr != node1_outlist.end(); ++edge_set_itr) {
        if (graph->get_target_node(*edge_set_itr) == node2 && edge_type_subtype_subset_match(*edge_set_itr, edge_type, list_edge_subtypes, graph)) {
            edge_exists_from_node1_to_node2 = true;
            edge_to_consider = *edge_set_itr;
            break;
        }
    }

    if (!edge_exists_from_node1_to_node2) {
        //check if there is an edge from node2 to node1
        bool edge_exists_from_node2_to_node1 = false;
        vector<int> node2_outlist = graph->get_outlist(node2);
        for (edge_set_itr = node2_outlist.begin(); edge_set_itr != node2_outlist.end(); ++edge_set_itr) {
            if (graph->get_target_node(*edge_set_itr) == node1 && edge_type_subtype_subset_match(*edge_set_itr, edge_type, list_edge_subtypes, graph)) {
                edge_exists_from_node2_to_node1 = true;
                break;
            }
        }

        if (edge_exists_from_node2_to_node1) {
            cerr << "Error: there is no edge of desired type from " + repid_node1 + " to " + repid_node2 +
                    ", but there exists edge of desired type from " + repid_node2 + " to " + repid_node1;
        } else {
            cerr << "Error: there is no edge of desired type from " + repid_node1 + " to " + repid_node2 +
                    ", also there is no edge of desired type from " + repid_node2 + " to " + repid_node1;
        }

        //this was earlier exit case
        cerr << "\nExiting. . ." << endl;
        exit(1);
    }



    t_Expression* expression_to_return = NULL;
    TypeOfExpressionTuple te1 = {TYPE_UNSIGNED_BITVECTOR, 1};

    string edge_type_str = graph->get_edge_type(edge_to_consider);
    vector<string> edge_subtype_vec_str = graph->get_edge_subtypes_of_edge(edge_to_consider);
    string edge_subtypes_str = get_edge_substring_for_constraint_variable(edge_subtype_vec_str);

    string edge_variable = "edge." + repid_node1 + "to" + repid_node2 + "." + edge_type_str + "-" + edge_subtypes_str + "present";

    if (getExpressionMap.find(edge_variable) == getExpressionMap.end()) {
        expression_to_return = em->createSymbol(edge_variable, te1);
        getExpressionMap[edge_variable] = expression_to_return;
        getCNFIndexMap[expression_to_return] = make_pair(edge_variable, -1);
    } else {
        expression_to_return = getExpressionMap[edge_variable];
    }

    if (edge_state != PRESENT_STATE) {
        expression_to_return = em->createOneBitExpressionWithOneOperand(em->m_operatorLabelLogNOT, expression_to_return);
    }

    assert(expression_to_return != NULL);
    return expression_to_return;
}

t_Expression* GraphManagerNew::get_edge_constraint(int node1, int node2, edge_state_t edge_state, edge_t edge_type, DNF_edgesub_t* DNF_edgesub, t_ExpressionManager* em, GraphNew* graph) {
    string repid_node1 = graph->get_rep_id_from_nid(node1);
    string repid_node2 = graph->get_rep_id_from_nid(node2);
    bool report_error = true;
    while (DNF_edgesub) {
        ANDed_edgesub_literals_t* current_ANDed_clause = DNF_edgesub->current_ANDed_clause;
        //first a check needs to be performed that the edge actually exists from node1 to node2
        bool edge_exists_from_node1_to_node2 = false;
        int edge_to_consider;
        vector<int> node1_outlist = graph->get_outlist(node1);
        vector<int>::iterator edge_set_itr;
        for (edge_set_itr = node1_outlist.begin(); edge_set_itr != node1_outlist.end(); ++edge_set_itr) {
            if (graph->get_target_node(*edge_set_itr) == node2 && edge_subtype_ANDed_clause_match(*edge_set_itr, DNF_edgesub->current_ANDed_clause, graph)) {
                edge_exists_from_node1_to_node2 = true;
                edge_to_consider = *edge_set_itr;
                break;
            }
        }
        if (edge_exists_from_node1_to_node2) {//thus the constraint is written for the first macthed clause in the DNF
            report_error = false;
            t_Expression* expression_to_return = NULL;
            TypeOfExpressionTuple te1 = {TYPE_UNSIGNED_BITVECTOR, 1};

            string edge_type_str = graph->get_edge_type(edge_to_consider);
            vector<string> edge_subtype_vec_str = graph->get_edge_subtypes_of_edge(edge_to_consider);
            string edge_subtypes_str = get_edge_substring_for_constraint_variable(edge_subtype_vec_str);

            string edge_variable = "edge." + repid_node1 + "to" + repid_node2 + "." + edge_type_str + "-" + edge_subtypes_str + "present";

            if (getExpressionMap.find(edge_variable) == getExpressionMap.end()) {
                expression_to_return = em->createSymbol(edge_variable, te1);
                getExpressionMap[edge_variable] = expression_to_return;
                getCNFIndexMap[expression_to_return] = make_pair(edge_variable, -1);
            } else {
                expression_to_return = getExpressionMap[edge_variable];
            }

            if (edge_state != PRESENT_STATE) {
                expression_to_return = em->createOneBitExpressionWithOneOperand(em->m_operatorLabelLogNOT, expression_to_return);
            }

            assert(expression_to_return != NULL);
            return expression_to_return;
        }
        DNF_edgesub = DNF_edgesub->next;
    }
    if (report_error) {
        cerr << "\nNone of the clauses of edgesubtype in DNF macthed, exiting. . ." << endl;
        exit(1);
    }
    return NULL;
}

//match happens when the edge type match exactly and when the edge subtype list of parser is a subset of the edge subtype list of the edge with id eid

bool GraphManagerNew::edge_type_subtype_subset_match(int eid, edge_t edge_type, list_edge_subtypes_t* list_edge_subtypes, GraphNew* graph) {
    string edge_type_str = get_edge_type_str_from_edge_type_parser(edge_type);
    vector<string> edge_subtype_vec_str = get_vector_edge_subtype_str_from_edge_subtype_parser_list(list_edge_subtypes);
    vector<string> eid_all_subtypes_vec_str = graph->get_edge_subtypes_of_edge(eid);
    bool edge_type_match = (edge_type_str == graph->get_edge_type(eid));
    bool edge_subtype_list_subset_match = is_subset(edge_subtype_vec_str, eid_all_subtypes_vec_str);
    return edge_type_match && edge_subtype_list_subset_match;
}

//match happens when all the non-negated literals in the ANDed_clause exist as subtype in edge with id eid and none of the negated literals exist as subtype in edge with id eid

bool GraphManagerNew::edge_subtype_ANDed_clause_match(int eid, ANDed_edgesub_literals_t* ANDed_clause, GraphNew* graph) {
    vector<string> eid_all_subtypes_vec_str = graph->get_edge_subtypes_of_edge(eid);
    vector<string> non_negated_subtypes = get_non_negated_edge_subtypes(ANDed_clause);
    vector<string> negated_subtypes = get_negated_edge_subtypes(ANDed_clause);
    bool non_negated_are_subset = is_subset(non_negated_subtypes, eid_all_subtypes_vec_str);
    bool negated_dont_intersect = intersection_empty(negated_subtypes, eid_all_subtypes_vec_str);
    return non_negated_are_subset && negated_dont_intersect;
}

//for edge subtype string inclusion in edge presence variable

std::string GraphManagerNew::get_edge_substring_for_constraint_variable(std::vector<std::string>& edge_subtype_vec_str) {
    string edge_subtype_str = "";
    for (vector<string>::iterator itr = edge_subtype_vec_str.begin(); itr != edge_subtype_vec_str.end(); ++itr) {
        edge_subtype_str += get_string_prefix(get_string_prefix(*itr, ' '), '/') + "-";
    }
    return edge_subtype_str;
}

string GraphManagerNew::get_string_prefix(string input, char delim) {
    int ind = input.find_first_of(delim);
    if (ind == string::npos)
        return input;
    return input.substr(0, ind);
}

vector<t_Expression *> GraphManagerNew::get_microarray_constraints(string micro_arr_decl, string micro_arr_assert, t_ExpressionManager* em) {
    ifstream fin(micro_arr_decl.c_str());
    ifstream fin1(micro_arr_assert.c_str());
    if (fin.fail() || fin1.fail()) {
        cerr << "Unable to open micro array declaration/definition/assertions/conflicting_nodes file(s) "; // << constraint_file << endl;
    }


    string s;

    TypeOfExpressionTuple te = {TYPE_UNSIGNED_BITVECTOR, 1};
    while (fin >> s) {
        if (s[0] != '(')
            continue;

        fin >> s;

        if (getExpressionMap.find(s) == getExpressionMap.end()) {
            cerr << "The variable " + s + " was not declared in the graph constraints\n";
            getExpressionMap[s] = em->createSymbol(s, te);
            getCNFIndexMap[getExpressionMap[s]] = make_pair(s, -1);
        }

        fin >> s;
    }

    vector<t_Expression *> micro_constraints;

    while (fin1 >> s) {
        if (s[0] != '(')
            continue;

        fin1 >> s;

        if (s[0] != '(') {
            s = s.substr(0, s.length() - 1);
            micro_constraints.push_back(getExpressionMap[s]);
        } else {
            fin1 >> s;
            s = s.substr(0, s.length() - 2);
            micro_constraints.push_back(em->createOneBitExpressionWithOneOperand(em->m_operatorLabelLogNOT, getExpressionMap[s]));
        }
    }

    return micro_constraints;
}

void GraphManagerNew::solve_constraints(vector<t_Expression*> cons, t_ExpressionManager* em) {
    string CNF_file = "CNF_file";
    string z3_out_file = "z3_out_file"; //z3 std output goes here
    string z3_error_file = "z3_error_file"; //z3 std error goes here
    string bin_search_report = "bin_search_report"; //binary search procedure goes here

    ofstream fout_CNF_file(CNF_file.c_str());
    //CNF_file that constraint solver is partitioned into upper part and lower part - upper part is stored in tmp_file, lower part is stored in tmp_file2
    string tmp_file = "temp_file"; //this stores all the constraints but the value of the upper bound
    string tmp_file2 = "temp_file2"; //this stores the upper bound in CNF format
    //int idx = 1, clauses = 0; //clauses is num of clauses, idx stores the number that is to be given to the next variable, thus idx-1 is the total variables


    //em->printExpressionsToFileInCNF(cons, tmp_file, idx, clauses, getCNFIndexMap);//constraints in cons written to the file tmp_file
    t_Expression* AND_cons = build_AND_constraints_from_vector(cons, em);

    ofstream em_log("em_log");
    if (em_log.is_open()) {
        em->printExpressionInCNFefficient(AND_cons, tmp_file, idx, clauses, getCNFIndexMap, em_log);
        em_log.close();
    } else {
        cerr << "Error: em_log file couldn't be opened" << endl;
    }



    vector<int> upper_bound_val; //vector of CNF variables that acts as a bit sequence that stores the upper bound - note the left most element of vector corresponds to the right most bit of the bit sequence
    ofstream fout2(tmp_file2.c_str());
    string cmd = "cat " + tmp_file + " >> " + CNF_file + " ; " + "cat " + tmp_file2 + " >> " + CNF_file; //this command puts everything in the CNF_file to make it ready for the constraint solver
    int upper_bound_cur;
    int upper_bound_user;
    int upper_bound_prev;
    int time_out; //the time in seconds beyond which z3 run is considered timed out
    bool strict_sat_boundaries;
    char choose_strict;
    int highest_unsat_bound_seen;
    sat_state_t sat_state = UNDEFINED;
    sat_state_t sat_state_prev = UNDEFINED;

    ofstream fout3(bin_search_report.c_str());
    ifstream fin;

    bool loop_forver = true;

    while (loop_forver) {
        char choice;
        cout << "\nEnter 'b' to do the binary-search-based constraint solving with metric as upper bound on total number of edges ";
        cout << "\nEnter 'u' to do constraint solving with metric as just a fixed upper bound on total number of edges ";
        cout << "\nEnter 'n' to do constraint solving without any metric ";
        cin >> choice;

        switch (choice) {
                //the binary search case
            case 'b':

                cout << "\nDo you want to find strict SAT boundaries? 'y' or 'Y' for yes, otherwise any other key: ";
                cin >> choose_strict;
                if (choose_strict == 'y' || choose_strict == 'Y') {
                    strict_sat_boundaries = true;
                }



                loop_forver = false;
                upper_bound_val = write_edgecount_cnf(tmp_file, getCNFIndexMap, idx, clauses);

                cout << "\nEnter the time to wait for each run(in seconds) : ";
                cin >> time_out;

                upper_bound_cur = 1;
                upper_bound_prev = 0;
                highest_unsat_bound_seen = 0;

                // increasing the upper_bound by 2 times for each run in the loop
                while (true) {
                    //for(int i=0; i <= upper_bound_val.size(); i++) {

                    /*if(i==upper_bound_val.size())
                      upper_bound_cur--;*/

                    if (fout_CNF_file.is_open()) {
                        fout_CNF_file.close();
                    }
                    if (fout2.is_open()) {
                        fout2.close();
                    }

                    fout_CNF_file.open(CNF_file.c_str());
                    fout2.open(tmp_file2.c_str());
                    fout2 << "c edge var sum upper bound starts" << endl;

                    fout_CNF_file << "p cnf " << idx - 1 << " " << clauses << endl;

                    upper_bound_user = upper_bound_cur;
                    for (int i = 0; i < upper_bound_val.size(); i++) {
                        if (upper_bound_user % 2 == 0)
                            fout2 << -upper_bound_val[i] << " 0\n";
                        else
                            fout2 << upper_bound_val[i] << " 0\n";
                        upper_bound_user /= 2;
                    }
                    fout_CNF_file.close();
                    fout2.close();
                    system((cmd + "; timeout " + IntToString(time_out) + " z3 -dimacs " + CNF_file + " > " + z3_out_file + " 2> " + z3_error_file).c_str());
                    //sleep(time_out+3);

                    fout3 << "\nUpper bound : " << upper_bound_cur << endl;

                    string s;
                    if (fin.is_open()) {
                        fin.close();
                    }
                    fin.open(z3_error_file.c_str());

                    if (fin.is_open()) {
                        fin >> s;
                        if (s.length() > 0) {
                            fout3 << "Error in cnf input file format";
                            fin.close();
                            break;
                        }
                    }

                    if (fin.is_open()) {
                        fin.close();
                    }
                    fin.open(z3_out_file.c_str());

                    if (fin.is_open()) {
                        fin >> s;
                        fin.close();
                    }

                    if (s == "sat") {
                        sat_state = SAT;
                        fout3 << s << endl;
                        //break;
                    } else if (s == "unsat") {
                        sat_state = UNSAT;
                        fout3 << s << endl;
                    } else {
                        sat_state = TIMEOUT;
                        fout3 << "timed out\n";
                    }

                    //testing starts
                    //system(("cp " + tmp_file + " " + tmp_file + "_" + IntToString(upper_bound_cur) + " ; " + "cp " + tmp_file2 + " " + tmp_file2 + "_" + IntToString(upper_bound_cur)).c_str());
                    //testing ends


                    //testing
                    fout3 << "current upper bound " << upper_bound_cur << endl;
                    fout3 << "previous upper bound " << upper_bound_prev << endl;
                    fout3 << "highest unsat bound " << highest_unsat_bound_seen << endl;


                    //there is an assumption here -
                    //bw UNSAT and TIMEOUT there is a continuous UNSAT followed by continuous TIMOUT
                    //bw UNSAT and SAT there is a continuous UNSAT followed by continuous SAT
                    //other cases must be handled later to this
                    if (strict_sat_boundaries) {
                        if (sat_state == SAT || sat_state == TIMEOUT) {
                            if ((upper_bound_cur - highest_unsat_bound_seen) == 1) {
                                break;
                            } else {
                                sat_state_prev = sat_state;
                                sat_state = UNDEFINED;
                                int temp = upper_bound_cur;
                                upper_bound_cur = (highest_unsat_bound_seen + upper_bound_cur) / 2;
                                upper_bound_prev = temp;
                            }
                        } else if (sat_state == UNSAT) {
                            if (sat_state_prev == UNSAT || sat_state_prev == UNDEFINED) {
                                sat_state_prev = UNSAT;
                                sat_state = UNDEFINED;
                                highest_unsat_bound_seen = upper_bound_cur;
                                upper_bound_prev = upper_bound_cur;
                                upper_bound_cur = 2 * upper_bound_prev;
                            } else if (sat_state_prev == TIMEOUT || sat_state_prev == SAT) {
                                sat_state_prev = UNSAT;
                                sat_state = UNDEFINED;
                                if (upper_bound_prev - upper_bound_cur == 1) {
                                    highest_unsat_bound_seen = upper_bound_cur;
                                    upper_bound_prev = upper_bound_cur;
                                    upper_bound_cur++;
                                } else {
                                    if (highest_unsat_bound_seen < upper_bound_cur) {
                                        highest_unsat_bound_seen = upper_bound_cur;
                                    }
                                    int temp = upper_bound_cur;
                                    upper_bound_cur = (upper_bound_prev + upper_bound_cur) / 2;
                                    upper_bound_prev = temp;
                                }
                            } else {
                                assert(false);
                            }
                        } else {
                            assert(false);
                        }
                    } else {
                        if (sat_state == SAT) {
                            break;
                        } else if (sat_state == UNSAT || sat_state == TIMEOUT) {
                            sat_state_prev = sat_state;
                            sat_state = UNDEFINED;
                            upper_bound_prev = upper_bound_cur;
                            highest_unsat_bound_seen = upper_bound_cur;
                            upper_bound_cur *= 2;
                        } else {
                            cerr << "Error: sat state must be one of SAT, UNSAT, TIMEOUT at this stage" << endl;
                            assert(false);
                        }
                    }
                }

                /*
                   fout << "p cnf " <<idx-1<<" "<<clauses<<endl;

                   for(int i=0;i<upper_bound_val.size();i++) {
                   if(upper_bound_user%2==0)
                   fout2<<-upper_bound_val[i]<<" 0\n";
                   else
                   fout2<<upper_bound_val[i]<<" 0\n";
                   upper_bound_user/=2;
                   }
                 */

                break;
            case 'u':
                //a given upperbound case
                loop_forver = false;
                upper_bound_val = write_edgecount_cnf(tmp_file, getCNFIndexMap, idx, clauses);

                cout << "\nEnter upper bound ";
                cin >> upper_bound_user;

                fout_CNF_file << "p cnf " << idx - 1 << " " << clauses << endl; //the format is p cnf <number of variables in CNF> <number of clauses in CNF>

                for (int i = 0; i < upper_bound_val.size(); i++) {
                    if (upper_bound_user % 2 == 0)
                        fout2 << -upper_bound_val[i] << " 0\n";
                    else
                        fout2 << upper_bound_val[i] << " 0\n";
                    upper_bound_user /= 2;
                }
                fout_CNF_file.close();
                fout2.close();
                system(cmd.c_str());

                break;
                //no metric case
            case 'n':
                loop_forver = false;
                fout_CNF_file << "p cnf " << idx - 1 << " " << clauses << endl; //the format is p cnf <number of variables in CNF> <number of clauses in CNF>
                fout_CNF_file.close();
                system(cmd.c_str());
                //cout << "Not implemented yet" << endl;
                break;
            default:
                cout << "\nError: invalid choice ";
                break;
        }
    }
}

//appends edge upper bound constraints to the file CNF_filename (w/o the upper bound value)
//returns vector of internal variables storing the actual upper bound

vector<int> GraphManagerNew::write_edgecount_cnf(string CNF_filename, map<t_Expression *, pair<string, int> > getCNFIndexMap, int& idx, int& clauses) {
    vector<vector<int> > add_constraints; //stores all internal variables that must be added
    ofstream fout_CNF_file(CNF_filename.c_str(), ofstream::out | ofstream::app);
    fout_CNF_file << "c edge variables sum constraints start" << endl;

    ofstream fout_mapping("mapping", ofstream::out); //string variable name to internal CNF variable number written to file mapping

    for (map<t_Expression *, pair<string, int> >::iterator it = getCNFIndexMap.begin(); it != getCNFIndexMap.end(); it++) {
        string var_name = (it->second).first;
        if (var_name.substr(0, 4) == "edge") {
            if ((it->second).second == -1)//if the internal variables hasn't been assigned so far assign it
                (it->second).second = idx++;

            vector<int> v;
            v.push_back((it->second).second);
            add_constraints.push_back(v);
        }
        fout_mapping << (it->second).first << " " << (it->second).second << endl;
    }

    if (add_constraints.empty()) {
        cerr << "Error: there are no edge variables to add - exiting..." << endl;
        exit(1);
    }

    while (add_constraints.size() > 1) {
        vector<vector<int> > new_cons;

        for (int i = 0; i < add_constraints.size(); i += 2) {
            if ((i + 1) < add_constraints.size()) {
                new_cons.push_back(add_cnf(add_constraints[i], add_constraints[i + 1], idx, clauses, fout_CNF_file));
            } else {
                // should append zero here
                fout_CNF_file << -idx << " 0\n";
                clauses++;
                add_constraints[i].push_back(idx);
                idx++;

                new_cons.push_back(add_constraints[i]);
            }
        }
        add_constraints = new_cons;
    }

    vector<int> a = add_constraints[0];
    vector<int> b;

    for (int i = 0; i < a.size(); i++) {
        b.push_back(idx++);
        //cout<<b[i]<<" "<<a[i]<<endl;
    }

    vector<int> temp;
    // checking if a < b

    for (int i = a.size() - 1; i >= 0; i--) {
        if (i == 0) {
            fout_CNF_file << b[i];
            for (int j = 0; j < temp.size(); j++)
                fout_CNF_file << " " << temp[j];
            fout_CNF_file << " 0\n";
            clauses++;

            fout_CNF_file << -a[i];
            for (int j = 0; j < temp.size(); j++)
                fout_CNF_file << " " << temp[j];
            fout_CNF_file << " 0\n";
            clauses++;
        } else {
            fout_CNF_file << b[i];
            for (int j = 0; j < temp.size(); j++)
                fout_CNF_file << " " << temp[j];
            fout_CNF_file << " " << -(idx) << " 0\n";
            clauses++;

            fout_CNF_file << -a[i];
            for (int j = 0; j < temp.size(); j++)
                fout_CNF_file << " " << temp[j];
            fout_CNF_file << " " << (-idx) << " 0\n";
            clauses++;

            temp.push_back(idx);
            idx++;

            fout_CNF_file << -b[i] << " " << a[i];
            for (int j = 0; j < temp.size(); j++)
                fout_CNF_file << " " << temp[j];
            fout_CNF_file << " 0\n";
            clauses++;

            fout_CNF_file << -a[i] << " " << b[i];
            for (int j = 0; j < temp.size(); j++)
                fout_CNF_file << " " << temp[j];
            fout_CNF_file << " 0\n";
            clauses++;
        }

    }


    ofstream fout4("ind_var", ofstream::out);

    map<int, int> ind_vars;

    for (map<t_Expression *, pair<string, int> >::iterator it = getCNFIndexMap.begin(); it != getCNFIndexMap.end(); it++) {
        if ((it->second).second != -1) {
            fout4 << (it->second).second << endl;
            ind_vars[(it->second).second] = 1;
        }
    }

    ofstream fout5("dep_var", ofstream::out);

    for (int i = 1; i < idx; i++) {
        if (ind_vars.find(i) == ind_vars.end())
            fout5 << i << endl;
    }


    clauses += b.size();
    /*	for(int i=0;i<b.size();i++) {
            if(const_num%2==1)
            fout<<b[i]<<" 0\n";
            else
            fout<<-b[i]<<" 0\n";
            clauses++;
            const_num/=2;
            }
     */
    // we are just returning the constant number now which can be later set to any value
    return b;
}

GraphNew* GraphManagerNew::get_subgraph_with_edges_retained(GraphNew* graph, std::string filename) {
    if (graph == NULL) {
        cerr << "Error: null parent graph" << endl;
        return NULL;
    }
    GraphNew* subgraph = NULL;
    ifstream fin(filename.c_str());
    if (fin.is_open()) {
        subgraph = new GraphNew;
        int new_gid = ++GraphManagerNew::graph_id_count;
        subgraph->set_graph_id(new_gid);
        add_graph(new_gid, subgraph);
        
        // populate adjacency matrix
        //fill_adj_matrix_for_graph(subgraph);
    
        string line;

        while (getline(fin, line)) {
            string name, value;
            stringstream ss(line);
            ss >> name >> value;
            if (value == "true") {
                string head(name.c_str(), 0, 4);
                if (head == "edge") {
                    list<string> *subparts = this->get_list_of_names_from_string(name, ".");
                    subparts->pop_front(); // remove 'edge' prefix
                    string end_names = subparts->front(); //source to target
                    subparts->pop_front();
                    string edge_info = subparts->front(); //type subtype

                    //get source and target rep ids
                    list<string> *end_nodes = this->get_list_of_names_from_string(end_names, "to");
                    string source_rep_id = end_nodes->front();
                    end_nodes->pop_front();
                    string target_rep_id = end_nodes->front();
                    end_nodes->pop_front();

                    //get type info
                    list<string>* edgeInfo = this->get_list_of_names_from_string(edge_info, "-");
                    string edgeType = edgeInfo->front(); //get edge type
                    edgeInfo->pop_front(); // Remove the 'edge type' from list of strings
                    edgeInfo->pop_back(); // Remove 'present' from the list of strings

                    //edgeInfo now has only subtypes

                    //go over the edges of the old graph and if edge matches then include edge in the subgraph
                    vector<int> parent_graph_EIDS = graph->get_edge_ids();
                    for (vector<int>::iterator edge_itr = parent_graph_EIDS.begin(); edge_itr != parent_graph_EIDS.end(); ++edge_itr) {
                        string parent_edge_type = graph->get_edge_type(*edge_itr);
                        vector<string> parent_edge_subtypes = graph->get_edge_subtypes_of_edge(*edge_itr);
                        sort(parent_edge_subtypes.begin(), parent_edge_subtypes.end());
                        vector<string> edgeSubtypes(edgeInfo->begin(), edgeInfo->end());
                        sort(edgeSubtypes.begin(), edgeSubtypes.end());
                        int parent_source_nid = graph->get_source_node(*edge_itr);
                        int parent_target_nid = graph->get_target_node(*edge_itr);
                        string parent_source_rid = graph->get_rep_id_from_nid(parent_source_nid);
                        string parent_target_rid = graph->get_rep_id_from_nid(parent_target_nid);
                        if (parent_source_rid == source_rep_id && parent_target_rid == target_rep_id && parent_edge_type == edgeType && edgeSubtypes == parent_edge_subtypes) {
                            duplicate_edge(subgraph, graph, *edge_itr);
                            //if edge is assoc/dissoc type then make an edge in oppoiste direction also
                            if (graph->edge_has_subtype(*edge_itr, "association") || graph->edge_has_subtype(*edge_itr, "dissociation")) {
                                vector<int> parent_target_out_list = graph->get_outlist(parent_target_nid);

                                for (vector<int>::iterator parent_target_out_list_itr = parent_target_out_list.begin(); parent_target_out_list_itr != parent_target_out_list.end(); parent_target_out_list_itr++) {
                                    int target_of_target_id = graph->get_target_node(*parent_target_out_list_itr);
                                    string target_out_edge_type = graph->get_edge_type(*parent_target_out_list_itr);
                                    vector<string> target_out_edge_subtypes = graph->get_edge_subtypes_of_edge(*parent_target_out_list_itr);
                                    sort(target_out_edge_subtypes.begin(), target_out_edge_subtypes.end());

                                    if (parent_source_nid == target_of_target_id && parent_edge_type == target_out_edge_type && parent_edge_subtypes == target_out_edge_subtypes) {
                                        duplicate_edge(subgraph, graph, *parent_target_out_list_itr);
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        //store genesis
        list<int> empty_list;
        empty_list.push_back(graph->get_graph_id());
        string oper = "subgraph from assignment file: " + filename;
        add_graph_genesis(new_gid, oper, empty_list);
        fin.close();
    } else {
        cerr << "Error: couldn't open file: " + filename << endl;
    }
    return subgraph;
}

list<string>* GraphManagerNew::get_list_of_names_from_string(string name_str, string delim) {
    list<string> *list_of_labels = new list<string>;
    unsigned start_pos = 0;
    while (start_pos < name_str.length()) {
        std::size_t found = name_str.find(delim, start_pos);
        if (found != std::string::npos) {
            (*list_of_labels).push_back(name_str.substr(start_pos, found - start_pos));
            start_pos = found + delim.length();
        } else {
            (*list_of_labels).push_back(name_str.substr(start_pos));
            break;
        }
    }
    return list_of_labels;
}

void GraphManagerNew::merge_vis_files(string file_assign1, string file_assign2, std::ofstream& fout) {
    ifstream fin1(file_assign1.c_str());
    ifstream fin2(file_assign2.c_str());

    set<string> visible_edges1;
    set<string> present_edges1;
    set<string> visible_edges2;
    set<string> present_edges2;
    set<string> visible_minus_present_edges1;
    set<string> visible_minus_present_edges2;

    set<string> present_minus_visible_edges1;
    set<string> present_minus_visible_edges2;
    string visible_str = "-visible";
    string present_str = "-present";
    if (fin1.is_open()) {
        string var, boolval;
        while (fin1 >> var) {
            fin1 >> boolval;
            if (boolval == "true") {
                string::size_type visible_index = var.find(visible_str);
                string::size_type present_index = var.find(present_str);
                if (visible_index != string::npos) {
                    var.erase(visible_index, visible_str.length());
                    visible_edges1.insert(var);
                }
                if (present_index != string::npos) {
                    var.erase(present_index, present_str.length());
                    present_edges1.insert(var);
                }
            }
        }
        fin1.close();
        //find visible edges that are not present
        set_difference(visible_edges1.begin(), visible_edges1.end(), present_edges1.begin(), present_edges1.end(), inserter(visible_minus_present_edges1, visible_minus_present_edges1.begin()));
        set_difference(present_edges1.begin(), present_edges1.end(), visible_edges1.begin(), visible_edges1.end(), inserter(present_minus_visible_edges1, present_minus_visible_edges1.begin()));


    } else {
        cerr << "Error: file " + file_assign1 + " could not be opened for reading assignments" << endl;
    }

    if (fin2.is_open()) {
        string var, boolval;
        while (fin2 >> var) {
            fin2 >> boolval;
            if (boolval == "true") {
                string::size_type visible_index = var.find(visible_str);
                string::size_type present_index = var.find(present_str);
                if (visible_index != string::npos) {
                    var.erase(visible_index, visible_str.length());
                    visible_edges2.insert(var);
                }
                if (present_index != string::npos) {
                    var.erase(present_index, present_str.length());
                    present_edges2.insert(var);
                }
            }
        }
        fin2.close();
        //find visible edges that are not present
        set_difference(visible_edges2.begin(), visible_edges2.end(), present_edges2.begin(), present_edges2.end(), inserter(visible_minus_present_edges2, visible_minus_present_edges2.begin()));
        set_difference(present_edges2.begin(), present_edges2.end(), visible_edges2.begin(), visible_edges2.end(), inserter(present_minus_visible_edges2, present_minus_visible_edges2.begin()));


    } else {
        cerr << "Error: file " + file_assign2 + " could not be opened for reading assignments" << endl;
    }

    static set<string> visible_edges_merged;
    //set_union(visible_edges1.begin(), visible_edges1.begin(), visible_edges2.begin(), visible_edges2.end(), inserter(visible_edges_merged, visible_edges_merged.begin()));
    set_union(visible_minus_present_edges1.begin(), visible_minus_present_edges1.begin(), visible_minus_present_edges2.begin(), visible_minus_present_edges2.end(), inserter(visible_edges_merged, visible_edges_merged.begin()));
    static set<string> present_edges_merged;
    set_union(present_edges1.begin(), present_edges1.end(), present_edges2.begin(), present_edges2.end(), inserter(present_edges_merged, present_edges_merged.begin()));
    //set_union(present_minus_visible_edges1.begin(), present_minus_visible_edges1.end(), present_minus_visible_edges2.begin(), present_minus_visible_edges2.end(), inserter(present_edges_merged, present_edges_merged.begin()));

    set<string> visible_minus_present_merged; // = visible_edges_merged;
    set_difference(visible_edges_merged.begin(), visible_edges_merged.end(), present_edges_merged.begin(), present_edges_merged.end(), inserter(visible_minus_present_merged, visible_minus_present_merged.begin()));

    for (set<string>::iterator set_itr = visible_minus_present_merged.begin(); set_itr != visible_minus_present_merged.end(); set_itr++) {
        fout << *set_itr << endl;
    }
}

void GraphManagerNew::print_visible_but_not_present_edges_from_z3_assignment(string file_assgn, std::ofstream& fout) {
    ifstream fin(file_assgn.c_str());
    set<string> visible_edges;
    set<string> present_edges;
    set<string> visible_minus_present_edges;
    string visible_str = "-visible";
    string present_str = "-present";
    if (fin.is_open()) {
        string var, boolval;
        while (fin >> var) {
            fin >> boolval;
            if (boolval == "true") {
                string::size_type visible_index = var.find(visible_str);
                string::size_type present_index = var.find(present_str);
                if (visible_index != string::npos) {
                    var.erase(visible_index, visible_str.length());
                    visible_edges.insert(var);
                }
                if (present_index != string::npos) {
                    var.erase(present_index, present_str.length());
                    present_edges.insert(var);
                }
            }
        }
        fin.close();
        //find visible edges that are not present
        set_difference(visible_edges.begin(), visible_edges.end(), present_edges.begin(), present_edges.end(), inserter(visible_minus_present_edges, visible_minus_present_edges.begin()));

        for (set<string>::iterator set_itr = visible_minus_present_edges.begin(); set_itr != visible_minus_present_edges.end(); set_itr++) {
            fout << *set_itr << endl;
        }
    } else {
        cerr << "Error: file " + file_assgn + " couldn't be opened for reading assignments" << endl;
    }
}

void GraphManagerNew::testing_printexpr_iter(t_ExpressionManager* em) {
    int idx = 1, clauses = 0;
    map<t_Expression*, pair<string, int> > getCNFIndexMap2;
    TypeOfExpressionTuple te1 = {TYPE_UNSIGNED_BITVECTOR, 1};
    t_Expression* expr;
    string left = "left", right = "right", center = "center";

    t_Expression* left_expr = em->createSymbol(left, te1);
    getCNFIndexMap2[left_expr] = make_pair(left, -1);

    t_Expression* right_expr = em->createSymbol(right, te1);
    getCNFIndexMap2[right_expr] = make_pair(right, -1);

    t_Expression* center_expr = em->createSymbol(center, te1);
    getCNFIndexMap2[center_expr] = make_pair(center, -1);

    t_Expression* expr1 = build_AND_constraints(left_expr, center_expr, 0, 0, em);
    t_Expression* expr2 = build_AND_constraints(right_expr, center_expr, 0, 0, em);

    expr = build_AND_constraints(expr1, expr2, 0, 0, em);

    //expr = left_expr;

    string cnf_test = "print_cnf_test";
    ofstream em_log_test("em_log_test");

    em->printExpressionInCNFefficient(expr, cnf_test, idx, clauses, getCNFIndexMap2, em_log_test);
    em->print_expr_var_cnf_id(getCNFIndexMap2);
    em_log_test << " idx is " << idx << endl;
    em_log_test << "clauses is " << clauses << endl;
    em_log_test.close();
}



//Uddipaan's conversion module

void GraphNew::convert_to_sif(GraphManagerNew* gm, bool b_mode, vector<string> &token_cmd, int &cmd_index) {

    //cout<<"inside convert_to_sif :)"<<endl; 

    cout << endl;
    //for the purpose of storing the sif file
    std::string sif_name;
    if (!b_mode) {
        std::cout << "\nEnter a file name for the graph with .sif extension (e.g. mygraph.sif): ";
        std::cin >> sif_name;
    } else {
        sif_name = token_cmd[cmd_index];
        cmd_index++;
    }
    //std::string pth = "/home/sysbio/uddipaan/network_tool/cnv";
    std::string pth = ".";
    //creating the file stream
    ofstream fout((pth + "/" + sif_name).c_str());

    //declared a container of integers holding the nodes
    set<int> edges_of_graph;

    //operates by iterating through the nodes storage
    for (vector<int>::iterator itr = EIDSg.begin(); itr != EIDSg.end(); itr++)
        //itr points to begin of EIDSg until EIDSg doesnt end
    {

        set<int>::iterator edges_itr_graph = edges_of_graph.find(*itr);


        write_file_to_sif(fout, *itr); //conversion to .sif    

    }
    fout.close();
    //else {
    // cerr << "\nCouldn't open file for writing: " << sif_name << endl;
    //}



}

void GraphNew::convert_to_graphml(std::ofstream &fout, bool b_mode, vector<string> &token_cmd, int &cmd_index) {
    std::string color_map_filename; //for color
    if (!b_mode) {
        cout << "Enter color map filename (0 to skip): ";
        cin >> color_map_filename;
    } else {
        color_map_filename = token_cmd[cmd_index++];
    }
    fout << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" << endl;
    fout << "<graphml xmlns=\"http://graphml.graphdrawing.org/xmlns\"" << endl;
    fout << "\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"" << endl;
    fout << "\txmlns:y=\"http://www.yworks.com/xml/graphml\"" << endl;
    fout << "\txsi:schemaLocation=\"http://graphml.graphdrawing.org/xmlns" << endl;
    fout << "\thttp://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd\">" << endl;


    //key for graph
    fout << "<key id=\"Name\" for=\"graph\" attr.name=\"Name\" attr.type=\"string\"/>" << endl;
    fout << "<key id=\"Org\" for=\"graph\" attr.name=\"Org\" attr.type=\"string\"/>" << endl;
    fout << "<key id=\"Title\" for=\"graph\" attr.name=\"Title\" attr.type=\"string\"/>" << endl;
    fout << "<key id=\"Number\" for=\"graph\" attr.name=\"Number\" attr.type=\"double\"/>" << endl;
    fout << "\n" << endl;





    //key for edge
    fout << "<key id=\"Relation\" for=\"edge\" attr.name=\"relationship_type\" attr.type=\"string\"/>" << endl;
    fout << "<key id=\"Type\" for=\"edge\" attr.name=\"Label\" attr.type=\"string\"/>" << endl;
    fout << "<key id=\"ecolor\" for=\"edge\"  attr.name=\"Edge_Color\" attr.type=\"string\"/>" << endl;
    //fout<< "<key id=\"Pathway\" for=\"edge\" attr.name=\"mincut\" attr.type=\"string\"/>"<<endl;
    fout << "<key id=\"ID\" for=\"edge\" attr.name=\"ID\" attr.type=\"string\"/>" << endl;
    fout << "<key id=\"arrow\" for=\"edge\" attr.name=\"Arrow\" attr.type=\"string\"/>" << endl;
    //fout<< " <default> Arrow </default>" <<endl;
    //fout<< "</key>"<<endl;

    fout << "<key id=\"Style\" for=\"edge\" attr.name=\"Line_Type\" attr.type=\"string\"/>" << endl;
    fout << "<key id=\"int\" for=\"edge\" attr.name=\"interaction\" attr.type=\"string\"/>" << endl;
    fout << "\n" << endl;



    //key for node
    fout << "<key id=\"Name\" for=\"node\" attr.name=\"display_ids\" attr.type=\"string\">" << endl;
    fout << " <default> Untitled! </default>" << endl;
    fout << "</key>" << endl;


    fout << "<key id=\"Type\" for=\"node\" attr.name=\"type\" attr.type=\"string\"/>" << endl;

    fout << "<key id=\"Shape\" for=\"node\" attr.name=\"Shape\" attr.type=\"string\"/>" << endl;
    fout << "<key id=\"ncolor\" for=\"node\" attr.name=\"Node_Color\" attr.type=\"string\"/>" << endl;

    fout << "<key id=\"URL\" for=\"node\" attr.name=\"url\" attr.type=\"string\" />" << endl;
    fout << "<key id=\"Description\" for=\"node\" attr.name=\"description\" attr.type=\"string\"  />" << endl;
    fout << "<key id=\"Label\" for=\"node\" attr.name=\"label\" attr.type=\"string\"/>" << endl;






    int gid = get_graph_id();

    fout << "\t<graph id=\"" << gid << "\" edgedefault=\"directed\">" << endl;
    //std::string nme = NULL; 
    std::string nme2;
    std::string nme1 = "/home/sysbio/uddipaan-cse-git/network_tool";

    std::cout << "\nEnter a file path for storing the repository as html (e.g. /foldername/filename.html) " << endl;
    std::cout << "!!NOTE:Write the file directory as shown in the eg, use of \"..\" is prohibited due to underlying mechanisms of this functionality!! \n Also the file is automatically directed to be created under \"/home/sysbio/uddipaan-cse-git/network_tool\" further it can be made more dynamic when file directory will be stored in some seperate structure \n(if html is not required then type \"no\"):";

    std::cin >> nme2;

    if (!b_mode) {
        std::cout << "\nEnter a file path for storing the repository as html (e.g. /foldername/filename.html): ";
        std::cin >> nme2;
    } else {
        nme2 = token_cmd[cmd_index++];
    }

    std::string nme = nme1 + nme2;







    if (nme2 == "no") {
        nme = "";
    }


    map<int, int> nid_to_ml_node_id_map;

    int ml_node_id = 1;
    for (vector<int>::iterator nid_itr = NIDSg.begin(); nid_itr != NIDSg.end(); ++nid_itr) {
        nid_to_ml_node_id_map[*nid_itr] = ml_node_id;
        ++ml_node_id;
    }


    set<int> drawn_nodes;

    //nodes are taken care of here
    int count = 0;
    for (vector<int>::iterator nid_itr = NIDSg.begin(); nid_itr != NIDSg.end(); ++nid_itr) {

        set<int>::iterator drawn_nodes_itr = drawn_nodes.find(*nid_itr);
        if (drawn_nodes_itr == drawn_nodes.end()) {
            write_node_to_grml_file(*nid_itr, nid_to_ml_node_id_map, fout, color_map_filename, 0);
        }
        count++;
    }

    cout << count << " node(s) written to graphml file" << endl;


    //edges are taken care of here


    map<int, int> eid_to_ml_edge_id_map;


    int ml_edge_id = 1;
    for (vector<int>::iterator eid_itr = EIDSg.begin(); eid_itr != EIDSg.end(); ++eid_itr) {

        eid_to_ml_edge_id_map[*eid_itr] = ml_edge_id;
        ++ml_edge_id;
    }
    set<int> drawn_edge;
    count = 0;
    for (vector<int>::iterator eid_itr = EIDSg.begin(); eid_itr != EIDSg.end(); ++eid_itr) {

        set<int>::iterator drawn_edge_itr = drawn_edge.find(*eid_itr);
        if (drawn_edge_itr == drawn_edge.end()) {
            //cout<<*eid_itr;

            write_edge_to_grml_file(*eid_itr, eid_to_ml_edge_id_map, fout, nme);
        }

        count++;

    }
    cout << count << " edges written to graphml file" << endl;

    fout << "  </graph>" << endl;
    fout << "</graphml>" << endl;



    if (nme2 != "no") {

        //writing the html repository
        cout << "Please wait while we create your repository! |*__*| " << endl;




        //std::string pth = "../html/";
        //std::string nme;
        //nme = "repo"+std::to_string(gid)+".html";


        ofstream hout((nme).c_str());

        hout << "<!DOCTYPE html>" << endl;
        hout << "<html>" << endl;
        hout << "<head>" << endl;
        hout << "<title>Repository</title>" << endl;
        hout << "</head>" << endl;
        hout << "<body style=\"background-color:powderblue;\">" << endl;

        hout << "<h2 style=\"color:red;text-align:center;font-family:courier;\">Repository</h2>" << endl;


        for (vector<int>::iterator eid_itr = EIDSg.begin(); eid_itr != EIDSg.end(); ++eid_itr) {

            set<int>::iterator drawn_edge_itr = drawn_edge.find(*eid_itr);
            if (drawn_edge_itr == drawn_edge.end()) {
                //cout<<*eid_itr;

                write_edge_to_html(*eid_itr, eid_to_ml_edge_id_map, hout);
            }

        }
        hout << "<a style=\"text-align:left;\">Done by:Uddipaan's Converter</a>" << endl;
        hout << "</body>" << endl;
        hout << "</html>" << endl;
        cout << "We are good to go, have fun! |^_^|" << endl;
    }

}

void GraphNew::convert_to_graphml_new(GraphManagerNew * graph_man, std::ofstream &fout, string log_fold_change_filename, bool b_mode, vector<string> &token_cmd, int &cmd_index) {

    map<int, float> nid_to_expr_value_map;
    graph_man->read_fold_change_values_into_map(this, nid_to_expr_value_map, log_fold_change_filename, 0);
        
    std::string color_map_filename; //for color
    if (!b_mode) {
        cout << "Enter color map filename (0 to skip): ";
        cin >> color_map_filename;
    } else {
        color_map_filename = token_cmd[cmd_index++];
    }
    fout << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" << endl;
    fout << "<graphml xmlns=\"http://graphml.graphdrawing.org/xmlns\"" << endl;
    fout << "\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"" << endl;
    fout << "\txmlns:y=\"http://www.yworks.com/xml/graphml\"" << endl;
    fout << "\txsi:schemaLocation=\"http://graphml.graphdrawing.org/xmlns" << endl;
    fout << "\thttp://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd\">" << endl;


    //key for graph
    fout << "<key id=\"Name\" for=\"graph\" attr.name=\"Name\" attr.type=\"string\"/>" << endl;
    fout << "<key id=\"Org\" for=\"graph\" attr.name=\"Org\" attr.type=\"string\"/>" << endl;
    fout << "<key id=\"Title\" for=\"graph\" attr.name=\"Title\" attr.type=\"string\"/>" << endl;
    fout << "<key id=\"Number\" for=\"graph\" attr.name=\"Number\" attr.type=\"double\"/>" << endl;
    fout << "\n" << endl;


    //key for edge
    fout << "<key id=\"Relation\" for=\"edge\" attr.name=\"relationship_type\" attr.type=\"string\"/>" << endl;
    fout << "<key id=\"Type\" for=\"edge\" attr.name=\"Label\" attr.type=\"string\"/>" << endl;
    fout << "<key id=\"ecolor\" for=\"edge\"  attr.name=\"Edge_Color\" attr.type=\"string\"/>" << endl;
    //fout<< "<key id=\"Pathway\" for=\"edge\" attr.name=\"mincut\" attr.type=\"string\"/>"<<endl;
    fout << "<key id=\"ID\" for=\"edge\" attr.name=\"ID\" attr.type=\"string\"/>" << endl;
    fout << "<key id=\"arrow\" for=\"edge\" attr.name=\"Arrow\" attr.type=\"string\"/>" << endl;
    fout << "<key id=\"Weight\" for=\"edge\" attr.name=\"Weight\" attr.type=\"int\"/>" << endl;
    //fout<< " <default> Arrow </default>" <<endl;
    //fout<< "</key>"<<endl;

    fout << "<key id=\"Style\" for=\"edge\" attr.name=\"Line_Type\" attr.type=\"string\"/>" << endl;
    fout << "<key id=\"int\" for=\"edge\" attr.name=\"interaction\" attr.type=\"string\"/>" << endl;
    fout << "<key id=\"Name\" for=\"edge\" attr.name=\"name\" attr.type=\"string\"/>" << endl; // added by sukanya on 5 Aug 2016
    fout << "\n" << endl;


    //key for node
    fout << "<key id=\"Name\" for=\"node\" attr.name=\"display_ids\" attr.type=\"string\">" << endl;
    fout << " <default> Untitled! </default>" << endl;
    fout << "</key>" << endl;


    fout << "<key id=\"Type\" for=\"node\" attr.name=\"type\" attr.type=\"string\"/>" << endl;

    fout << "<key id=\"Shape\" for=\"node\" attr.name=\"Shape\" attr.type=\"string\"/>" << endl;
    fout << "<key id=\"ncolor\" for=\"node\" attr.name=\"Node_Color\" attr.type=\"string\"/>" << endl;

    fout << "<key id=\"URL\" for=\"node\" attr.name=\"url\" attr.type=\"string\" />" << endl;
    fout << "<key id=\"Description\" for=\"node\" attr.name=\"description\" attr.type=\"string\"  />" << endl;
    fout << "<key id=\"Label\" for=\"node\" attr.name=\"label\" attr.type=\"string\"/>" << endl;
    fout << "<key id=\"Degree\" for=\"node\" attr.name=\"Degree\" attr.type=\"int\"/>" << endl;
    fout << "<key id=\"LogFold\" for=\"node\" attr.name=\"LogFold\" attr.type=\"int\"/>" << endl;

    int gid = get_graph_id();

    fout << "\t<graph id=\"" << gid << "\" edgedefault=\"directed\">" << endl;
    //std::string nme = NULL; 
    std::string nme2;

    //std::string nme1 = "/home/sysbio/uddipaan-cse-git/network_tool";
    std::string nme1 = "";

    std::cout << "\nEnter a file path for storing the repository as html (e.g. /foldername/filename.html) " << endl;
    std::cout << "!!NOTE:Write the file directory as shown in the eg, use of \"..\" is prohibited due to underlying mechanisms of this functionality!! \n Also the file is automatically directed to be created under \"/home/sysbio/uddipaan-cse-git/network_tool\" further it can be made more dynamic when file directory will be stored in some seperate structure \n(if html is not required then type \"no\"):";

    ////std::cin >> nme2;


    if (!b_mode) {
        std::cout << "\nEnter a file path for storing the repository as html (e.g. /foldername/filename.html): ";
        std::cin >> nme2;
    } else {
        nme2 = token_cmd[cmd_index++];
    }

    std::string nme = nme1 + nme2;


    if (nme2 == "no") {
        nme = "";
    }


    map<int, int> nid_to_ml_node_id_map;

    int ml_node_id = 1;
    for (vector<int>::iterator nid_itr = NIDSg.begin(); nid_itr != NIDSg.end(); ++nid_itr) {
        nid_to_ml_node_id_map[*nid_itr] = ml_node_id;
        ++ml_node_id;
    }


    set<int> drawn_nodes;

    //nodes are taken care of here
    int count = 0;
    for (vector<int>::iterator nid_itr = NIDSg.begin(); nid_itr != NIDSg.end(); ++nid_itr) {
        int curr_nid = *nid_itr;
        
        int fold_change = (int) ceil((nid_to_expr_value_map[curr_nid] * 10) + 35);
        
        if (is_isolated_node(curr_nid)) {
            //cout << get_all_display_ids_of_node(curr_nid)[0] << " is isolated" << endl;
            continue;
        }
        set<int>::iterator drawn_nodes_itr = drawn_nodes.find(curr_nid);
        if (drawn_nodes_itr == drawn_nodes.end()) {
            //cout<<curr_nid;
            write_node_to_grml_file(curr_nid, nid_to_ml_node_id_map, fout, color_map_filename, fold_change);
        }
        count++;
    }

    cout << count << " node(s) written to graphml file" << endl;


    //edges are taken care of here


    map<int, int> eid_to_ml_edge_id_map;


    int ml_edge_id = 1;
    for (vector<int>::iterator eid_itr = EIDSg.begin(); eid_itr != EIDSg.end(); ++eid_itr) {

        eid_to_ml_edge_id_map[*eid_itr] = ml_edge_id;
        ++ml_edge_id;
    }
    set<int> drawn_edge;
    count = 0;
    for (vector<int>::iterator eid_itr = EIDSg.begin(); eid_itr != EIDSg.end(); ++eid_itr) {

        set<int>::iterator drawn_edge_itr = drawn_edge.find(*eid_itr);
        if (drawn_edge_itr == drawn_edge.end()) {
            //cout<<*eid_itr;

            write_edge_to_grml_file(*eid_itr, eid_to_ml_edge_id_map, fout, nme);
        }

        count++;

    }
    cout << count << " edges written to graphml file" << endl;

    fout << "  </graph>" << endl;
    fout << "</graphml>" << endl;



    if (nme2 != "no") {

        // -- added by sukanya on 23 Aug 2016
        string up_reg_filename, down_reg_filename;
        if (!b_mode) {
            cout << "\nEnter file for up regulated entries: ";
            cin >> up_reg_filename;
            cout << "\nEnter file for down regulated entries: ";
            cin >> down_reg_filename;
        } else {
            up_reg_filename = token_cmd[cmd_index++];
            down_reg_filename = token_cmd[cmd_index++];
        }
        string id;
        ifstream ifs_up(up_reg_filename.c_str()), ifs_down(down_reg_filename.c_str());
        set<string> up_reg_rep_ids, down_reg_rep_ids;

        if (!ifs_up.is_open()) {
            cerr << "Error: file " + up_reg_filename + " can't be opened." << endl;

        }
        if (!ifs_down.is_open()) {
            cerr << "Error: file " + down_reg_filename + " can't be opened." << endl;

        }
        while (ifs_up >> id) {
            string repid = get_rep_id_from_id(id);
            if (repid != "") {
                up_reg_rep_ids.insert(repid);
            }
        }
        ifs_up.close();
        while (ifs_down >> id) {
            string repid = get_rep_id_from_id(id);
            if (repid != "") {
                down_reg_rep_ids.insert(repid);
            }
        }
        ifs_down.close();
        // --


        //writing the html repository
        cout << "Please wait while we create your repository! |*__*| " << endl;




        //std::string pth = "../html/";
        //std::string nme;
        //nme = "repo"+std::to_string(gid)+".html";


        set<string> up_reg_in_all_mincut;
        set<string> down_reg_in_all_mincut;

        ofstream hout((nme).c_str());

        hout << "<!DOCTYPE html>" << endl;
        hout << "<html>" << endl;
        hout << "<head>" << endl;
        hout << "<title>Repository</title>" << endl;
        hout << "</head>" << endl;
        //hout<<"<body style=\"background-color:powderblue;\">"<<endl;
        hout << "<body style=\"background-color:#FFFFF0;\">" << endl;

        hout << "<h2 style=\"color:red;text-align:center;font-family:courier;\">Repository</h2>" << endl;

        // explantion section added by sukanya on 8 Aug 2016
        if (get_edge_type(*EIDSg.begin()) == "gh_edge") {
            hout << "<div id=\"explanation\"></div>" << endl;
            hout << "<p style=\"border: black 2px solid\">";
            hout << "<br>" << endl;
            hout << "<b>Explanation</b><br><br>" << endl;
            hout << "Each entry represents the mincut edges between two nodes (in bold)<br>" << endl;
            hout << "It will be sufficient to remove the listed edges to disconnect the two nodes<br><br>" << endl;
            hout << "For example:<br><br>" << endl;
            hout << "To disconnect <b>ACTN4</b> from <b>TRAF2</b> <br>" << endl;
            hout << "remove all of the following edges<br>" << endl;
            hout << "MAGI3 &#8212; ACTN4<br>" << endl;
            hout << "CTNNB1 &#8212; MAGI3<br>" << endl;
            hout << "ACTN4 &#8212; MAGI3<br>" << endl;
            hout << "MAGI3 &#8212; PTEN<br><br>" << endl;
            hout << "means removing all the four edges will be enough to disconnect <b>ACTN4</b> and <b>TRAF2</b><br>" << endl;
            hout << "The listed edges may be directed/undirected and activating/inhibiting, etc.<br>" << endl;
            hout << "The entry MAGI3 &#8212; ACTN4 only means the edge from MAGI3 to ACTN4<br>" << endl;
            hout << "It is not necessarily an undirected edge.<br><br>" << endl;
            hout << "The entries of the form [ITGB1+ITGA11] represent a complex of ITGB1 and ITGA11<br><br>" << endl;
            hout << "</p>" << endl;
        }

        for (vector<int>::iterator eid_itr = EIDSg.begin(); eid_itr != EIDSg.end(); ++eid_itr) {
            //if ((!edge_has_subtype(*eid_itr, "dummy_u_to_d")) && (!edge_has_subtype(*eid_itr, "dummy_d_to_u"))) {
            if (!edge_has_subtype(*eid_itr, "dummy_d_to_u")) {
                set<int>::iterator drawn_edge_itr = drawn_edge.find(*eid_itr);
                if (drawn_edge_itr == drawn_edge.end()) {
                    //cout<<*eid_itr;

                    write_edge_to_html_new(*eid_itr, eid_to_ml_edge_id_map, hout, up_reg_rep_ids, down_reg_rep_ids, up_reg_in_all_mincut, down_reg_in_all_mincut);
                }
            }

        }
        hout << "<br>" << endl;
        hout << "<a style=\"text-align:left;\">Done by:Uddipaan's Converter</a>" << endl;
        hout << "</body>" << endl;
        hout << "</html>" << endl;
        cout << "We are good to go, have fun! |^_^|" << endl;

#ifdef DEBUG_FLAG
        debug_log << "Up regulated genes appearing in mincuts: " << endl;
        for (set<string>::iterator up_itr = up_reg_in_all_mincut.begin(); up_itr != up_reg_in_all_mincut.end(); up_itr++) {
            debug_log << (*up_itr) << endl;
        }
        debug_log << "Down regulated genes appearing in mincuts: " << endl;
        for (set<string>::iterator down_itr = down_reg_in_all_mincut.begin(); down_itr != down_reg_in_all_mincut.end(); down_itr++) {
            debug_log << (*down_itr) << endl;
        }

#endif

    }

}

// -- Uddipaan's original method starts here

void GraphNew::write_edge_to_html(int eid, map<int, int>& eid_to_ml_edge_id_map, std::ofstream &hout) {


    int source_id = get_source_node(eid);
    int target_id = get_target_node(eid);

    string source_name = get_all_display_ids_of_node(source_id)[0];
    string target_name = get_all_display_ids_of_node(target_id)[0];
    //std::string eds_names = get_all_display_ids_of_node(source_id)[0];
    //std::string edt_names = get_all_display_ids_of_node(target_id)[0];

    //string label;
    string type = get_edge_type(eid);
    int count = 1;
    vector<string> subtypes = get_edge_subtypes_of_edge(eid);




    hout << "\n" << endl;
    hout << "<h1 style=\"color:green;text-align:center;\" id= " << eid << "> Edge id is: " << eid << " </h1>" << endl;


    //pathway(mincut info) processed here
    //hout<<"<p>";
    //for (unordered_map<int, EdgeNew *>::iterator edge_map_itr = eid_to_edge_map.begin(); edge_map_itr != eid_to_edge_map.end(); ++edge_map_itr) {

    //hout<<"<p style=\"text-align:center;\"
    hout << "\n" << endl;
    hout << "<p style=\"text-align:center;\">";
    //vector<string> edge_pathways = edge_map_itr->second->get_pathways();
    hout << "<br> Source Name: " << source_name << endl;
    hout << "<br> Target Name: " << target_name << endl;
    hout << "<br> Relation: " << type << endl;

    hout << "<br> Type: ";
    for (vector<string>::iterator itr = subtypes.begin(); itr != subtypes.end(); ++itr) {
        hout << *itr << endl;
    }


    vector<string> edge_pathways = get_all_pathways_for_edge(eid);

    if (!edge_pathways.empty()) {
        hout << "<br> Pathways:" << endl;
        for (std::vector<string>::iterator itr = edge_pathways.begin(); itr != edge_pathways.end(); ++itr) {
            hout << "<br>" << *itr << " " << endl;
        }
    }
    hout << "</p>" << endl;

    hout << "\n" << endl;

}

// -- Uddipaan's original method ends here

void GraphNew::write_mincut_edge_to_html(int eid, std::ofstream &hout, set<string>& up_reg_rep_ids, set<string>& down_reg_rep_ids, map<string, int>& nodes_in_mincut, map<string, int>& nodes_in_all_mincuts, set<string>& written_edges) {

    
    int source_id = get_source_node(eid);
    int target_id = get_target_node(eid);

    string src_rep_id = get_rep_id_from_nid(source_id);
    string tgt_rep_id = get_rep_id_from_nid(target_id);
    
    string src_tgt_rep_ids = src_rep_id + "_" + tgt_rep_id;
                
    if (written_edges.find(src_tgt_rep_ids) != written_edges.end())
        return;
    written_edges.insert(src_tgt_rep_ids);
    
    string source_name = get_all_display_ids_of_node(source_id)[0];
    string target_name = get_all_display_ids_of_node(target_id)[0];


    string type = get_edge_type(eid);
    vector<string> subtypes = get_edge_subtypes_of_edge(eid);

    int weight = get_edge_weight(eid);
    vector<float> weight_factors = get_weight_tuple_for_edge(eid);

    if (up_reg_rep_ids.find(src_rep_id) != up_reg_rep_ids.end())
        hout << "<span style=\"color: #009900\">" << get_all_display_ids_of_node(get_nid_from_rep_id(src_rep_id))[0] << "</span>";
    else if (down_reg_rep_ids.find(src_rep_id) != down_reg_rep_ids.end())
        hout << "<span style=\"color: #ff0000\">" << get_all_display_ids_of_node(get_nid_from_rep_id(src_rep_id))[0] << "</span>";
    else
        hout << "<span style=\"color: #000000\">" << get_all_display_ids_of_node(get_nid_from_rep_id(src_rep_id))[0] << "</span>";

       
    auto node_iter = nodes_in_mincut.find(src_rep_id);
        
    if (node_iter != nodes_in_mincut.end())
        node_iter->second++;
    else 
        nodes_in_mincut[src_rep_id] = 1;
        
    auto node_iter2 = nodes_in_all_mincuts.find(src_rep_id);
    if (node_iter2 != nodes_in_all_mincuts.end())
        node_iter2->second++;
    else 
        nodes_in_all_mincuts[src_rep_id] = 1;
    
   
    //hout << " &#8212; ";
    hout << " &#8594; ";
        
    //cout << tgt_rep_id << endl;
    if (up_reg_rep_ids.find(tgt_rep_id) != up_reg_rep_ids.end())
        hout << "<span style=\"color: #009900\">" << get_all_display_ids_of_node(get_nid_from_rep_id(tgt_rep_id))[0] << "</span>";
    else if (down_reg_rep_ids.find(tgt_rep_id) != down_reg_rep_ids.end())
        hout << "<span style=\"color: #ff0000\">" << get_all_display_ids_of_node(get_nid_from_rep_id(tgt_rep_id))[0] << "</span>";
    else
        hout << "<span style=\"color: #000000\">" << get_all_display_ids_of_node(get_nid_from_rep_id(tgt_rep_id))[0] << "</span>";


    node_iter = nodes_in_mincut.find(tgt_rep_id);
        
    if (node_iter != nodes_in_mincut.end())
        node_iter->second++;
    else 
        nodes_in_mincut[tgt_rep_id] = 1;
    
    node_iter2 = nodes_in_all_mincuts.find(tgt_rep_id);
    if (node_iter2 != nodes_in_all_mincuts.end())
        node_iter2->second++;
    else 
        nodes_in_all_mincuts[tgt_rep_id] = 1;
        
        
    hout << "<span style=\"color: #808080\">";
    hout << "\t\t{";
    hout << std::setprecision(PRECISION) << *weight_factors.begin();
    for (auto i = weight_factors.begin()+1; i != weight_factors.end(); i++) {
        hout << ", " << std::setprecision(PRECISION) << *i;
    }

    hout << "} = " << weight << endl;
    hout << "</span>";
    hout << "<br>" << endl;

    
   
}

// -- Sukanya's edited method starts here

void GraphNew::write_edge_to_html_new(int eid, map<int, int>& eid_to_ml_edge_id_map, std::ofstream &hout, set<string>& up_reg_rep_ids, set<string>& down_reg_rep_ids, set<string>& up_reg_in_all_mincut, set<string>& down_reg_in_all_mincut) {


    // this part makes sure a source-target pair (edge) is not written onto the html file twice
    static set<pair<int, int> > written_pairs;

    int source_id = get_source_node(eid);
    int target_id = get_target_node(eid);

    if (written_pairs.find(make_pair(source_id, target_id)) != written_pairs.end())
        return;

    written_pairs.insert(make_pair(source_id, target_id));


    string source_name = get_all_display_ids_of_node(source_id)[0];
    string target_name = get_all_display_ids_of_node(target_id)[0];
    //std::string eds_names = get_all_display_ids_of_node(source_id)[0];
    //std::string edt_names = get_all_display_ids_of_node(target_id)[0];

    //string label;
    string type = get_edge_type(eid);
    int count = 1;
    vector<string> subtypes = get_edge_subtypes_of_edge(eid);

    //hout<<"<h1 id= "<<eid<< "> Edge id is: "<<eid<<" </h1>"<<endl;
    hout << "<div id=" << eid << "></div>" << endl;

    vector<string> edge_pathways = get_all_pathways_for_edge(eid);
    if (!edge_pathways.empty()) {

        if (type == "gh_edge") {
            hout << "\n\n" << endl;
            //hout<<"<p id= "<<eid<< "> <small> Edge "<<eid<<"</small> </p>"<<endl;
            //out<<"\n"<<endl;
            hout << "<p style=\"text-align:left;\">";
            //vector<string> edge_pathways = edge_map_itr->second->get_pathways();
            hout << "<br> <br> To disconnect <b>" << source_name << "</b> ";
            hout << "from <b> " << target_name << "</b>";
            hout << "<br>remove all of the following edges <br>" << endl;

            // added by sukanya on 7th Oct 2016
            // to show parallel edges only once
            std::unique(edge_pathways.begin(), edge_pathways.end());


            for (std::vector<string>::iterator itr = edge_pathways.begin(); itr != edge_pathways.end(); itr++) {
                string s = *itr;

                //s.replace(s.find("--"), 2, " &#8212; ");
                //hout << "<br>" << s << " " <<endl;
                std::string delimiter = "--";

                size_t pos = 0;
                std::string token;
                hout << "<br>" << endl;
                while ((pos = s.find(delimiter)) != std::string::npos) {

                    token = s.substr(0, pos);
                    string src_rep_id = get_rep_id_from_id(token);
                    //cout << src_rep_id << endl;
                    if (up_reg_rep_ids.find(src_rep_id) != up_reg_rep_ids.end()) {
                        hout << "<span style=\"color: #009900\">" << get_all_display_ids_of_node(get_nid_from_rep_id(src_rep_id))[0] << "</span>";
                        up_reg_in_all_mincut.insert(get_all_display_ids_of_node(get_nid_from_rep_id(src_rep_id))[0]);
                    } else if (down_reg_rep_ids.find(src_rep_id) != down_reg_rep_ids.end()) {
                        hout << "<span style=\"color: #ff0000\">" << get_all_display_ids_of_node(get_nid_from_rep_id(src_rep_id))[0] << "</span>";
                        down_reg_in_all_mincut.insert(get_all_display_ids_of_node(get_nid_from_rep_id(src_rep_id))[0]);
                    } else {
                        hout << "<span style=\"color: #000000\">" << get_all_display_ids_of_node(get_nid_from_rep_id(src_rep_id))[0] << "</span>";
                    }
                    s.erase(0, pos + delimiter.length());
                }
                hout << " &#8212; ";
                string tgt_rep_id = get_rep_id_from_id(s);
                //cout << tgt_rep_id << endl;
                if (up_reg_rep_ids.find(tgt_rep_id) != up_reg_rep_ids.end()) {
                    hout << "<span style=\"color: #009900\">" << get_all_display_ids_of_node(get_nid_from_rep_id(tgt_rep_id))[0] << "</span>";
                    up_reg_in_all_mincut.insert(get_all_display_ids_of_node(get_nid_from_rep_id(tgt_rep_id))[0]);
                } else if (down_reg_rep_ids.find(tgt_rep_id) != down_reg_rep_ids.end()) {
                    hout << "<span style=\"color: #ff0000\">" << get_all_display_ids_of_node(get_nid_from_rep_id(tgt_rep_id))[0] << "</span>";
                    down_reg_in_all_mincut.insert(get_all_display_ids_of_node(get_nid_from_rep_id(tgt_rep_id))[0]);
                } else {
                    hout << "<span style=\"color: #000000\">" << get_all_display_ids_of_node(get_nid_from_rep_id(tgt_rep_id))[0] << "</span>";
                }
                //}
            }
        } else {
            hout << "\n" << endl;
            hout << "<p style=\"text-align:left;\">";
            //vector<string> edge_pathways = edge_map_itr->second->get_pathways();
            hout << "<br> Source Name: " << source_name << endl;
            hout << "<br> Target Name: " << target_name << endl;
            hout << "<br> Edge type: " << type << " ";

            hout << "<br> Edge subtypes: ";
            for (vector<string>::iterator itr = subtypes.begin(); itr != subtypes.end(); ++itr) {
                hout << *itr << " ";
            }
            hout << endl;
            hout << "<br> Pathways:" << endl;
            for (std::vector<string>::iterator itr = edge_pathways.begin(); itr != edge_pathways.end(); ++itr) {
                hout << "<br>" << *itr << " " << endl;
            }
        }

    }
    hout << "</p>" << endl;

    // sukanya
    if (type == "gh_edge") {
        hout << "<a href=\"#explanation\">Explanation</a><br>" << endl;
    }

    hout << "\n" << endl;

}

// -- Sukanya'a edited method ends here

void GraphNew::convert_to_gml(std::ofstream &fout) {



    int a = get_graph_id();
    fout << "graph [" << endl;
    fout << "directed 1" << endl;
    fout << "id " << a << endl;



    map<int, int> nid_to_ml_node_id_map;

    int ml_node_id = 1;
    for (vector<int>::iterator nid_itr = NIDSg.begin(); nid_itr != NIDSg.end(); ++nid_itr) {
        nid_to_ml_node_id_map[*nid_itr] = ml_node_id;
        ++ml_node_id;
    }



    //nodes are taken care of here
    int count = 0;
    for (vector<int>::iterator nid_itr = NIDSg.begin(); nid_itr != NIDSg.end(); ++nid_itr) {
        write_node_to_gml_file(*nid_itr, nid_to_ml_node_id_map, fout);
        count++;
    }
    cout << count << " node(s) written to gml file" << endl;



    //edges are taken care of here

    map<int, int> eid_to_ml_edge_id_map;


    int ml_edge_id = 1;
    for (vector<int>::iterator eid_itr = EIDSg.begin(); eid_itr != EIDSg.end(); ++eid_itr) {

        eid_to_ml_edge_id_map[*eid_itr] = ml_edge_id;
        ++ml_edge_id;
    }

    count = 0;
    for (vector<int>::iterator eid_itr = EIDSg.begin(); eid_itr != EIDSg.end(); ++eid_itr) {

        write_edge_to_gml_file(*eid_itr, eid_to_ml_edge_id_map, fout);
        count++;
    }
    cout << count << " edges written to gml file" << endl;
    fout << "]" << endl;



}

// status check
//anjan

int GraphManagerNew::create_node(int itr_no, int org_nseq, GraphNew *residual_graph, map<int, int>& map_nseq_to_res_graph_nid, int node_height, int node_excess) {

    int new_nid;
    // creating the node for i      
    if (map_nseq_to_res_graph_nid.find(org_nseq) == map_nseq_to_res_graph_nid.end()) {
        new_nid = residual_graph->create_new_node();

        residual_graph->add_node_id(new_nid);
        add_node_id_graph_id(new_nid, residual_graph->get_graph_id());

        residual_graph->add_component_id_for_node(new_nid, org_nseq); // nseq in original graph
        residual_graph->add_component_id_for_node(new_nid, itr_no); // identifier of mincut call
        residual_graph->add_component_id_for_node(new_nid, node_height); // height
        residual_graph->add_component_id_for_node(new_nid, node_excess); // excess

        map_nseq_to_res_graph_nid.insert(pair<int, int>(org_nseq, new_nid));
    } else {
        new_nid = map_nseq_to_res_graph_nid[org_nseq];
        //the node may or may not be the same for present iteration
        if(residual_graph->get_component_ids_of_node(new_nid)[1] != itr_no){
        	residual_graph->update_component_of_node_at_index(new_nid, 1, itr_no); // updating identifier of mincut call
        	residual_graph->update_component_of_node_at_index(new_nid, 2, node_height); // updating height
        	residual_graph->update_component_of_node_at_index(new_nid, 3, node_excess); // updating excess
        }

    }

    return new_nid;

}

int GraphManagerNew::get_node_from_src_tgt(int src, int tgt, map<string, long int>& map_src_tgt_to_eid) {
    stringstream ss;
    ss << src << ":" << tgt;
    return map_src_tgt_to_eid[ss.str()];
}

long int GraphManagerNew::create_edge(int itr_no, int curr_node_id, int succ_node_id, int eid_in_org_graph, map<string, long int>& map_src_tgt_to_eid, GraphNew * residual_graph, int capacity, string type) {
    long int new_eid_in_res_graph = residual_graph->create_new_edge();
    residual_graph->add_edge_id(new_eid_in_res_graph);
    add_edge_id_graph_id(new_eid_in_res_graph, residual_graph->get_graph_id());
    residual_graph->add_source_node(new_eid_in_res_graph, curr_node_id);
    residual_graph->add_target_node(new_eid_in_res_graph, succ_node_id);
    residual_graph->add_edge_to_outlist_of_node(curr_node_id, new_eid_in_res_graph);
    residual_graph->add_edge_to_inlist_of_node(succ_node_id, new_eid_in_res_graph);
    residual_graph->set_other_value1_in_edge(new_eid_in_res_graph, itr_no); // identifier of mincut call
    residual_graph->set_other_value2_in_edge(new_eid_in_res_graph, capacity); // capacity
    residual_graph->set_other_value4_in_edge(new_eid_in_res_graph, eid_in_org_graph); // eid in original graph
    residual_graph->add_edge_type(new_eid_in_res_graph, type);

    //cout<<curr_node_id<<"["<<residual_graph->get_component_ids_of_node(curr_node_id)[0]<<"]"<<"->"<<new_eid_in_res_graph<<"["<<residual_graph->get_other_value4_in_edge(new_eid_in_res_graph)<<"]"<<"->"<<succ_node_id<<"["<<residual_graph->get_component_ids_of_node(succ_node_id)[0]<<"]"<<endl;

    stringstream ss;
    ss << curr_node_id << ":" << succ_node_id;
    map_src_tgt_to_eid.insert(pair<string, long int>(ss.str(), new_eid_in_res_graph));

    return new_eid_in_res_graph;
}

void GraphManagerNew::reset_edge(map<string, long int>& map_src_tgt_to_eid, int src, int tgt, int itr_no, GraphNew * residual_graph) {
    int edge_id = get_node_from_src_tgt(src, tgt, map_src_tgt_to_eid);

    residual_graph->set_other_value1_in_edge(edge_id, itr_no); // identifier of mincut call
    residual_graph->set_other_value2_in_edge(edge_id, 1); // capacity

}

int GraphManagerNew::get_outgoing_edges_explored(GraphNew * original_graph, GraphNew * residual_graph, map<int, int>& map_nseq_to_res_graph_nid, map<string, long int>& map_src_tgt_to_eid, vector<vector<bool >> &edge_exist, int org_node_id, int itr_no) {
    vector<int>::iterator vec_itr;
    int succ_node_id, succ_node_seq, curr_nid_in_res, height_of_target, tar_nid_in_res, org_rev_eid;
    vector<int> outlist;

    outlist = original_graph->get_outlist(org_node_id); //fetch outgoing edges of a node in ORIGINAL graph
    for (vec_itr = outlist.begin(); vec_itr != outlist.end(); vec_itr++) {
        if (NOT_INTERAC_EDGE(original_graph, *vec_itr))
            continue;

        succ_node_id = original_graph->get_target_node(*vec_itr);
        if (succ_node_id == org_node_id) //self loop handling and checking already in the List
            continue;

        int org_node_seq = GET_NODE_SEQ_NUM(original_graph, org_node_id);
        int succ_node_seq = GET_NODE_SEQ_NUM(original_graph, succ_node_id);
        curr_nid_in_res = map_nseq_to_res_graph_nid[org_node_seq];

        if (map_nseq_to_res_graph_nid.find(succ_node_seq) == map_nseq_to_res_graph_nid.end()) {//if target node is not created

            tar_nid_in_res = create_node(itr_no, succ_node_seq, residual_graph, map_nseq_to_res_graph_nid, 0, 0);

            long int new_eid_in_res_graph, rev_eid_in_res_graph;
            if(!original_graph->get_delete_status_for_edge(*vec_itr))
                new_eid_in_res_graph = create_edge(itr_no, curr_nid_in_res, tar_nid_in_res, *vec_itr, map_src_tgt_to_eid, residual_graph, 1, "original"); //forward edge
            else
                new_eid_in_res_graph = create_edge(itr_no, curr_nid_in_res, tar_nid_in_res, *vec_itr, map_src_tgt_to_eid, residual_graph, 0, "not_original"); //forward edge

            //to know if the reverse edge exists
            vector<int> outlist2 = original_graph->get_outlist(succ_node_id);
            org_rev_eid = -1;
            bool orig_edge = false;
            for (vector<int>::iterator out_itr = outlist2.begin(); out_itr != outlist2.end(); out_itr++) {
                if (NOT_INTERAC_EDGE(original_graph, *out_itr))
                    continue;
                if (original_graph->get_target_node(*out_itr) == org_node_id) {
                    org_rev_eid = *out_itr;
                    orig_edge = true;
                    break;
                }

            }

            if (orig_edge && !original_graph->get_delete_status_for_edge(org_rev_eid)) {
                rev_eid_in_res_graph = create_edge(itr_no, tar_nid_in_res, curr_nid_in_res, org_rev_eid, map_src_tgt_to_eid, residual_graph, 1, "original"); //backward edge
            } else {
                rev_eid_in_res_graph = create_edge(itr_no, tar_nid_in_res, curr_nid_in_res, org_rev_eid, map_src_tgt_to_eid, residual_graph, 0, "not_original"); //backward edge
            }

            residual_graph->set_other_value3_in_edge(rev_eid_in_res_graph, new_eid_in_res_graph); // eid of paired reverse edge

            residual_graph->set_other_value3_in_edge(new_eid_in_res_graph, rev_eid_in_res_graph); // eid of paired reverse edge
            edge_exist[org_node_seq][succ_node_seq] = true;
            edge_exist[succ_node_seq][org_node_seq] = true;
        } else {//target node already created - this will not effect the source and target for push-relabel as they are created at beggining
            int tar_nid_in_res = map_nseq_to_res_graph_nid[succ_node_seq];
            if (residual_graph->get_component_ids_of_node(tar_nid_in_res)[1] != itr_no){
                residual_graph->update_component_of_node_at_index(tar_nid_in_res, 1, itr_no);
            	residual_graph->update_component_of_node_at_index(tar_nid_in_res, 2, 0); // updating height
            	residual_graph->update_component_of_node_at_index(tar_nid_in_res, 3, 0); // updating excess
            }

            //residual edge may or may not exist
            int res_eid = -1;
            bool res_edge = false;
            vector<int> outlist3 = residual_graph->get_outlist(curr_nid_in_res);

            for (vector<int>::iterator out_itr = outlist3.begin(); out_itr != outlist3.end(); out_itr++) {
                res_eid = *out_itr;
                if (residual_graph->get_target_node(res_eid) == tar_nid_in_res) {
                    res_edge = true;
                    break;
                }
            }

            if (res_edge) {// if res_edge exist

                if (residual_graph->get_other_value1_in_edge(res_eid) != itr_no) {
                    residual_graph->set_other_value1_in_edge(res_eid, itr_no);
                    if (residual_graph->get_edge_type(res_eid) == "original" && !original_graph->get_delete_status_for_edge(*vec_itr))
                        residual_graph->set_other_value2_in_edge(res_eid, 1); // capacity
                    else
                        residual_graph->set_other_value2_in_edge(res_eid, 0); // capacity
                }
                int rev_res_eid = residual_graph->get_other_value3_in_edge(res_eid); // eid of paired reverse edge
                if (residual_graph->get_other_value1_in_edge(rev_res_eid) != itr_no) {
                    residual_graph->set_other_value1_in_edge(rev_res_eid, itr_no);
                    if (residual_graph->get_edge_type(rev_res_eid) == "original" && !original_graph->get_delete_status_for_edge(residual_graph->get_other_value4_in_edge(rev_res_eid)))
                        residual_graph->set_other_value2_in_edge(rev_res_eid, 1);
                    else
                        residual_graph->set_other_value2_in_edge(rev_res_eid, 0);
                }
            } else {// if res_edge NOT exist
                int new_eid_in_res_graph;
                if (!original_graph->get_delete_status_for_edge(*vec_itr))
                    new_eid_in_res_graph = create_edge(itr_no, curr_nid_in_res, tar_nid_in_res, *vec_itr, map_src_tgt_to_eid, residual_graph, 1, "original"); //forward edge
                else
                    new_eid_in_res_graph = create_edge(itr_no, curr_nid_in_res, tar_nid_in_res, *vec_itr, map_src_tgt_to_eid, residual_graph, 0, "not_original"); //forward edge
                int rev_eid_in_orig_graph = -1;

                bool orig_edge = false;
                vector<int> outlist2 = original_graph->get_outlist(succ_node_id);
                for (vector<int>::iterator out_itr = outlist2.begin(); out_itr != outlist2.end(); out_itr++) {
                    if (NOT_INTERAC_EDGE(original_graph, *out_itr))
                        continue;
                    if (original_graph->get_target_node(*out_itr) == org_node_id) {
                        rev_eid_in_orig_graph = *out_itr;
                        orig_edge = true;
                        break;
                    }

                }

                int rev_eid_in_res_graph;
                if (orig_edge && !original_graph->get_delete_status_for_edge(rev_eid_in_orig_graph)) {
                    rev_eid_in_res_graph = create_edge(itr_no, tar_nid_in_res, curr_nid_in_res, rev_eid_in_orig_graph, map_src_tgt_to_eid, residual_graph, 1, "original"); //backward edge
                } else {
                    rev_eid_in_res_graph = create_edge(itr_no, tar_nid_in_res, curr_nid_in_res, rev_eid_in_orig_graph, map_src_tgt_to_eid, residual_graph, 0, "not_original"); //backward edge
                }

                residual_graph->set_other_value3_in_edge(rev_eid_in_res_graph, new_eid_in_res_graph); // eid of paired reverse edge
                residual_graph->set_other_value3_in_edge(new_eid_in_res_graph, rev_eid_in_res_graph); // eid of paired reverse edge
                edge_exist[org_node_seq][succ_node_seq] = true;
                edge_exist[succ_node_seq][org_node_seq] = true;


            }
        }
    }


}

bool GraphManagerNew::ford_BFS(GraphNew * original_graph, GraphNew * residual_graph, vector<bool>& is_outgoing_edges_explored, map<int, int>& map_nseq_to_res_graph_nid, map<string, long int>& map_src_tgt_to_eid, vector<vector<bool >> &edge_exist, vector<int>& q, int src, int dest, int itr_no, unordered_map<int, int>& pred, unordered_map<int, int>& pred_edge) {
    int src_seq = GET_NODE_SEQ_NUM(original_graph, src);
    int dest_seq = GET_NODE_SEQ_NUM(original_graph, dest);
    int qt = 0;
    q[qt++] = src_seq;
    vector<bool> visited(q.size());
    for (int qh = 0; qh < qt; qh++) {
        int u = q[qh]; //take element from the header
        visited[u] = true;
        if (u == dest_seq)
            return true;
        if (is_outgoing_edges_explored[u] == false) {
            get_outgoing_edges_explored(original_graph, residual_graph, map_nseq_to_res_graph_nid, map_src_tgt_to_eid, edge_exist, GET_NODE_ID(original_graph, u), itr_no);
            is_outgoing_edges_explored[u] = true;
        }
        vector<int> outlist;
        int u_res = map_nseq_to_res_graph_nid[u];
        outlist = residual_graph->get_outlist(u_res); //fetch outgoing edges of a node in Residual graph
        for (vector<int>::iterator vec_itr = outlist.begin(); vec_itr != outlist.end(); vec_itr++) {//for each out going edge of the node
            int v_res = residual_graph->get_target_node(*vec_itr);
            int curr_edge_flow = residual_graph->get_other_value2_in_edge(*vec_itr);
            int v_org = residual_graph->get_component_ids_of_node(v_res)[0];
            if (curr_edge_flow > 0 && !visited[v_org]) {
                q[qt++] = v_org;
                pred[v_org] = u;
                pred_edge[v_org] = *vec_itr;
                visited[v_org] = true;
                if (v_org == dest_seq)
                    return true;
            }
        }
    }
    return false;
}

int GraphManagerNew::mincut_ford(GraphNew * original_graph, int i, int j, int N, set<int>& cut_edges, set<int>& set_s) {// N is the number of nodes, i is the curr node SEQ, j is the parent node SEQ.
    static GraphNew * residual_graph;
    static int num_of_nodes, new_gid, itr_no;
    static map<int, int> map_nseq_to_res_graph_nid;
    unordered_map<int, int> pred;
    unordered_map<int, int> pred_edge;
    static map<string, long int> map_src_tgt_to_eid;
    static vector < vector<bool >> edge_exist(N + 1, vector<bool>(N + 1));
    vector<int> q(N + 1);
    vector<bool> is_outgoing_edges_explored(N + 1);
    int result = 0;

    itr_no++; //node 0 has no out-list in original graph. due to mismatch in the original graph, we need to take this.
    //create the gra[h at the first iteration
    if (itr_no == 1) {
        residual_graph = new GraphNew;
        num_of_nodes = N;
        new_gid = ++GraphManagerNew::graph_id_count;
        residual_graph->set_graph_id(new_gid);
        add_graph(new_gid, residual_graph);
        
        // populate adjacency matrix
        //fill_adj_matrix_for_graph(residual_graph);
    }

    int src = GET_NODE_ID(original_graph, i);
    int sink = GET_NODE_ID(original_graph, j);

    cout << i << "---" << j << endl;
    //create node i and j
    int new_nid = create_node(itr_no, i, residual_graph, map_nseq_to_res_graph_nid, N, original_graph->get_outlist(i).size());
    create_node(itr_no, j, residual_graph, map_nseq_to_res_graph_nid, 0, 0);

    pred[i] = -1;
    pred_edge[i] = -1;
    int v_org = j;
    while (ford_BFS(original_graph, residual_graph, is_outgoing_edges_explored, map_nseq_to_res_graph_nid, map_src_tgt_to_eid, edge_exist, q, src, sink, itr_no, pred, pred_edge)) {

        while (pred[v_org] != -1) {
            int u_org = pred[v_org]; //
            int res_edge = pred_edge[v_org];
            int src_res = residual_graph->get_source_node(res_edge);
            int v_res = residual_graph->get_target_node(res_edge);
            int curr_edge_flow = residual_graph->get_other_value2_in_edge(res_edge);
            // update capacity
            residual_graph->set_other_value2_in_edge(res_edge, curr_edge_flow - 1); //1 will be changed later
            int rev_edge_id = get_node_from_src_tgt(v_res, src_res, map_src_tgt_to_eid);
            int rev_edge_flow = residual_graph->get_other_value2_in_edge(rev_edge_id);
            residual_graph->set_other_value2_in_edge(rev_edge_id, rev_edge_flow + 1);

            v_org = u_org;

        }
        pred.clear();
        pred_edge.clear();
        pred[i] = -1;
        pred_edge[i] = -1;
        v_org = j;

        result++;
    }

    set_s.insert(i);
    get_min_cut_edges(original_graph, residual_graph, map_nseq_to_res_graph_nid, i, j, cut_edges, set_s, map_src_tgt_to_eid);
    cout << endl << result << endl;
    /*for (set<int>::iterator out_itr = cut_edges.begin(); out_itr != cut_edges.end(); out_itr++) {
    	cout<<*out_itr<<endl;
    }*/

    return result;

}

inline bool GraphManagerNew::Dinics_BFS(GraphNew * original_graph, GraphNew * residual_graph, vector<bool>& is_outgoing_edges_explored, map<int, int>& map_nseq_to_res_graph_nid, map<string, long int>& map_src_tgt_to_eid, vector<vector<bool >> &edge_exist, vector<int>& dist, vector<int>& q, int src, int dest, int itr_no) {
    fill(dist.begin(), dist.end(), -1);
    int src_seq = GET_NODE_SEQ_NUM(original_graph, src);
    int dest_seq = GET_NODE_SEQ_NUM(original_graph, dest);

    dist[src_seq] = 0;
    int qt = 0;
    q[qt++] = src_seq;
    int flag = 0;
    for (int qh = 0; qh < qt; qh++) {
        int u = q[qh]; //take element from the header
        if (u == dest_seq)
            continue;
        if (is_outgoing_edges_explored[u] == false) {
            get_outgoing_edges_explored(original_graph, residual_graph, map_nseq_to_res_graph_nid, map_src_tgt_to_eid, edge_exist, GET_NODE_ID(original_graph, u), itr_no);
            is_outgoing_edges_explored[u] = true;
        }
        vector<int> outlist;
        int u_res = map_nseq_to_res_graph_nid[u];
        outlist = residual_graph->get_outlist(u_res); //fetch outgoing edges of a node in Residual graph		
        for (vector<int>::iterator vec_itr = outlist.begin(); vec_itr != outlist.end(); vec_itr++) {//for each out going edge of the node 	
            int v_res = residual_graph->get_target_node(*vec_itr);
            int curr_edge_flow = residual_graph->get_other_value2_in_edge(*vec_itr);
            int v_org = residual_graph->get_component_ids_of_node(v_res)[0];
            if (dist[v_org] < 0 && curr_edge_flow > 0) {//graph labelling
                dist[v_org] = dist[u] + 1;
                q[qt++] = v_org;
                //if v_org is the dest then take break from these two loops
                /*if(v_org == dest){
                  flag = 1;
                  break;
                  }*/
            }

        }
        //if(flag == 1)
        //	break;
    }
    return dist[dest_seq] >= 0;
}
int cnt = 0;

int GraphManagerNew::Dinics_DFS(GraphNew * original_graph, GraphNew * residual_graph, vector<bool>& is_outgoing_edges_explored, map<int, int>& map_nseq_to_res_graph_nid, map<string, long int>& map_src_tgt_to_eid, vector<vector<bool >> &edge_exist, vector<int>& dist, vector<int>& work, int src, int target, int f, int itr_no) {
    if (src == target) {//count the number of times it reaches to target
        cnt++;
        return f;
    }
    if (dist[src] >= dist[target])
        return 0;
    /*if (is_outgoing_edges_explored[src] == false) {
        get_outgoing_edges_explored(original_graph, residual_graph, map_nseq_to_res_graph_nid, map_src_tgt_to_eid, edge_exist, src, itr_no);
        is_outgoing_edges_explored[src] = true;
    }*/

    vector<int> outlist;
    int src_res = map_nseq_to_res_graph_nid[src];
    outlist = residual_graph->get_outlist(src_res); //fetch outgoing edges of a node in Residual graph	
    for (vector<int>::iterator vec_itr = outlist.begin(); vec_itr != outlist.end(); vec_itr++) {//for each out going edge of the node
        int v_res = residual_graph->get_target_node(*vec_itr);
        int curr_edge_flow = residual_graph->get_other_value2_in_edge(*vec_itr);
        int v_org = residual_graph->get_component_ids_of_node(v_res)[0];
        if (curr_edge_flow <= 0)
            continue;
        if (dist[v_org] == dist[src] + 1) {
            int df = Dinics_DFS(original_graph, residual_graph, is_outgoing_edges_explored, map_nseq_to_res_graph_nid, map_src_tgt_to_eid, edge_exist, dist, work, v_org, target, min(f, curr_edge_flow), itr_no);
            if (df > 0) {
                // update capacity
                residual_graph->set_other_value2_in_edge(*vec_itr, curr_edge_flow - df);
                int rev_edge_id = get_node_from_src_tgt(v_res, src_res, map_src_tgt_to_eid);
                int rev_edge_flow = residual_graph->get_other_value2_in_edge(rev_edge_id);
                residual_graph->set_other_value2_in_edge(rev_edge_id, rev_edge_flow + df);

                return df;
            }
        }

    }
    return 0;
}

set<int> GraphManagerNew::get_min_cut_edges(GraphNew * original_graph, GraphNew * residual_graph, map<int, int>& map_nseq_to_res_graph_nid, int i, int j, set<int>& cut_edges, set<int>& set_s, map<string, long int>& map_src_tgt_to_eid) { // find the mincut edges
    set<int> visited;
    list<int> bfs_queue;
    // find forward reachable nodes and edges from i
    set<int> set_nodes_frwd_reachable_from_i;
    set<int> set_frwd_edges_from_i_with_zero_capacity;

    bfs_queue.push_back(map_nseq_to_res_graph_nid[i]);
    while (!bfs_queue.empty()) {
        int curr_node = bfs_queue.front();
        bfs_queue.pop_front();
        if (visited.find(curr_node) == visited.end()) {// can be make more efficient by taking a boolean vector work as a flag
            visited.insert(curr_node);
            set_nodes_frwd_reachable_from_i.insert(curr_node);
            int org_node = residual_graph->get_component_ids_of_node(curr_node)[0];
            //if (org_node > i)
            set_s.insert(org_node);
            // traverse outlist
            vector<int> outlist_of_i_side_node = residual_graph->get_outlist(curr_node);
            for (vector<int>::iterator outlist_of_i_itr = outlist_of_i_side_node.begin(); outlist_of_i_itr != outlist_of_i_side_node.end(); outlist_of_i_itr++) {
                int curr_edge = (*outlist_of_i_itr);
                if (residual_graph->get_other_value2_in_edge(curr_edge) == 0) { // stop at zero capacity edge
                    set_frwd_edges_from_i_with_zero_capacity.insert(curr_edge);
                } else {
                    bfs_queue.push_back(residual_graph->get_target_node(curr_edge));
                }
            }
        }
    }

    // find backward reachable nodes and edges from j
    set<int> set_nodes_bkwd_reachable_from_j;
    set<int> set_bkwd_edges_from_j_with_zero_capacity;

    bfs_queue.push_back(map_nseq_to_res_graph_nid[j]);
    while (!bfs_queue.empty()) {
        int curr_node = bfs_queue.front();
        bfs_queue.pop_front();
        if (visited.find(curr_node) == visited.end()) {// can be make more efficient by taking a boolean vector work as a flag
            visited.insert(curr_node);
            set_nodes_bkwd_reachable_from_j.insert(curr_node);
            // traverse inlist
            vector<int> inlist_of_j_side_node = residual_graph->get_inlist(curr_node);
            for (vector<int>::iterator inlist_of_j_itr = inlist_of_j_side_node.begin(); inlist_of_j_itr != inlist_of_j_side_node.end(); inlist_of_j_itr++) {
                int curr_edge = (*inlist_of_j_itr);
                if ((residual_graph->get_other_value2_in_edge(curr_edge) == 0)&&(set_frwd_edges_from_i_with_zero_capacity.find(curr_edge) != set_frwd_edges_from_i_with_zero_capacity.end())) {
                    set_bkwd_edges_from_j_with_zero_capacity.insert(curr_edge);
                    // cut_edges.insert(curr_edge);
                } else {
                    if (residual_graph->get_other_value2_in_edge(curr_edge) == 0)
                        set_bkwd_edges_from_j_with_zero_capacity.insert(curr_edge);
                    bfs_queue.push_back(residual_graph->get_source_node(curr_edge));
                }
            }

        }
    }

    set<int> cut_edges_org;
    std::set<int>::iterator it;

    /*	remember to uncomment cut_edges for (it = cut_edges.begin(); it != cut_edges.end(); ++it)
        {
                int res_eid = *it;
                int res_src = residual_graph->get_source_node(res_eid);
                int res_target = residual_graph->get_target_node(res_eid);
                int rev_eid = get_node_from_src_tgt(res_target, res_src, map_src_tgt_to_eid);
                cut_edges_org.insert(residual_graph->get_other_value4_in_edge(res_eid));
                //cut_edges_org.insert(residual_graph->get_other_value4_in_edge(rev_eid));
	    
            }
	
            cut_edges = cut_edges_org;
        return cut_edges;
     */

    set<int> undirected_cut_edges;
    for (set<int>::iterator set_itr2 = set_frwd_edges_from_i_with_zero_capacity.begin(); set_itr2 != set_frwd_edges_from_i_with_zero_capacity.end(); set_itr2++) {
        int curr_fwd_edge = *set_itr2;
        int curr_tgt = residual_graph->get_component_ids_of_node(residual_graph->get_target_node(curr_fwd_edge))[0];
        int curr_src = residual_graph->get_component_ids_of_node(residual_graph->get_source_node(curr_fwd_edge))[0];
        if (set_nodes_bkwd_reachable_from_j.find(residual_graph->get_target_node(curr_fwd_edge)) != set_nodes_bkwd_reachable_from_j.end()) {
            int curr_src_nseq_in_orig_graph = curr_src;
            int curr_src_nid_in_orig_graph = GET_NODE_ID(original_graph, curr_src_nseq_in_orig_graph);
            //int curr_tgt_nseq_in_orig_graph = residual_graph->get_component_ids_of_node(curr_tgt)[0];
            int curr_tgt_nseq_in_orig_graph = curr_tgt;
            int curr_tgt_nid_in_orig_graph = GET_NODE_ID(original_graph, curr_tgt_nseq_in_orig_graph);
            set<int> all_eids_between_two_nids;
            original_graph->get_all_eids_between_two_nodes(curr_src_nid_in_orig_graph, curr_tgt_nid_in_orig_graph, all_eids_between_two_nids);
            for (set<int>::iterator set_itr_eids = all_eids_between_two_nids.begin(); set_itr_eids != all_eids_between_two_nids.end(); set_itr_eids++) {
                undirected_cut_edges.insert(*set_itr_eids);
            }
            original_graph->get_all_eids_between_two_nodes(curr_tgt_nid_in_orig_graph, curr_src_nid_in_orig_graph, all_eids_between_two_nids);
            for (set<int>::iterator set_itr_eids = all_eids_between_two_nids.begin(); set_itr_eids != all_eids_between_two_nids.end(); set_itr_eids++) {
                undirected_cut_edges.insert(*set_itr_eids);
            }
        }

    }

    set<int>::iterator cut_edges_itr;
    for (cut_edges_itr = undirected_cut_edges.begin(); cut_edges_itr != undirected_cut_edges.end(); cut_edges_itr++) {
        //int eid_in_orig_graph = residual_graph->get_other_value4_in_edge(*cut_edges_itr);
        int eid_in_orig_graph = *cut_edges_itr;

        if (!original_graph->edge_has_subtype(eid_in_orig_graph, "dummy_d_to_u")) {//if (eid_in_orig_graph != -1) {
            //also check the edge's src is in actual source side
            EdgeNew * chosen_edge = original_graph->get_edge_from_eid(eid_in_orig_graph);

            // if(src_side_nodes[GET_NODE_SEQ_NUM(original_graph, chosen_edge->get_source())]==1)

            cut_edges.insert(eid_in_orig_graph);
        }
    }
    return cut_edges;

}

int GraphManagerNew::mincut_Dinics(GraphNew * original_graph, int i, int j, int N, set<int>& cut_edges, set<int>& set_s) {// N is the number of nodes, i is the curr node SEQ, j is the parent node SEQ.
    static GraphNew * residual_graph;
    static int num_of_nodes, new_gid, itr_no;
    static map<int, int> map_nseq_to_res_graph_nid;
    static map<string, long int> map_src_tgt_to_eid;
    static vector < vector<bool >> edge_exist(N + 1, vector<bool>(N + 1));
    vector<int> dist(N + 1), q(N + 1), work(N + 1);
    vector<bool> is_outgoing_edges_explored(N + 1);
    int result = 0;

    itr_no++; //node 0 has no out-list in original graph. due to mismatch in the original graph, we need to take this.
    //create the gra[h at the first iteration
    if (itr_no == 1) {
        residual_graph = new GraphNew;
        num_of_nodes = N;
        new_gid = ++GraphManagerNew::graph_id_count;
        residual_graph->set_graph_id(new_gid);
        add_graph(new_gid, residual_graph);
        
        // populate adjacency matrix
        //fill_adj_matrix_for_graph(residual_graph);
    }

    int src = GET_NODE_ID(original_graph, i);
    int sink = GET_NODE_ID(original_graph, j);

    cout << i << "---" << j << endl;
    //create node i and j
    int new_nid = create_node(itr_no, i, residual_graph, map_nseq_to_res_graph_nid, N, original_graph->get_outlist(i).size());
    create_node(itr_no, j, residual_graph, map_nseq_to_res_graph_nid, 0, 0);

    //find the min-cut
    while (Dinics_BFS(original_graph, residual_graph, is_outgoing_edges_explored, map_nseq_to_res_graph_nid, map_src_tgt_to_eid, edge_exist, dist, q, src, sink, itr_no)) {
        fill(work.begin(), work.end(), -1);
        while (int delta = Dinics_DFS(original_graph, residual_graph, is_outgoing_edges_explored, map_nseq_to_res_graph_nid, map_src_tgt_to_eid, edge_exist, dist, work, i, j, INT_MAX, itr_no))
            result += delta;
    }



    set_s.insert(i);
    get_min_cut_edges(original_graph, residual_graph, map_nseq_to_res_graph_nid, i, j, cut_edges, set_s, map_src_tgt_to_eid);
    //cout<<endl<<cnt<<endl;

    return result;

}

int GraphManagerNew::compute_gh_tree_dinics(int gid, vector<int>& node_ids, vector<int>& gomoryhu_parents, vector<set<int> >& cut_edges, vector<set<int> >& fwd_cut_edges, vector<set<int> >& bkd_cut_edges) {
    GraphNew* graph = get_graph(gid);
    if (graph == NULL) {
        cerr << "Error: there is no graph for id " << gid << endl;
    }

    // Gusfield algorithm for computing gh tree
    int n = gomoryhu_parents.size();
    for (int i = 1; i < n; i++) {// try to make i=1

        set<int> set_nd_seq_nums_gt_i_with_same_parent_as_i_on_i_side_of_cut;
        set<int> set_edge_ids;
        set<int> set_fwd_edge_ids;
        set<int> set_bkd_edge_ids;
        set<int>::iterator set_itr;
        cout<<i<<"---"<<gomoryhu_parents[i]<<endl;
        //mincut_Dinics(graph, i, gomoryhu_parents[i], graph->get_node_ids().size(), set_edge_ids, set_nd_seq_nums_gt_i_with_same_parent_as_i_on_i_side_of_cut);
        mincut_ford(graph, i, gomoryhu_parents[i], graph->get_node_ids().size(), set_edge_ids, set_nd_seq_nums_gt_i_with_same_parent_as_i_on_i_side_of_cut);
        //mincut_ford_cbp(graph, i, gomoryhu_parents[i], node_ids, set_edge_ids, set_nd_seq_nums_gt_i_with_same_parent_as_i_on_i_side_of_cut);
        //mincut_excess_scaling(graph, i, gomoryhu_parents[i], graph->get_node_ids().size(), set_edge_ids, set_nd_seq_nums_gt_i_with_same_parent_as_i_on_i_side_of_cut, 1);
        //cout<<set_edge_ids.size()<<endl;
        cut_edges[i] = set_edge_ids; // set_edge_ids represent cut edges between i and gomoryhu_parents[i]
        fwd_cut_edges[i] = set_fwd_edge_ids;
        bkd_cut_edges[i] = set_bkd_edge_ids;


        bool pt_is_in_X_side = false;
        for (set_itr = set_nd_seq_nums_gt_i_with_same_parent_as_i_on_i_side_of_cut.begin(); set_itr != set_nd_seq_nums_gt_i_with_same_parent_as_i_on_i_side_of_cut.end(); set_itr++) {

            if (i != *set_itr && gomoryhu_parents[*set_itr] == gomoryhu_parents[i])
                gomoryhu_parents[*set_itr] = i;
            //checking if p[t] is in X
            if (gomoryhu_parents[gomoryhu_parents[i]] == *set_itr)
                pt_is_in_X_side = true;

        }

        if (pt_is_in_X_side) {
            int t = gomoryhu_parents[i];
            gomoryhu_parents[i] = gomoryhu_parents[t];
            gomoryhu_parents[t] = i;
            cut_edges[i] = cut_edges[t];
            cut_edges[t] = set_edge_ids;
            fwd_cut_edges[i] = fwd_cut_edges[t];
        }
    }

    // -- creating graph for Gomory-Hu tree -- starts here

    map<int, int> map_nseq_to_ghtree_nid;

    // create new graph for gh tree
    int new_gid = -1;
    GraphNew * ghtree = new GraphNew;
    new_gid = ++GraphManagerNew::graph_id_count;
    ghtree->set_graph_id(new_gid);
    add_graph(new_gid, ghtree);


    // populate adjacency matrix
    //fill_adj_matrix_for_graph(ghtree);
    
    // duplicate 0th node
    int new_nid = duplicate_node(ghtree, graph, GET_NODE_ID(graph, 0), true);
    map_nseq_to_ghtree_nid.insert(pair<int, int>(0, new_nid));


    for (int i = 1; i < n; i++) {
#ifdef ONLY_INTERAC_EDGES_FOR_MINCUT                            
        assert(!graph->is_isolated_node(GET_NODE_ID(graph, i)));

#endif
        // duplicate node
        int temp_i = GET_NODE_ID(graph, i);
        new_nid = duplicate_node(ghtree, graph, GET_NODE_ID(graph, i), true);
        map_nseq_to_ghtree_nid.insert(pair<int, int>(i, new_nid));

        // -- added on 5 Aug 2016
        // duplicate parent node if not already created
        int new_parent_nid = duplicate_node(ghtree, graph, GET_NODE_ID(graph, gomoryhu_parents[i]), true);
        map_nseq_to_ghtree_nid.insert(pair<int, int>(gomoryhu_parents[i], new_parent_nid));
        // --

        int node_i = map_nseq_to_ghtree_nid[i];
        int node_parent_i = map_nseq_to_ghtree_nid[gomoryhu_parents[i]];

        // create edge
        int new_eid = ghtree->create_new_edge();
        ghtree->add_edge_id(new_eid);
        add_edge_id_graph_id(new_eid, ghtree->get_graph_id());
        ghtree->add_source_node(new_eid, node_i);
        ghtree->add_target_node(new_eid, node_parent_i);
        ghtree->add_edge_to_outlist_of_node(node_i, new_eid);
        ghtree->add_edge_to_inlist_of_node(node_parent_i, new_eid);
        ghtree->add_edge_type(new_eid, "gh_edge");
        ghtree->add_subtype_for_edge(new_eid, "gh_edge");
        for (set<int>::iterator itr = cut_edges[i].begin(); itr != cut_edges[i].end(); itr++) {
            if ((!graph->edge_has_subtype(*itr, "dummy_u_to_d")) && (!graph->edge_has_subtype(*itr, "dummy_d_to_u"))) {
                //string edge_src_name = graph->get_all_display_ids_of_node(graph->get_source_node(*itr))[0];
                //string edge_tgt_name = graph->get_all_display_ids_of_node(graph->get_target_node(*itr))[0];
                string edge_src_name = graph->get_rep_id_from_nid(graph->get_source_node(*itr));
                string edge_tgt_name = graph->get_rep_id_from_nid(graph->get_target_node(*itr));
                string gh_edge = edge_src_name + "--" + edge_tgt_name;
                ghtree->add_pathway_for_edge(new_eid, gh_edge);
            }
        }
    }

    // -- creating graph for Gomory-Hu tree -- ends here 
    return new_gid;
}

void GraphManagerNew::generate_connectivity_constraints(int graph_gid, int ugraph_gid, vector<set<int> >& cut_edges, vector<int>& gomoryhu_parents, vector<pair<int, int> >& connect_pairs, vector<pair<int, int> >& disconnect_pairs, set<int>& up_reg_nids, set<int>& down_reg_nids, set<int>& essential_nids, set<int>& nids_as_source, set<int>& nids_as_target) {

    set<string> all_vars;
    set<string> all_int_vars;

    ofstream fout1("file1");
    ofstream fout2("file2");
    ofstream fout3("file3");
    ofstream fout4("file4");
    ofstream fout5("file5");
    ofstream decl_fout("decl_file");
    ofstream data_fout("data_file");
    ofstream assert_fout("assert_file");

    GraphNew * graph = get_graph(graph_gid);
    if (graph == NULL) {
        cerr << "No graph for graph id " << graph_gid << endl;
        return;
    }

    GraphNew * ugraph = get_graph(ugraph_gid);
    if (ugraph == NULL) {
        cerr << "No graph for graph id " << ugraph_gid << endl;
        return;
    }


    set<int> eids_to_consider;
    set<int> nids_to_consider;

    list<pair<int, int> > connect_pairs_to_consider;

    for (auto iter = connect_pairs.begin(); iter != connect_pairs.end(); iter++)
        connect_pairs_to_consider.push_back(*iter);
    for (auto iter = disconnect_pairs.begin(); iter != disconnect_pairs.end(); iter++)
        connect_pairs_to_consider.push_back(*iter);


    while (1) {
        cout << nids_to_consider.size() << " " << eids_to_consider.size() << " " << connect_pairs_to_consider.size() << " " << endl;
        get_connection_constraints(graph, ugraph, cut_edges, gomoryhu_parents, connect_pairs_to_consider, eids_to_consider, all_vars, fout1, fout2);
        cout << "Written connection constraints" << endl;
        cout << nids_to_consider.size() << " " << eids_to_consider.size() << " " << connect_pairs_to_consider.size() << " " << endl;
        get_node_positive_distance_constraints(graph, nids_to_consider, nids_as_source, all_vars, all_int_vars, fout5);
        //get_connection_implies_end_nodes_constraints(graph, connect_pairs_to_consider_copy, nids_to_consider, all_vars, fout2);
        cout << "Written connection implies end nodes constraints" << endl;
        cout << nids_to_consider.size() << " " << eids_to_consider.size() << " " << connect_pairs_to_consider.size() << " " << endl;
        get_node_implies_inedge_outedge_constraints(graph, nids_to_consider, eids_to_consider, nids_as_source, nids_as_target, all_vars, fout3);
        cout << "Written node implies inedge outedge constraints" << endl;
        cout << nids_to_consider.size() << " " << eids_to_consider.size() << " " << connect_pairs_to_consider.size() << " " << endl;
        get_edge_implies_connection_constraints(graph, eids_to_consider, connect_pairs_to_consider, all_vars, fout4, all_int_vars, fout5);
        cout << "Written edge implies connection constraints" << endl;
        cout << nids_to_consider.size() << " " << eids_to_consider.size() << " " << connect_pairs_to_consider.size() << " " << endl;
        //get_node_ordering_constraints(graph, nids_as_source, all_vars, all_int_vars, fout5);
        cout << "Written node ordering constraints" << endl;
        //get_node_positive_distance_constraints(graph, nids_to_consider, nids_as_source, all_vars, all_int_vars, fout5);
        //connect_pairs_to_consider_copy = connect_pairs_to_consider;
        cout << nids_to_consider.size() << " " << eids_to_consider.size() << " " << connect_pairs_to_consider.size() << " " << endl;
        if (eids_to_consider.empty() && nids_to_consider.empty() && connect_pairs_to_consider.empty())
            break;
    }

    write_data_assertions(up_reg_nids, down_reg_nids, all_vars, data_fout);
    cout << "Written data assertions" << endl;

    write_var_declarations(all_vars, all_int_vars, up_reg_nids, down_reg_nids, decl_fout);
    cout << "Written variable declarations" << endl;

    write_query_assertions(connect_pairs, disconnect_pairs, essential_nids, assert_fout);
    cout << "Written query assertions" << endl;

    string concat_cmd = "cat decl_file newline file1 newline file2 newline file3 newline file4 newline file5 newline data_file newline assert_file > path.smt2";
    //string concat_cmd = "cat " + decl_file + " " + file1 + " " + file2 + " " + file3 + " " + file4 + " " + file5 + " " + data_file + " " + assert_file + " > path.smt2";
    system(concat_cmd.c_str());
    string run_z3_cmd = "z3 -smt2 path.smt2 > out";
    system(run_z3_cmd.c_str());
}

void GraphManagerNew::get_connection_constraints(GraphNew * graph, GraphNew * ugraph, vector<set<int> >& cut_edges, vector<int>& gomoryhu_parents, list<pair<int, int> >& connect_pairs_to_consider, set<int>& eids_to_consider, set<string>& all_vars, ofstream& smt, ofstream& smt1) {

    static set<string> written_pairs;

    while (!connect_pairs_to_consider.empty()) {
        pair<int, int> curr_pair = connect_pairs_to_consider.front();
        int source_nid = curr_pair.first;
        int target_nid = curr_pair.second;
        string src_node_var = "__node_" + IntToString(source_nid);
        string tgt_node_var = "__node_" + IntToString(target_nid);
        string connect_var = "__connect_" + IntToString(source_nid) + "_" + IntToString(target_nid);
        //smt1 << "(assert (=> " << connect_var << " (and " << src_node_var << " " << tgt_node_var << ")))" << endl;
        all_vars.insert(connect_var);
        all_vars.insert(src_node_var);
        all_vars.insert(tgt_node_var);
        connect_pairs_to_consider.pop_front();
        if (written_pairs.find(connect_var) == written_pairs.end()) {
            written_pairs.insert(connect_var);

            int node_u_in_tree, is_src_side;
            ofstream outfile;
            outfile.open("all_mincuts");

            int src_nid_in_ugraph = ugraph->get_nid_from_rep_id(graph->get_rep_id_from_nid(source_nid));
            int tgt_nid_in_ugraph = ugraph->get_nid_from_rep_id(graph->get_rep_id_from_nid(target_nid));
            set<int> mincut_eids = getMinCutEdges(ugraph, cut_edges, gomoryhu_parents, GET_NODE_SEQ_NUM(ugraph, src_nid_in_ugraph), GET_NODE_SEQ_NUM(ugraph, tgt_nid_in_ugraph), node_u_in_tree, is_src_side, outfile);

            //set<int> directed_cut_eids = getFilteredCutEdges(ugraph, mincut_eids, src_nid_in_ugraph, tgt_nid_in_ugraph);
            set<int> directed_cut_eids;
            get_directed_cut(ugraph, src_nid_in_ugraph, tgt_nid_in_ugraph, mincut_eids, directed_cut_eids);

            if (directed_cut_eids.empty()) {
                //cout << "Mincut between " << graph->get_rep_id_from_nid(source_nid) << " and " << graph->get_rep_id_from_nid(target_nid) << " empty" << endl;
                continue;
            }


            if (directed_cut_eids.size() == 1) {
                int curr_edge = ugraph->get_other_value1_in_edge(*directed_cut_eids.begin());
                eids_to_consider.insert(curr_edge);
                string edge_var = "__edge_" + IntToString(curr_edge);
                all_vars.insert(edge_var);


                smt << "(assert (= " << connect_var << " ";
                if ((graph->get_source_node(curr_edge) == source_nid) && (graph->get_target_node(curr_edge) == target_nid)) {
                    smt << " " << edge_var << " ";
                    //connect_pairs_to_consider.push_back(pair<int,int>(source_nid, target_nid));
                } else {
                    smt << "(and " << edge_var << " ";
                    if (graph->get_source_node(curr_edge) != source_nid) {
                        string new_connect_var = "__connect_" + IntToString(source_nid) + "_" + IntToString(graph->get_source_node(curr_edge));
                        string src_node_var = "__node_" + IntToString(source_nid);
                        string tgt_node_var = "__node_" + IntToString(graph->get_source_node(curr_edge));
                        smt1 << "(assert (=> " << new_connect_var << " (and " << src_node_var << " " << tgt_node_var << ")))" << endl;
                        all_vars.insert(new_connect_var);
                        all_vars.insert(src_node_var);
                        all_vars.insert(tgt_node_var);
                        smt << " " << new_connect_var << " ";
                        connect_pairs_to_consider.push_back(pair<int, int>(source_nid, graph->get_source_node(curr_edge)));
                        //connect_pairs_to_consider_copy.push_back(pair<int,int>(source_nid,graph->get_source_node(curr_edge)));
                    }
                    if (graph->get_target_node(curr_edge) != target_nid) {
                        string new_connect_var = "__connect_" + IntToString(graph->get_target_node(curr_edge)) + "_" + IntToString(target_nid);
                        string src_node_var = "__node_" + IntToString(graph->get_target_node(curr_edge));
                        string tgt_node_var = "__node_" + IntToString(target_nid);
                        smt1 << "(assert (=> " << new_connect_var << " (and " << src_node_var << " " << tgt_node_var << ")))" << endl;
                        all_vars.insert(new_connect_var);
                        all_vars.insert(src_node_var);
                        all_vars.insert(tgt_node_var);
                        smt << " " << new_connect_var << " ";
                        connect_pairs_to_consider.push_back(pair<int, int>(graph->get_target_node(curr_edge), target_nid));
                        //connect_pairs_to_consider_copy.push_back(pair<int,int>(graph->get_target_node(curr_edge), target_nid));
                    }

                    smt << ")";
                }

                smt << "))" << endl;
            }
            else {
                smt << "(assert (= " << connect_var << " (or";
                for (auto mincut_iter = directed_cut_eids.begin(); mincut_iter != directed_cut_eids.end(); mincut_iter++) {
                    int curr_edge = ugraph->get_other_value1_in_edge(*mincut_iter);
                    eids_to_consider.insert(curr_edge);
                    string edge_var = "__edge_" + IntToString(curr_edge);
                    all_vars.insert(edge_var);

                    if ((graph->get_source_node(curr_edge) == source_nid) && (graph->get_target_node(curr_edge) == target_nid)) {
                        smt << " " << edge_var << " ";
                        //connect_pairs_to_consider.push_back(pair<int,int>(source_nid, target_nid));
                    } else {
                        smt << " (and " << edge_var << " ";
                        if (graph->get_source_node(curr_edge) != source_nid) {
                            string new_connect_var = "__connect_" + IntToString(source_nid) + "_" + IntToString(graph->get_source_node(curr_edge));
                            string src_node_var = "__node_" + IntToString(source_nid);
                            string tgt_node_var = "__node_" + IntToString(graph->get_source_node(curr_edge));
                            smt1 << "(assert (=> " << new_connect_var << " (and " << src_node_var << " " << tgt_node_var << ")))" << endl;
                            all_vars.insert(new_connect_var);
                            all_vars.insert(src_node_var);
                            all_vars.insert(tgt_node_var);
                            smt << " " << new_connect_var << " ";
                            connect_pairs_to_consider.push_back(pair<int, int>(source_nid, graph->get_source_node(curr_edge)));
                            //connect_pairs_to_consider_copy.push_back(pair<int,int>(source_nid,graph->get_source_node(curr_edge)));
                        }
                        if (graph->get_target_node(curr_edge) != target_nid) {
                            string new_connect_var = "__connect_" + IntToString(graph->get_target_node(curr_edge)) + "_" + IntToString(target_nid);
                            string src_node_var = "__node_" + IntToString(graph->get_target_node(curr_edge));
                            string tgt_node_var = "__node_" + IntToString(target_nid);
                            smt1 << "(assert (=> " << new_connect_var << " (and " << src_node_var << " " << tgt_node_var << ")))" << endl;
                            all_vars.insert(new_connect_var);
                            all_vars.insert(src_node_var);
                            all_vars.insert(tgt_node_var);
                            smt << " " << new_connect_var << " ";
                            connect_pairs_to_consider.push_back(pair<int, int>(graph->get_target_node(curr_edge), target_nid));
                            //connect_pairs_to_consider_copy.push_back(pair<int,int>(graph->get_target_node(curr_edge), target_nid));
                        }

                        smt << ")";
                    }
                }
                smt << ")))" << endl;
            }
        }
    }

}


//void GraphManagerNew::get_connection_implies_end_nodes_constraints(GraphNew * graph, list<pair<int, int> >& connect_pairs_to_consider, set<int>& nids_to_consider, set<string>& all_vars, ofstream& smt) {
//    
//    static set<string> written_pairs;
//    
//    while (!connect_pairs_to_consider.empty()) {
//        pair<int, int> curr_pair = connect_pairs_to_consider.front();
//        int source_nid = curr_pair.first;
//        int target_nid = curr_pair.second;
//        string connect_var = "__connect_" + IntToString(source_nid) + "_" + IntToString(target_nid);
//        all_vars.insert(connect_var);
//        connect_pairs_to_consider.pop_front();
//        
//        if (written_pairs.find(connect_var) == written_pairs.end()) {
//            written_pairs.insert(connect_var);
//            string src_node_var = "__node_" + IntToString(source_nid);
//            string tgt_node_var = "__node_" + IntToString(target_nid);
//            all_vars.insert(src_node_var);
//            all_vars.insert(tgt_node_var);
//            smt << "(assert (=> " << connect_var << " (and " << src_node_var << " " << tgt_node_var << ")))" << endl;
//            
//            nids_to_consider.insert(source_nid);
//            nids_to_consider.insert(target_nid);
//        }
//                    
//    }
//    
//        
//}

void GraphManagerNew::get_node_implies_inedge_outedge_constraints(GraphNew * graph, set<int>& nids_to_consider, set<int>& eids_to_consider, set<int>& nids_as_source, set<int>& nids_as_target, set<string>& all_vars, ofstream& smt) {

    static set<int> written_as_source;
    static set<int> written_as_target;
    static set<int> written_nids;

    //source nodes - only out edge
    for (auto nids_iter = nids_as_source.begin(); nids_iter != nids_as_source.end(); nids_iter++) {
        int curr_nid = *nids_iter;
        if (nids_as_target.find(curr_nid) != nids_as_target.end())
            continue;
        if (written_as_source.find(curr_nid) != written_as_source.end())
            continue;
        written_as_source.insert(curr_nid);
        string node_var = "__node_" + IntToString(curr_nid);
        all_vars.insert(node_var);
        vector<int> outlist = graph->get_outlist(curr_nid);

        if (outlist.empty())
            continue;
        smt << "(assert (=> " << node_var << " ";
        if (outlist.size() == 1) {
            string edge_var = "__edge_" + IntToString(*outlist.begin());
            eids_to_consider.insert(*outlist.begin());
            smt << edge_var;
            all_vars.insert(edge_var);
        } else {
            smt << " (or";
            for (auto out_iter = outlist.begin(); out_iter != outlist.end(); out_iter++) {
                int curr_edge = *out_iter;
                string edge_var = "__edge_" + IntToString(curr_edge);
                eids_to_consider.insert(curr_edge);
                all_vars.insert(edge_var);
                smt << " " << edge_var;
            }
            smt << ")";
        }

        smt << "))" << endl;
    }


    //target nodes - only in edge
    for (auto nids_iter = nids_as_target.begin(); nids_iter != nids_as_target.end(); nids_iter++) {
        int curr_nid = *nids_iter;
        if (nids_as_source.find(curr_nid) != nids_as_source.end())
            continue;
        if (written_as_target.find(curr_nid) != written_as_target.end())
            continue;
        written_as_target.insert(curr_nid);
        string node_var = "__node_" + IntToString(curr_nid);
        all_vars.insert(node_var);
        vector<int> inlist = graph->get_inlist(curr_nid);

        if (inlist.empty())
            continue;
        smt << "(assert (=> " << node_var << " ";
        if (inlist.size() == 1) {
            string edge_var = "__edge_" + IntToString(*inlist.begin());
            eids_to_consider.insert(*inlist.begin());
            smt << edge_var;
            all_vars.insert(edge_var);
        } else {
            smt << " (or";
            for (auto in_iter = inlist.begin(); in_iter != inlist.end(); in_iter++) {
                int curr_edge = *in_iter;
                string edge_var = "__edge_" + IntToString(curr_edge);
                eids_to_consider.insert(curr_edge);
                all_vars.insert(edge_var);
                smt << " " << edge_var;
            }
            smt << ")";
        }

        smt << "))" << endl;
    }


    //nids_to_consider - both out and in edges
    for (auto nids_iter = nids_to_consider.begin(); nids_iter != nids_to_consider.end(); nids_iter++) {
        int curr_nid = *nids_iter;
        if (written_nids.find(curr_nid) != written_nids.end())
            continue;
        //if (written_as_source.find(curr_nid) != written_as_source.end())
        //   continue;
        //if (written_as_target.find(curr_nid) != written_as_target.end())
        //    continue;
        written_nids.insert(curr_nid);
        vector<int> inlist = graph->get_inlist(curr_nid);
        vector<int> outlist = graph->get_outlist(curr_nid);

        if (inlist.empty() && outlist.empty())
            continue;

        string node_var = "__node_" + IntToString(curr_nid);
        all_vars.insert(node_var);

        smt << "(assert (=> " << node_var << " ";
        if (!inlist.empty() && !outlist.empty())
            smt << "(and ";
        //smt << "(or ";

        // inlist
        if (inlist.size() == 1) {
            string edge_var = "__edge_" + IntToString(*inlist.begin());
            eids_to_consider.insert(*inlist.begin());
            smt << " " << edge_var;
            all_vars.insert(edge_var);
        } else if (!inlist.empty()) {
            smt << " (or";
            for (auto in_iter = inlist.begin(); in_iter != inlist.end(); in_iter++) {
                int curr_edge = *in_iter;
                string edge_var = "__edge_" + IntToString(curr_edge);
                eids_to_consider.insert(curr_edge);
                all_vars.insert(edge_var);
                smt << " " << edge_var;
            }
            smt << ")";
        }

        // outlist
        if (outlist.size() == 1) {
            string edge_var = "__edge_" + IntToString(*outlist.begin());
            eids_to_consider.insert(*outlist.begin());
            smt << " " << edge_var;
            all_vars.insert(edge_var);
        } else if (!outlist.empty()) {
            smt << " (or";
            for (auto out_iter = outlist.begin(); out_iter != outlist.end(); out_iter++) {
                int curr_edge = *out_iter;
                string edge_var = "__edge_" + IntToString(curr_edge);
                eids_to_consider.insert(curr_edge);
                all_vars.insert(edge_var);
                smt << " " << edge_var;
            }
            smt << ")";
        }


        if (!inlist.empty() && !outlist.empty())
            smt << ")";
        smt << "))" << endl;

    }
    nids_to_consider.clear();

}

void GraphManagerNew::get_edge_implies_connection_constraints(GraphNew * graph, set<int>& eids_to_consider, list<pair<int, int> >& connect_pairs_to_consider, set<string>& all_vars, ofstream& smt, set<string>& all_int_vars, ofstream& order) {
    static set<int> written_edges;

    for (auto eids_iter = eids_to_consider.begin(); eids_iter != eids_to_consider.end(); eids_iter++) {
        int curr_eid = *eids_iter;
        int src_nid = graph->get_source_node(curr_eid);
        int tgt_nid = graph->get_target_node(curr_eid);

        if (written_edges.find(curr_eid) == written_edges.end()) {
            written_edges.insert(curr_eid);

            string edge_var = "__edge_" + IntToString(curr_eid);
            all_vars.insert(edge_var);
            string connect_var = "__connect_" + IntToString(src_nid) + "_" + IntToString(tgt_nid);
            all_vars.insert(connect_var);
            connect_pairs_to_consider.push_back(pair<int, int>(src_nid, tgt_nid));

            smt << "(assert (=> " << edge_var << " " << connect_var << "))" << endl;

            // for ordering
            string src_distance_var = "__nodedistance_" + IntToString(graph->get_source_node(curr_eid));
            string tgt_distance_var = "__nodedistance_" + IntToString(graph->get_target_node(curr_eid));
            order << "(assert (= " << tgt_distance_var << "(get-max " << tgt_distance_var << " (+ " << src_distance_var << " 1)" << ")))" << endl;
            //order << "(assert-soft (= " << tgt_distance_var << " (+ " << src_distance_var << " 1)" << "))" << endl;
            //order << "(assert-soft (< " << tgt_distance_var << " 10))" << endl;
            all_int_vars.insert(src_distance_var);
            all_int_vars.insert(tgt_distance_var);
        }
    }
    eids_to_consider.clear();

}

// not called

void GraphManagerNew::get_node_ordering_constraints(GraphNew * graph, set<int>& nids_as_source, set<string>& all_vars, set<string>& all_int_vars, ofstream& smt) {
    static set<int> written_nodes;

    for (auto nids_iter = nids_as_source.begin(); nids_iter != nids_as_source.end(); nids_iter++) {
        int curr_nid = *nids_iter;

        if (written_nodes.find(curr_nid) == written_nodes.end()) {
            written_nodes.insert(curr_nid);

            string node_distance_var = "__nodedistance_" + IntToString(curr_nid);
            smt << "(assert (= " << node_distance_var << " 0))" << endl;
            all_int_vars.insert(node_distance_var);
        }
    }
}

void GraphManagerNew::get_node_positive_distance_constraints(GraphNew * graph, set<int>& nids_to_consider, set<int>& nids_as_source, set<string>& all_vars, set<string>& all_int_vars, ofstream& smt) {
    static set<int> written_nodes;

    for (auto nids_iter = nids_to_consider.begin(); nids_iter != nids_to_consider.end(); nids_iter++) {
        int curr_nid = *nids_iter;
        string node_distance_var = "__nodedistance_" + IntToString(curr_nid);

        if (written_nodes.find(curr_nid) == written_nodes.end()) {
            written_nodes.insert(curr_nid);

            if (nids_as_source.find(curr_nid) != nids_as_source.end())
                smt << "(assert-soft (= " << node_distance_var << " 0))" << endl;
            else
                smt << "(assert (> " << node_distance_var << " 0))" << endl;
            all_int_vars.insert(node_distance_var);
        }
    }
}

void GraphManagerNew::write_var_declarations(set<string>& all_vars, set<string>& all_int_vars, set<int>& up_reg_nids, set<int>& down_reg_nids, ofstream& decl_fout) {
    decl_fout << "(set-option :produce-unsat-cores true)" << endl;
    decl_fout << endl;
    for (auto iter = all_vars.begin(); iter != all_vars.end(); iter++) {
        string curr_var = *iter;
        decl_fout << "(declare-const " << curr_var << " Bool)" << endl;
    }
    for (auto iter = all_int_vars.begin(); iter != all_int_vars.end(); iter++) {
        string curr_var = *iter;
        decl_fout << "(declare-const " << curr_var << " Int)" << endl;
    }

    decl_fout << endl;
    decl_fout << "(define-fun get-max ((x Int) (y Int)) Int" << endl;
    decl_fout << "\t(ite (< x y) y x))" << endl;

}

void GraphManagerNew::write_data_assertions(set<int>& up_reg_nids, set<int>& down_reg_nids, set<string>& all_vars, ofstream& data_fout) {
    string node_var;
    for (auto iter = up_reg_nids.begin(); iter != up_reg_nids.end(); iter++) {
        data_fout << "(assert-soft " << "__node_" << *iter << ")" << endl; // "\t:id data\t:weight 1)" << endl;
        node_var = "__node_" + IntToString(*iter);
        all_vars.insert(node_var);
    }
    for (auto iter = down_reg_nids.begin(); iter != down_reg_nids.end(); iter++) {
        data_fout << "(assert-soft " << "__node_" << *iter << ")" << endl; // "\t:id data\t:weight 1)" << endl;
        node_var = "__node_" + IntToString(*iter);
        all_vars.insert(node_var);
    }

}

void GraphManagerNew::write_query_assertions(vector<pair<int, int> >& connect_pairs, vector<pair<int, int> >& disconnect_pairs, set<int>& essential_nids, ofstream& assert_fout) {
    int counter = 1;
    for (auto iter = connect_pairs.begin(); iter != connect_pairs.end(); iter++) {
        string connect_var = "__connect_" + IntToString((*iter).first) + "_" + IntToString((*iter).second);
        string assert_name = "a" + IntToString(counter);
        assert_fout << "(assert (! " << connect_var << "\t:named " << assert_name << "))" << endl;
        counter++;
    }
    for (auto iter = disconnect_pairs.begin(); iter != disconnect_pairs.end(); iter++) {
        string connect_var = "__connect_" + IntToString((*iter).first) + "_" + IntToString((*iter).second);
        string assert_name = "a" + IntToString(counter);
        assert_fout << "(assert (! (not " << connect_var << ")\t:named " << assert_name << "))" << endl;
        counter++;
    }
    for (auto iter = essential_nids.begin(); iter != essential_nids.end(); iter++) {
        string assert_name = "a" + IntToString(counter);
        assert_fout << "(assert (! " << "__node_" << *iter << "\t:named " << assert_name << "))" << endl;
        counter++;
    }

    assert_fout << endl;
    assert_fout << "(check-sat)" << endl;
    assert_fout << "(get-model)" << endl;
    assert_fout << "(get-unsat-core)" << endl;
    assert_fout << endl;
}

void GraphManagerNew::get_connectivity(int graph_gid, int ugraph_gid, vector< vector< bool > >& closure_matrix, vector< vector<int> >& call_level_matrix, vector< vector<int> >& edge_level_matrix, vector< vector<int> >& call_count_matrix, vector< vector<int> >& edge_count_matrix, vector<set<int> >& cut_edges, vector<int>& gomoryhu_parents, vector<pair<int, int> >& connect_pairs, vector<pair<int, int> >& disconnect_pairs, set<int>& up_reg_nids, set<int>& down_reg_nids, set<int>& essential_nids, set<int>& avoid_nids, set<int>& nids_as_source, set<int>& nids_as_target, int path_length_bound, string fold_change_filename, string file_prefix, t_ExpressionManager * em) {

    GraphNew * graph = get_graph(graph_gid);
    if (graph == NULL) {
        cerr << "No graph for graph id " << graph_gid << endl;
        return;
    }

    GraphNew * ugraph = get_graph(ugraph_gid);
    if (ugraph == NULL) {
        cerr << "No graph for graph id " << ugraph_gid << endl;
        return;
    }

    generate_connectivity_constraints(graph, ugraph, closure_matrix, call_level_matrix, edge_level_matrix, call_count_matrix, edge_count_matrix, cut_edges, gomoryhu_parents, connect_pairs, disconnect_pairs, up_reg_nids, down_reg_nids, essential_nids, avoid_nids, nids_as_source, nids_as_target, path_length_bound, fold_change_filename, file_prefix, em);


}

void GraphManagerNew::generate_connectivity_constraints(GraphNew * graph, GraphNew * ugraph, vector< vector< bool > >& closure_matrix, vector< vector<int> >& call_level_matrix, vector< vector<int> >& edge_level_matrix, vector< vector<int> >& call_count_matrix, vector< vector<int> >& edge_count_matrix, vector<set<int> >& cut_edges, vector<int>& gomoryhu_parents, vector<pair<int, int> >& connect_pairs, vector<pair<int, int> >& disconnect_pairs, set<int>& up_reg_nids, set<int>& down_reg_nids, set<int>& essential_nids, set<int>& avoid_nids, set<int>& nids_as_source, set<int>& nids_as_target, int path_length_bound, string fold_change_filename, string file_prefix, t_ExpressionManager * em) {
    string all_pair_file_name = file_prefix + "_mincuts";
    ofstream hout(all_pair_file_name.c_str());

    map<string, int> nodes_in_all_mincuts;
    
    
    hout << "<!DOCTYPE html>" << endl;
    hout << "<html>" << endl;
    hout << "<head>" << endl;
    hout << "<title>All pair min cuts</title>" << endl;
    hout << "</head>" << endl;
    hout << "<body style=\"background-color:#FFFFF0;\">" << endl;

    hout << "<h2 style=\"color:red;text-align:center;font-family:courier;\">Min cuts</h2>" << endl;

    hout << "\n\n" << endl;
    

    vector<t_Expression *> all_expressions_vec;

    set<int> all_nids_in_constraints;
    set<int> all_eids_in_constraints;

    set<int> nids_to_consider;
    set<int> eids_to_consider;
    list<pair<int, int> > connect_pairs_to_consider;

    for (auto iter = connect_pairs.begin(); iter != connect_pairs.end(); iter++)  // current thing works only for one source-target pair
        connect_pairs_to_consider.push_back(*iter);
    
    int main_src_nid = connect_pairs_to_consider.front().first; 
    

    vector<t_Expression *> connection_constraints_vec;
    vector<t_Expression *> connection_implies_end_nodes_constraints_vec;
    vector<t_Expression *> edge_implies_connection_constraints_vec;
    vector<t_Expression *> src_dist_lt_tgt_dist_constraints_vec;
    vector<t_Expression *> node_implies_inedge_outedge_constraints_vec;
    vector<t_Expression *> targets_dist_lt_bound_constraints_vec;
    vector<t_Expression *> microarray_data_assertions_vec;
    vector<t_Expression *> query_assertions_as_constraints_vec;
    vector<t_Expression *> total_nodes_lt_bound_constraints_vec;
    vector<t_Expression *> total_edges_lt_bound_constraints_vec;
    vector<t_Expression *> node_activation_status_relaxation_constraints_vec;
    vector<t_Expression *> every_path_has_diff_exp_node_constraints_vec;
    vector<t_Expression *> edge_activation_status_relaxation_constraints_vec;
    vector<t_Expression *> all_nodes_relax_expr_vec;
    vector<t_Expression *> all_edges_relax_expr_vec;
    vector<t_Expression *> inedges_expr_edges_present_vec;
    
    get_query_assertions_as_constraints(em, query_assertions_as_constraints_vec, connect_pairs, disconnect_pairs, essential_nids, avoid_nids, nids_to_consider, all_nids_in_constraints);
    //get_microarray_data_as_constraints(em, graph, microarray_data_assertions_vec, up_reg_nids, down_reg_nids, nids_to_consider, nids_as_target, all_nids_in_constraints);

    
    
    set<string> up_reg_rep_ids, down_reg_rep_ids;
    for (auto i = up_reg_nids.begin(); i != up_reg_nids.end(); i++)
        up_reg_rep_ids.insert(graph->get_rep_id_from_nid(*i));
    for (auto i = down_reg_nids.begin(); i != down_reg_nids.end(); i++)
        down_reg_rep_ids.insert(graph->get_rep_id_from_nid(*i));
    
    
    cout << "A" << endl;

    get_connection_constraints_using_mincut(em, connection_constraints_vec, connection_implies_end_nodes_constraints_vec, graph, ugraph, closure_matrix, call_level_matrix, edge_level_matrix, call_count_matrix, edge_count_matrix, cut_edges, gomoryhu_parents, connect_pairs_to_consider, nids_to_consider, eids_to_consider, up_reg_nids, down_reg_nids, up_reg_rep_ids, down_reg_rep_ids, fold_change_filename, all_nids_in_constraints, all_eids_in_constraints, nodes_in_all_mincuts, hout);

    cout << "B" << endl;
    
    get_edge_implies_connection_constraints(em, path_length_bound, edge_implies_connection_constraints_vec, src_dist_lt_tgt_dist_constraints_vec, graph, nids_to_consider, eids_to_consider, connect_pairs_to_consider, all_nids_in_constraints);

    cout << "C" << endl;
    
    get_targets_dist_lt_bound_constraints(em, path_length_bound, targets_dist_lt_bound_constraints_vec, graph, nids_to_consider);

    cout << "D" << endl;
    
    get_node_implies_inedge_outedge_constraints(em, node_implies_inedge_outedge_constraints_vec, graph, up_reg_nids, down_reg_nids, nids_to_consider, eids_to_consider, nids_as_source, nids_as_target, all_nids_in_constraints, all_eids_in_constraints);

    cout << "E" << endl;

    t_Expression * vec1 = get_AND_expr_from_vector(em, connection_constraints_vec);
    t_Expression * vec2 = get_AND_expr_from_vector(em, connection_implies_end_nodes_constraints_vec);
    t_Expression * vec3 = get_AND_expr_from_vector(em, edge_implies_connection_constraints_vec);
    t_Expression * vec4 = get_AND_expr_from_vector(em, src_dist_lt_tgt_dist_constraints_vec);
    t_Expression * vec5 = get_AND_expr_from_vector(em, node_implies_inedge_outedge_constraints_vec);
    t_Expression * vec6 = get_AND_expr_from_vector(em, targets_dist_lt_bound_constraints_vec);
    // t_Expression * vec7 = get_AND_expr_from_vector(em, microarray_data_assertions_vec);
    t_Expression * vec8 = get_AND_expr_from_vector(em, query_assertions_as_constraints_vec);

    


    get_total_nodes_lt_bound_constraints(em, total_nodes_lt_bound_constraints_vec, graph, nids_to_consider);
    
    cout << "F" << endl;
    
    get_total_edges_lt_bound_constraints(em, total_edges_lt_bound_constraints_vec, graph, eids_to_consider);

    cout << "G" << endl;
    
    get_node_activation_status_relaxation_constraints(em, node_activation_status_relaxation_constraints_vec, all_nodes_relax_expr_vec, graph, nids_to_consider, up_reg_nids, down_reg_nids);
    
    cout << "H" << endl;
    
    get_every_path_has_diff_exp_node_constraints(em, every_path_has_diff_exp_node_constraints_vec, graph, nids_to_consider, eids_to_consider, up_reg_nids, down_reg_nids, nids_as_source, nids_as_target);
    
    cout << "I" << endl;
    
    get_edge_activation_status_relaxation_constraints(em, edge_activation_status_relaxation_constraints_vec, all_edges_relax_expr_vec, graph, eids_to_consider, up_reg_nids, down_reg_nids);
    
    cout << "J" << endl;
    
    
    t_Expression * vec9 = get_AND_expr_from_vector(em, total_nodes_lt_bound_constraints_vec);
    t_Expression * vec10 = get_AND_expr_from_vector(em, total_edges_lt_bound_constraints_vec);

    t_Expression * vec12 = get_AND_expr_from_vector(em, node_activation_status_relaxation_constraints_vec);
    t_Expression * vec13 = get_AND_expr_from_vector(em, every_path_has_diff_exp_node_constraints_vec);
    t_Expression * vec14 = get_AND_expr_from_vector(em, edge_activation_status_relaxation_constraints_vec);
    t_Expression * vec15 = get_AND_expr_from_vector(em, all_nodes_relax_expr_vec);
    t_Expression * vec16 = get_AND_expr_from_vector(em, all_edges_relax_expr_vec);
    
    
    
    cout << "K" << endl;
    
    if (vec1 != NULL)
        all_expressions_vec.push_back(vec1);
    if (vec2 != NULL)
        all_expressions_vec.push_back(vec2);
    if (vec3 != NULL)
        all_expressions_vec.push_back(vec3);
    if (vec4 != NULL)
        all_expressions_vec.push_back(vec4);
    if (vec5 != NULL)
        all_expressions_vec.push_back(vec5);
    if (vec6 != NULL)
        all_expressions_vec.push_back(vec6);
    
    if (vec8 != NULL)
        all_expressions_vec.push_back(vec8);
    if (vec9 != NULL)
        all_expressions_vec.push_back(vec9);
    if (vec10 != NULL)
        all_expressions_vec.push_back(vec10);

    if (vec12 != NULL)
        all_expressions_vec.push_back(vec12);
    if (vec13 != NULL)
        all_expressions_vec.push_back(vec13);
    if (vec14 != NULL)
        all_expressions_vec.push_back(vec14);
    if (vec15 != NULL)
        all_expressions_vec.push_back(vec15);
    if (vec16 != NULL)
        all_expressions_vec.push_back(vec16);
    cout << "L" << endl;
    
//    int akt_nid = graph->get_nid_from_rep_id("hsa10000");
//    vector<int> akt_expr_inedges = graph->get_inlist(akt_nid);
//    vector<t_Expression *> expression_edges_assert_vec;
//    get_expression_edges_assertion_constraints(em, akt_expr_inedges, expression_edges_assert_vec);
//    t_Expression * vec17 = get_AND_expr_from_vector(em, all_edges_relax_expr_vec);
//    if (vec17 != NULL)
//        all_expressions_vec.push_back(vec17);
//    cout << "M" << endl;
    
    
    // Currently asserting single source node must be active
    TypeOfExpressionTuple te1 = {TYPE_BOOL, 1};
    string src_active_var = "__nodeactive_" + IntToString(main_src_nid);    
    t_Expression * src_node_active_expr = em->createSymbol(src_active_var, te1);
    all_expressions_vec.push_back(src_node_active_expr);
    
//    string akt_active_var = "__nodeactive_" + IntToString(akt_nid);
//    t_Expression * akt_node_active_expr = em->createSymbol(akt_active_var, te1);
//    t_Expression * akt_node_inactive_expr = em->createOneBitExpressionWithOneOperand(em->m_operatorLabelLogNOT, akt_node_active_expr);
//    all_expressions_vec.push_back(akt_node_inactive_expr);
    
    cout << "Size: " << all_expressions_vec.size() << endl;
    
    em->mod_printExpressionsToFileInSMT(all_expressions_vec, "\n", file_prefix);

    cout << "M" << endl;
    
//    vector<pair<int, int> > nid_to_freq_pair_vec;
//    for (auto i = nodes_in_all_mincuts.begin(); i != nodes_in_all_mincuts.end(); i++) {
//        nid_to_freq_pair_vec.push_back(pair<int, int> (graph->get_nid_from_rep_id(i->first), i->second));
//    }
//    cout << "H" << endl;
//    sort(nid_to_freq_pair_vec.begin(), nid_to_freq_pair_vec.end(), compare_pair_on_second_descending);
//    cout << "I" << endl;
//    
//    hout << "<br>" << endl;
//    hout << "<span style=\"color: #000000\"> Frequency of nodes across all mincuts:" << "</span>" << endl;
//    hout << "<br><br>" << endl;
//    
//    cout << "J" << endl;
//    
//    for (auto iter = nid_to_freq_pair_vec.begin(); iter != nid_to_freq_pair_vec.end(); iter++) {
//        string curr_rep_id = graph->get_rep_id_from_nid(iter->first);
//        if (up_reg_rep_ids.find(curr_rep_id) != up_reg_rep_ids.end())
//            hout << "<span style=\"color: #009900\">" << graph->get_all_display_ids_of_node(iter->first)[0] << "</span>";
//        else if (down_reg_rep_ids.find(curr_rep_id) != down_reg_rep_ids.end())
//            hout << "<span style=\"color: #ff0000\">" << graph->get_all_display_ids_of_node(iter->first)[0] << "</span>";
//        else
//            hout << "<span style=\"color: #000000\">" << graph->get_all_display_ids_of_node(iter->first)[0] << "\t\t" << "</span>";
//        
//        
//        
//        hout << "<span style=\"color: #9e0a0a\">" << "\t\t" << iter->second <<  "</span>" << endl;
//        hout << "<br>" << endl;
//    }
//    
//    cout << "K" << endl;
//    
//    hout << "<br>" << endl;
//    
//
//    hout << "</body>" << endl;
//    hout << "</html>" << endl;
//    hout.close();
//
//    cout << "L" << endl;
}

void GraphManagerNew::get_connection_constraints_using_mincut(t_ExpressionManager * em, vector<t_Expression *>& connection_constraints_vec, vector<t_Expression *>& connection_implies_end_nodes, GraphNew * graph, GraphNew * ugraph, vector< vector< bool > >& closure_matrix, vector< vector<int> >& call_level_matrix, vector< vector<int> >& edge_level_matrix, vector< vector<int> >& call_count_matrix, vector< vector<int> >& edge_count_matrix, vector<set<int> >& cut_edges, vector<int>& gomoryhu_parents, list<pair<int, int> >& connect_pairs_to_consider, set<int>& nids_to_consider, set<int>& eids_to_consider, set<int>& up_reg_nids, set<int>& down_reg_nids, set<string>& up_reg_rep_ids, set<string>& down_reg_rep_ids, string fold_change_filename, set<int>& all_nids_in_constraints, set<int>& all_eids_in_constraints, map<string, int>& nodes_in_all_mincuts, ofstream& hout) {

    
    TypeOfExpressionTuple te1 = {TYPE_BOOL, 1};
    static set<string> written_pairs;
    static bool already_called = false;
    
    static vector<bool> selected_mincut_vec(gomoryhu_parents.size(), false);

    pair<int, int> first_pair = connect_pairs_to_consider.front();
    int first_pair_src_nid = first_pair.first;
    int first_pair_tgt_nid = first_pair.second;
    
    int call_pair_source_nseq = GET_NODE_SEQ_NUM(graph, first_pair_src_nid);
    int call_pair_target_nseq = GET_NODE_SEQ_NUM(graph, first_pair_tgt_nid);

    //cout << "Source: " << graph->get_all_display_ids_of_node(first_pair_src_nid)[0] << " Target: " << graph->get_all_display_ids_of_node(first_pair_tgt_nid)[0] << endl;
    cout << "Source: " << kegg_hsa_id_to_display_name_map[graph->get_rep_id_from_nid(first_pair_src_nid)] << " Target: " << kegg_hsa_id_to_display_name_map[graph->get_rep_id_from_nid(first_pair_tgt_nid)] << endl;
    
    if (already_called) {
        cerr << "Multiple calls for s-t pair." << endl;
        exit(1);
    }
    else {
        already_called = true;
    }
    
    
    call_level_matrix[call_pair_source_nseq][call_pair_target_nseq] = 1;
    call_count_matrix[call_pair_source_nseq][call_pair_target_nseq] = 1;
    
//    curr_cell_entry = edge_level_matrix[call_pair_source_nseq][call_pair_target_nseq];
//    if ((curr_cell_entry == inf) && (call_pair_source_nseq != call_pair_target_nseq))
//        edge_level_matrix[call_pair_source_nseq][call_pair_target_nseq] = 1;

    
    while (!connect_pairs_to_consider.empty()) {
        
        pair<int, int> curr_pair = connect_pairs_to_consider.front();
        connect_pairs_to_consider.pop_front();
        int source_nid = curr_pair.first;
        int target_nid = curr_pair.second;
        
        call_pair_source_nseq = GET_NODE_SEQ_NUM(graph, source_nid);
        call_pair_target_nseq = GET_NODE_SEQ_NUM(graph, target_nid);

//        int curr_cell_entry = call_level_matrix[call_pair_source_nseq][call_pair_target_nseq];
//        if (curr_cell_entry == inf)
//            call_level_matrix[call_pair_source_nseq][call_pair_target_nseq] = 1;
//        cout << "Curr pair: " << curr_pair.first << " " << curr_pair.second << endl;
        
        string src_node_var = "__node_" + IntToString(source_nid);
        string tgt_node_var = "__node_" + IntToString(target_nid);
        string connect_var = "__connect_" + IntToString(source_nid) + "_" + IntToString(target_nid);

        t_Expression * connect_expr = em->createSymbol(connect_var, te1);
                

        if (written_pairs.find(connect_var) == written_pairs.end()) {
            written_pairs.insert(connect_var);
            
            if (source_nid == target_nid) {
                    
                string true_var = "__true_";
                t_Expression * true_expr = em->createSymbol(true_var, te1);
                em->isAConstantOneExpression(true_expr);

                t_Expression * equiv_expr = em->createOneBitExpressionWithTwoOperands(em->m_operatorLabelLogicalEquality, connect_expr, true_expr);

                connection_constraints_vec.push_back(equiv_expr);
                continue;
            }


            nids_to_consider.insert(source_nid);
            nids_to_consider.insert(target_nid);
            all_nids_in_constraints.insert(source_nid);
            all_nids_in_constraints.insert(target_nid);
            get_connection_implies_end_nodes_constraints(em, connection_implies_end_nodes, connect_var, src_node_var, tgt_node_var);




            int src_nid_in_ugraph = ugraph->get_nid_from_rep_id(graph->get_rep_id_from_nid(source_nid));
            
            int tgt_nid_in_ugraph = ugraph->get_nid_from_rep_id(graph->get_rep_id_from_nid(target_nid));

            
            
            set<int> mincut_eids;
            set<int> directed_cut_eids;
            
            
            get_min_cut_edges_from_ghtree(graph, ugraph, closure_matrix, cut_edges, gomoryhu_parents, selected_mincut_vec, GET_NODE_SEQ_NUM(ugraph, src_nid_in_ugraph), GET_NODE_SEQ_NUM(ugraph, tgt_nid_in_ugraph), directed_cut_eids);
            
            //cout << "CUT SIZE: " << directed_cut_eids.size() << " between " << graph->get_rep_id_from_nid(source_nid) << " and " << graph->get_rep_id_from_nid(target_nid) << endl;
                
//            if (directed_cut_eids.size() == 0) {
//                cout << "No connection" << endl;
//                exit(1);
//            }
            
            //cout << "CUT SIZE: " << directed_cut_eids.size() << " between " << graph->get_rep_id_from_nid(source_nid) << " and " << graph->get_rep_id_from_nid(target_nid) << endl;
            // -- filling call_level_matrix - added by Sukanya on 28 Dec 2017
            
                
            for (auto e = directed_cut_eids.begin(); e != directed_cut_eids.end(); e++) {
                int curr_eid = *e;
                int curr_eid_src = graph->get_source_node(curr_eid);
                int curr_eid_tgt = graph->get_target_node(curr_eid);
                int curr_eid_src_nseq = GET_NODE_SEQ_NUM(graph, curr_eid_src);
                int curr_eid_tgt_nseq = GET_NODE_SEQ_NUM(graph, curr_eid_tgt);
                
                int curr_entry = call_level_matrix[call_pair_source_nseq][curr_eid_src_nseq];
                int new_curr_entry = min(curr_entry, 1 + call_level_matrix[call_pair_source_nseq][call_pair_target_nseq]);
                 
                if (new_curr_entry < curr_entry) {
                    call_level_matrix[call_pair_source_nseq][curr_eid_src_nseq] = new_curr_entry;
                    
                }
                
                curr_entry = call_level_matrix[curr_eid_tgt_nseq][call_pair_target_nseq];
                new_curr_entry = min(curr_entry, 1 + call_level_matrix[call_pair_source_nseq][call_pair_target_nseq]);
                
                if (new_curr_entry < curr_entry) {
                    call_level_matrix[curr_eid_tgt_nseq][call_pair_target_nseq] = new_curr_entry;
                    
                }
                
                curr_entry = edge_level_matrix[curr_eid_src_nseq][curr_eid_tgt_nseq];
                new_curr_entry = min(curr_entry, 1 + call_level_matrix[call_pair_source_nseq][call_pair_target_nseq]);
                
                
                if (new_curr_entry < curr_entry)
                    edge_level_matrix[curr_eid_src_nseq][curr_eid_tgt_nseq] = new_curr_entry;
                
                if (call_pair_source_nseq != curr_eid_src_nseq)
                        call_count_matrix[call_pair_source_nseq][curr_eid_src_nseq]++;
                
                if (curr_eid_tgt_nseq != call_pair_target_nseq)
                        call_count_matrix[curr_eid_tgt_nseq][call_pair_target_nseq]++;
                
                edge_count_matrix[curr_eid_src_nseq][curr_eid_tgt_nseq]++;
            }
                
                        
            // --
            
            


            if (directed_cut_eids.empty()) {
                
                t_Expression * connect_expr = em->createSymbol(connect_var, te1);
                t_Expression * no_connection = em->createOneBitExpressionWithOneOperand(em->m_operatorLabelLogNOT, connect_expr);
                connection_constraints_vec.push_back(no_connection);
                //return;
                continue;
            }

            // ----
////            map<string, int> nodes_in_mincut;
////            
////            hout << "<p style=\"text-align:left;\">";
////            hout << "<br> <br> To disconnect <b>" << ugraph->get_all_display_ids_of_node(src_nid_in_ugraph)[0] << "</b> ";
////            hout << "from <b> " << ugraph->get_all_display_ids_of_node(tgt_nid_in_ugraph)[0] << "</b>";
////            hout << "<br>remove all of the following edges <br>" << endl;
////            hout << "<br>" << endl;
////
////            set<string> written_edges;
////            for (set<int>::iterator set_itr = directed_cut_eids.begin(); set_itr != directed_cut_eids.end(); set_itr++) {
////                
////                graph->write_mincut_edge_to_html(*set_itr, hout, up_reg_rep_ids, down_reg_rep_ids, nodes_in_mincut, nodes_in_all_mincuts, written_edges);
////                
////            }
////
////            
////            hout << "<br>" << endl;
////            hout << "<span style=\"color: #000000\"> Frequency of nodes:" << "</span>" << endl;
////            hout << "<br><br>" << endl;
////            for (auto iter = nodes_in_mincut.begin(); iter != nodes_in_mincut.end(); iter++) {
////                hout << "<span style=\"color: #000000\">" << graph->get_all_display_ids_of_node(graph->get_nid_from_rep_id(iter->first))[0] << ": " << iter->second <<  "</span>" << endl;
////                hout << "<br>" << endl;
////            }
////            hout << "<br>" << endl;
////   
////   
////            hout << "</p>" << endl;
////            hout << "<br>" << endl;
            // ----
            
            if (directed_cut_eids.size() == 1) {
                //cout << "Mincut between " << graph->get_rep_id_from_nid(source_nid) << " and " << graph->get_rep_id_from_nid(target_nid) << " has 1 edge" << endl;

                //int curr_edge = ugraph->get_other_value1_in_edge(*directed_cut_eids.begin());
                int curr_edge = *directed_cut_eids.begin();

                //int curr_edge = *directed_cut_eids.begin();
                eids_to_consider.insert(curr_edge);
                nids_to_consider.insert(graph->get_source_node(curr_edge)); //
                nids_to_consider.insert(graph->get_target_node(curr_edge)); //

                all_eids_in_constraints.insert(curr_edge);
                all_nids_in_constraints.insert(graph->get_source_node(curr_edge));
                all_nids_in_constraints.insert(graph->get_target_node(curr_edge));
                string edge_var = "__edge_" + IntToString(curr_edge);


                t_Expression * right_expr;

                
                
                if ((graph->get_source_node(curr_edge) == source_nid) && (graph->get_target_node(curr_edge) == target_nid)) {
                    right_expr = em->createSymbol(edge_var, te1);
                    
                } else {
                    vector<t_Expression *> to_AND;
                    t_Expression * edge_expr = em->createSymbol(edge_var, te1);
                    if (edge_expr != NULL)
                        to_AND.push_back(edge_expr);

                    if (graph->get_source_node(curr_edge) != source_nid) {
                        string new_connect_var = "__connect_" + IntToString(source_nid) + "_" + IntToString(graph->get_source_node(curr_edge));
                        t_Expression * new_connect_expr = em->createSymbol(new_connect_var, te1);
                        if (new_connect_expr != NULL)
                            to_AND.push_back(new_connect_expr);
                        if (source_nid != graph->get_source_node(curr_edge)){ // not the same node
                            connect_pairs_to_consider.push_back(pair<int, int>(source_nid, graph->get_source_node(curr_edge)));
                            //cout << "A Pair inserted: " << source_nid << " " << graph->get_source_node(curr_edge) << endl;
                        }
                    }
                    if (graph->get_target_node(curr_edge) != target_nid) {
                        string new_connect_var = "__connect_" + IntToString(graph->get_target_node(curr_edge)) + "_" + IntToString(target_nid);
                        t_Expression * new_connect_expr = em->createSymbol(new_connect_var, te1);
                        if (new_connect_expr != NULL)
                            to_AND.push_back(new_connect_expr);
                        if (graph->get_target_node(curr_edge) != target_nid) { // not the same node
                            connect_pairs_to_consider.push_back(pair<int, int>(graph->get_target_node(curr_edge), target_nid));
                            //cout << "B Pair inserted: " << graph->get_target_node(curr_edge) << " " << target_nid << endl;
                        }

                    }

                    //right_expr = em->createExpression(em->m_operatorLabelLogAND, to_AND);
                    right_expr = get_AND_expr_from_vector(em, to_AND);
                    assert(right_expr != NULL);
                }

                //t_Expression * equiv_expr = build_EQUIV_constraint(connect_expr, right_expr, em);
                vector<t_Expression *> v = em->buildVector(connect_expr, right_expr);
                t_Expression * equiv_expr = em->createExpression(em->m_operatorLabelLogicalEquality, v);
                connection_constraints_vec.push_back(equiv_expr);

            }
            else {
                //t_Expression * connect_expr = em->createSymbol(connect_var, te1);
                t_Expression * right_expr;
                vector<t_Expression *> to_OR;
                for (auto mincut_iter = directed_cut_eids.begin(); mincut_iter != directed_cut_eids.end(); mincut_iter++) {
                    //int curr_edge = ugraph->get_other_value1_in_edge(*mincut_iter);
                    int curr_edge = *mincut_iter;
                    eids_to_consider.insert(curr_edge);
                    nids_to_consider.insert(graph->get_source_node(curr_edge)); //
                    nids_to_consider.insert(graph->get_target_node(curr_edge)); //

                    all_eids_in_constraints.insert(curr_edge);
                    all_nids_in_constraints.insert(graph->get_source_node(curr_edge));
                    all_nids_in_constraints.insert(graph->get_target_node(curr_edge));

                    string edge_var = "__edge_" + IntToString(curr_edge);


                    if ((graph->get_source_node(curr_edge) == source_nid) && (graph->get_target_node(curr_edge) == target_nid)) {
                        right_expr = em->createSymbol(edge_var, te1);
                        assert(right_expr != NULL);
                        to_OR.push_back(right_expr);

                    } else {
                        vector<t_Expression *> to_AND;
                        t_Expression * edge_expr = em->createSymbol(edge_var, te1);
                        t_Expression * new_connect_expr;
                        if (edge_expr != NULL)
                            to_AND.push_back(edge_expr);
                        if (graph->get_source_node(curr_edge) != source_nid) {
                            string new_connect_var = "__connect_" + IntToString(source_nid) + "_" + IntToString(graph->get_source_node(curr_edge));
                            new_connect_expr = em->createSymbol(new_connect_var, te1);
                            if (new_connect_expr != NULL)
                                to_AND.push_back(new_connect_expr);
                            if (source_nid != graph->get_source_node(curr_edge)) { // not the same node
                                connect_pairs_to_consider.push_back(pair<int, int>(source_nid, graph->get_source_node(curr_edge)));
                                //cout << "C Pair inserted: " << source_nid << " " << graph->get_source_node(curr_edge) << endl;
                            }

                        }
                        if (graph->get_target_node(curr_edge) != target_nid) {
                            string new_connect_var = "__connect_" + IntToString(graph->get_target_node(curr_edge)) + "_" + IntToString(target_nid);
                            new_connect_expr = em->createSymbol(new_connect_var, te1);
                            if (new_connect_expr != NULL)
                                to_AND.push_back(new_connect_expr);
                            if (graph->get_target_node(curr_edge) != target_nid) { // not the same node
                                connect_pairs_to_consider.push_back(pair<int, int>(graph->get_target_node(curr_edge), target_nid));
                                //cout << "D Pair inserted: " << graph->get_target_node(curr_edge) << " " << target_nid << endl;
                            }

                        }


                        //right_expr = em->createExpression(em->m_operatorLabelLogAND, to_AND);
                        right_expr = get_AND_expr_from_vector(em, to_AND);
                        assert(right_expr != NULL);
                        to_OR.push_back(right_expr);
                    }

                }

                //t_Expression * right_expr_ORed = em->createExpression(em->m_operatorLabelLogOR, to_OR);
                t_Expression * right_expr_ORed = get_OR_expr_from_vector(em, to_OR);

                
                
                vector<t_Expression *> v = em->buildVector(connect_expr, right_expr_ORed);
                t_Expression * equiv_expr = em->createExpression(em->m_operatorLabelLogicalEquality, v);
                connection_constraints_vec.push_back(equiv_expr);

            }

        }
    

    }

////////////    auto result = std::max_element(selected_mincut_vec.begin(), selected_mincut_vec.end());
    //std::cout << "max element " << *result << " at: " << std::distance(selected_mincut_vec.begin(), result) << endl;
    //cout << ugraph->get_all_display_ids_of_node(GET_NODE_ID(ugraph, gomoryhu_parents[*result]))[0] << " " 
    //        << ugraph->get_all_display_ids_of_node(GET_NODE_ID(ugraph, gomoryhu_parents[gomoryhu_parents[*result]]))[0] << endl;
}

void GraphManagerNew::get_connection_implies_end_nodes_constraints(t_ExpressionManager * em, vector<t_Expression *>& connection_implies_end_nodes, string connect_var, string src_node_var, string tgt_node_var) {



    //TypeOfExpressionTuple te1 = {TYPE_UNSIGNED_BITVECTOR, 1};
    TypeOfExpressionTuple te1 = {TYPE_BOOL, 1};
    t_Expression * connect_expr = em->createSymbol(connect_var, te1);
    t_Expression * src_node_expr = em->createSymbol(src_node_var, te1);
    t_Expression * tgt_node_expr = em->createSymbol(tgt_node_var, te1);
    //t_Expression * right_expr = build_AND_constraints(src_node_expr, tgt_node_expr, 0, 0, em);
    vector<t_Expression *> v1 = em->buildVector(src_node_expr, tgt_node_expr);
    t_Expression * right_expr = em->createExpression(em->m_operatorLabelLogAND, v1);


    connect_expr = em->createOneBitExpressionWithOneOperand(em->m_operatorLabelLogNOT, connect_expr);
    vector<t_Expression *> v2 = em->buildVector(connect_expr, right_expr);
    t_Expression * implication_expr = em->createExpression(em->m_operatorLabelLogOR, v2);
    //t_Expression * implication_expr = em->createExpression(em->m_operatorLabelLogicalEquality, v2);


    connection_implies_end_nodes.push_back(implication_expr);

}

void GraphManagerNew::get_edge_implies_connection_constraints(t_ExpressionManager * em, int path_length_bound, vector<t_Expression *>& edge_implies_connection_constraints_vec, vector<t_Expression *>& src_dist_lt_tgt_dist_constraints_vec, GraphNew * graph, set<int>& nids_to_consider, set<int>& eids_to_consider, list<pair<int, int> >& connect_pairs_to_consider, set<int>& all_nids_in_constraints) {

    
    //TypeOfExpressionTuple te1 = {TYPE_UNSIGNED_BITVECTOR, 1};
    TypeOfExpressionTuple te1 = {TYPE_BOOL, 1};

    static set<int> written_edges;


    for (auto eids_iter = eids_to_consider.begin(); eids_iter != eids_to_consider.end(); eids_iter++) {
        int curr_eid = *eids_iter;
        int src_nid = graph->get_source_node(curr_eid);
        int tgt_nid = graph->get_target_node(curr_eid);
        nids_to_consider.insert(src_nid);
        nids_to_consider.insert(tgt_nid);
        all_nids_in_constraints.insert(src_nid);
        all_nids_in_constraints.insert(tgt_nid);


        if (written_edges.find(curr_eid) == written_edges.end()) {
            written_edges.insert(curr_eid);

            string edge_var = "__edge_" + IntToString(curr_eid);
            string connect_var = "__connect_" + IntToString(src_nid) + "_" + IntToString(tgt_nid);
            t_Expression * edge_expr = em->createSymbol(edge_var, te1);
            
////            t_Expression * connect_expr = em->createSymbol(connect_var, te1);
////
            t_Expression * not_edge_expr = em->createOneBitExpressionWithOneOperand(em->m_operatorLabelLogNOT, edge_expr);
////            vector<t_Expression *> v = em->buildVector(not_edge_expr, connect_expr);
////            t_Expression * implication_expr = em->createExpression(em->m_operatorLabelLogOR, v);

////////            if (implication_expr != NULL) {
////////                edge_implies_connection_constraints_vec.push_back(implication_expr);
////////
////////            }
////////
////////            connect_pairs_to_consider.push_back(pair<int, int>(src_nid, tgt_nid));


            // edge present implies end nodes are present
            string src_var = "__node_" + IntToString(src_nid);
            string tgt_var = "__node_" + IntToString(tgt_nid);
            t_Expression * src_expr = em->createSymbol(src_var, te1);
            t_Expression * tgt_expr = em->createSymbol(tgt_var, te1);
            t_Expression * present_expr = em->createOneBitExpressionWithTwoOperands(em->m_operatorLabelLogAND, src_expr, tgt_expr);
            t_Expression * implication_expr2 = em->createOneBitExpressionWithTwoOperands(em->m_operatorLabelLogOR, not_edge_expr, present_expr);
            
            assert (implication_expr2 != NULL);
            
            edge_implies_connection_constraints_vec.push_back(implication_expr2);

            


            // for ordering -- src_dist < tgt_dist
            get_src_dist_lt_tgt_dist_constraints(em, path_length_bound, src_dist_lt_tgt_dist_constraints_vec, graph, curr_eid);


        }
    }
    
}

void GraphManagerNew::get_src_dist_lt_tgt_dist_constraints(t_ExpressionManager * em, int path_length_bound, vector<t_Expression *>& src_dist_lt_tgt_dist_constraints_vec, GraphNew * graph, int curr_eid) {
    //TypeOfExpressionTuple te1 = {TYPE_UNSIGNED_BITVECTOR, 1};
    TypeOfExpressionTuple te1 = {TYPE_BOOL, 1};
    TypeOfExpressionTuple te2 = {TYPE_UNSIGNED_BITVECTOR, PATH_BOUND_BIT_LENGTH(path_length_bound)};

    string edge_var = "__edge_" + IntToString(curr_eid);
    string src_distance_var = "__nodedistance_" + IntToString(graph->get_source_node(curr_eid));
    string tgt_distance_var = "__nodedistance_" + IntToString(graph->get_target_node(curr_eid));

    static set<int> written_eids;

    if (written_eids.find(curr_eid) != written_eids.end())
        return;

    t_Expression * edge_expr = em->createSymbol(edge_var, te1);
    t_Expression * src_distance_expr = em->createSymbol(src_distance_var, te2);
    t_Expression * tgt_distance_expr = em->createSymbol(tgt_distance_var, te2);
    //t_Expression * less_than_expr = em->createOneBitExpressionWithTwoOperands(em->m_operatorLabelLessThan, src_distance_expr, tgt_distance_expr);
    vector<t_Expression *> v1 = em->buildVector(src_distance_expr, tgt_distance_expr);
    t_Expression * less_than_expr = em->createExpression(em->m_operatorLabelLessThan, v1);

    edge_expr = em->createOneBitExpressionWithOneOperand(em->m_operatorLabelLogNOT, edge_expr);
    vector<t_Expression *> v = em->buildVector(edge_expr, less_than_expr);
    t_Expression * implication_expr = em->createExpression(em->m_operatorLabelLogOR, v);

    if (implication_expr != NULL)
        src_dist_lt_tgt_dist_constraints_vec.push_back(implication_expr);
}

void GraphManagerNew::get_targets_dist_lt_bound_constraints(t_ExpressionManager * em, int path_length_bound, vector<t_Expression *>& targets_dist_lt_bound_constraints_vec, GraphNew * graph, set<int>& nids_as_target) {
    //TypeOfExpressionTuple te1 = {TYPE_UNSIGNED_BITVECTOR, 1};
    TypeOfExpressionTuple te1 = {TYPE_BOOL, 1};
    TypeOfExpressionTuple te2 = {TYPE_UNSIGNED_BITVECTOR, PATH_BOUND_BIT_LENGTH(path_length_bound)};


    static set<int> written_nids;

    for (auto iter = nids_as_target.begin(); iter != nids_as_target.end(); iter++) {
        int curr_nid = *iter;

        if (written_nids.find(curr_nid) != written_nids.end())
            continue;

        string node_dist_var = "__nodedistance_" + IntToString(curr_nid);
        string path_bound_var = "__pathbound";

        t_Expression * node_dist_expr = em->createSymbol(node_dist_var, te2);
        //t_Expression * dist_bound_expr = em->createIntegerConstant(bound, NODE_DISTANCE_VALUE_BIT_LENGTH);
        t_Expression * dist_bound_expr = em->createSymbol(path_bound_var, te2);
        t_Expression * less_than_expr = em->createOneBitExpressionWithTwoOperands(em->m_operatorLabelLessThanOrEqual, node_dist_expr, dist_bound_expr);
        targets_dist_lt_bound_constraints_vec.push_back(less_than_expr);
    }


}

void GraphManagerNew::get_node_implies_inedge_outedge_constraints(t_ExpressionManager * em, vector<t_Expression *>& node_implies_inedge_outedge_constraints_vec, GraphNew * graph, set<int>& up_reg_nids, set<int>& down_reg_nids, set<int>& nids_to_consider, set<int>& eids_to_consider, set<int>& nids_as_source, set<int>& nids_as_target, set<int>& all_nids_in_constraints, set<int>& all_eids_in_constraints) {

   
    get_source_has_outedge_constraints(em, node_implies_inedge_outedge_constraints_vec, graph, nids_as_source, nids_to_consider, eids_to_consider, all_nids_in_constraints, all_eids_in_constraints);
    get_target_has_inedge_constraints(em, node_implies_inedge_outedge_constraints_vec, graph, up_reg_nids, down_reg_nids, nids_as_target, nids_to_consider, eids_to_consider, all_nids_in_constraints, all_eids_in_constraints);
    
    set<int> all_nodes_minus_sources;
    set<int> remaining_nodes_to_consider;
    set_difference(nids_to_consider.begin(), nids_to_consider.end(), nids_as_source.begin(), nids_as_source.end(), inserter(all_nodes_minus_sources, all_nodes_minus_sources.begin()));
    set_difference(all_nodes_minus_sources.begin(), all_nodes_minus_sources.end(), nids_as_target.begin(), nids_as_target.end(), inserter(remaining_nodes_to_consider, remaining_nodes_to_consider.begin()));

    get_node_has_inedge_outedge_constraints(em, node_implies_inedge_outedge_constraints_vec, graph, up_reg_nids, down_reg_nids, remaining_nodes_to_consider, nids_to_consider, eids_to_consider, all_nids_in_constraints, all_eids_in_constraints);

}

void GraphManagerNew::get_source_has_outedge_constraints(t_ExpressionManager * em, vector<t_Expression *>& node_implies_inedge_outedge_constraints_vec, GraphNew * graph, set<int>& nids_as_source, set<int>& nids_to_consider, set<int>& eids_to_consider, set<int>& all_nids_in_constraints, set<int>& all_eids_in_constraints) {
    //TypeOfExpressionTuple te1 = {TYPE_UNSIGNED_BITVECTOR, 1};
    TypeOfExpressionTuple te1 = {TYPE_BOOL, 1};

    static set<int> written_as_source;

    // currently considering single source
    for (auto nids_iter = nids_as_source.begin(); nids_iter != nids_as_source.end(); nids_iter++) {
        int curr_nid = *nids_iter;

        if (written_as_source.find(curr_nid) != written_as_source.end())
            continue;
        written_as_source.insert(curr_nid);

        string node_var = "__node_" + IntToString(curr_nid);
        t_Expression * node_expr = em->createSymbol(node_var, te1);
        t_Expression * right_expr;
        

        vector<int> outlist = graph->get_outlist(curr_nid);

        vector<t_Expression *> to_OR;

        for (auto out_iter = outlist.begin(); out_iter != outlist.end(); out_iter++) {
            int curr_edge = *out_iter;

            if (eids_to_consider.find(curr_edge) != eids_to_consider.end()) {
                    string edge_var = "__edge_" + IntToString(curr_edge);
                    t_Expression * edge_expr = em->createSymbol(edge_var, te1);
                    to_OR.push_back(edge_expr);

                    all_eids_in_constraints.insert(curr_edge);
                    int edge_src_nid = graph->get_source_node(curr_edge);
                    int edge_tgt_nid = graph->get_target_node(curr_edge);
                    all_nids_in_constraints.insert(edge_src_nid);
                    all_nids_in_constraints.insert(edge_tgt_nid);
            }

        }

        if (to_OR.empty()) {
            node_expr = em->createOneBitExpressionWithOneOperand(em->m_operatorLabelLogNOT, node_expr);
            node_implies_inedge_outedge_constraints_vec.push_back(node_expr);
            continue;
        }
        else if (to_OR.size() == 1) {
            
            right_expr = to_OR.front();
            
        }
        else
            right_expr = get_OR_expr_from_vector(em, to_OR);
        


        node_expr = em->createOneBitExpressionWithOneOperand(em->m_operatorLabelLogNOT, node_expr);
        vector<t_Expression *> v = em->buildVector(node_expr, right_expr);
        t_Expression * implication_expr = em->createExpression(em->m_operatorLabelLogOR, v);
        //t_Expression * implication_expr = em->createExpression(em->m_operatorLabelLogicalEquality, v);
        node_implies_inedge_outedge_constraints_vec.push_back(implication_expr);

    }

}

void GraphManagerNew::get_target_has_inedge_constraints(t_ExpressionManager * em, vector<t_Expression *>& node_implies_inedge_outedge_constraints_vec, GraphNew * graph, set<int>& up_reg_nids, set<int>& down_reg_nids, set<int>& nids_as_target, set<int>& nids_to_consider, set<int>& eids_to_consider, set<int>& all_nids_in_constraints, set<int>& all_eids_in_constraints) {
    //TypeOfExpressionTuple te1 = {TYPE_UNSIGNED_BITVECTOR, 1};
    TypeOfExpressionTuple te1 = {TYPE_BOOL, 1};

    static set<int> written_as_target;
    
    
    // this works only for one target currently
    for (auto nids_iter = nids_as_target.begin(); nids_iter != nids_as_target.end(); nids_iter++) {
        int curr_nid = *nids_iter;

        if (written_as_target.find(curr_nid) != written_as_target.end())
            continue;
        written_as_target.insert(curr_nid);

        string node_var = "__node_" + IntToString(curr_nid);
        t_Expression * node_expr = em->createSymbol(node_var, te1);
        t_Expression * right_expr;


        vector<int> inlist = graph->get_inlist(curr_nid);




        vector<t_Expression *> to_OR;
        for (auto in_iter = inlist.begin(); in_iter != inlist.end(); in_iter++) {
            int curr_edge = *in_iter;

            if (eids_to_consider.find(curr_edge) != eids_to_consider.end()) {


                string edge_var = "__edge_" + IntToString(curr_edge);
                t_Expression * edge_expr = em->createSymbol(edge_var, te1);


                to_OR.push_back(edge_expr);
                
                all_eids_in_constraints.insert(curr_edge);
                int edge_src_nid = graph->get_source_node(curr_edge);
                int edge_tgt_nid = graph->get_target_node(curr_edge);
                all_nids_in_constraints.insert(edge_src_nid);
                all_nids_in_constraints.insert(edge_tgt_nid);
            }

        }

        if (to_OR.empty()) {
            node_expr = em->createOneBitExpressionWithOneOperand(em->m_operatorLabelLogNOT, node_expr);
            node_implies_inedge_outedge_constraints_vec.push_back(node_expr);
            continue;
        }
        else if (to_OR.size() == 1) {
            
            right_expr = to_OR.front();
        }
        else
            right_expr = get_OR_expr_from_vector(em, to_OR);



        node_expr = em->createOneBitExpressionWithOneOperand(em->m_operatorLabelLogNOT, node_expr);
        vector<t_Expression *> v = em->buildVector(node_expr, right_expr);
        t_Expression * implication_expr = em->createExpression(em->m_operatorLabelLogOR, v);
        //t_Expression * implication_expr = em->createExpression(em->m_operatorLabelLogicalEquality, v);
        node_implies_inedge_outedge_constraints_vec.push_back(implication_expr);

    }

}

void GraphManagerNew::get_node_has_inedge_outedge_constraints(t_ExpressionManager * em, vector<t_Expression *>& node_implies_inedge_outedge_constraints_vec, GraphNew * graph, set<int>& up_reg_nids, set<int>& down_reg_nids, set<int>& remaining_nodes_to_consider, set<int>& nids_to_consider, set<int>& eids_to_consider, set<int>& all_nids_in_constraints, set<int>& all_eids_in_constraints) {
    //TypeOfExpressionTuple te1 = {TYPE_UNSIGNED_BITVECTOR, 1};
    TypeOfExpressionTuple te1 = {TYPE_BOOL, 1};

    static set<int> written_nids;

    //nids_to_consider - both out and in edges
    for (auto nids_iter = remaining_nodes_to_consider.begin(); nids_iter != remaining_nodes_to_consider.end(); nids_iter++) {
        int curr_nid = *nids_iter;

        if (written_nids.find(curr_nid) != written_nids.end())
            continue;
        written_nids.insert(curr_nid);

        vector<int> inlist = graph->get_inlist(curr_nid);
        vector<int> outlist = graph->get_outlist(curr_nid);


        string node_var = "__node_" + IntToString(curr_nid);
        t_Expression * node_expr = em->createSymbol(node_var, te1);
        
        assert (!inlist.empty() && !outlist.empty());


        // inlist

        t_Expression * inlist_expr = NULL;
       
          
        vector<t_Expression *> to_OR_in;
        for (auto in_iter = inlist.begin(); in_iter != inlist.end(); in_iter++) {
            int curr_edge = *in_iter;

            if (eids_to_consider.find(curr_edge) != eids_to_consider.end()) {
                string edge_var = "__edge_" + IntToString(curr_edge);
                t_Expression * edge_expr = em->createSymbol(edge_var, te1);

                to_OR_in.push_back(edge_expr);
                
                //all_eids_in_constraints.insert(curr_edge);
                int edge_src_nid = graph->get_source_node(curr_edge);
                int edge_tgt_nid = graph->get_target_node(curr_edge);
                all_nids_in_constraints.insert(edge_src_nid);
                all_nids_in_constraints.insert(edge_tgt_nid);
            }

        }

        if (to_OR_in.empty()) {
            t_Expression * not_node_expr = em->createOneBitExpressionWithOneOperand(em->m_operatorLabelLogNOT, node_expr);
            node_implies_inedge_outedge_constraints_vec.push_back(not_node_expr);
            continue;
        }
        else if (to_OR_in.size() == 1) {
            
            
            inlist_expr = to_OR_in.front();
        }
        else
            inlist_expr = get_OR_expr_from_vector(em, to_OR_in);

        

        // outlist

        t_Expression * outlist_expr = NULL;
           
        vector<t_Expression *> to_OR_out;
        for (auto out_iter = outlist.begin(); out_iter != outlist.end(); out_iter++) {
            int curr_edge = *out_iter;

            if (eids_to_consider.find(curr_edge) != eids_to_consider.end()) {
                string edge_var = "__edge_" + IntToString(curr_edge);
                t_Expression * edge_expr = em->createSymbol(edge_var, te1);

                to_OR_out.push_back(edge_expr);
                //all_eids_in_constraints.insert(curr_edge);
                int edge_src_nid = graph->get_source_node(curr_edge);
                int edge_tgt_nid = graph->get_target_node(curr_edge);
                all_nids_in_constraints.insert(edge_src_nid);
                all_nids_in_constraints.insert(edge_tgt_nid);
            }



        }


        if (to_OR_out.empty()) {
            t_Expression * not_node_expr = em->createOneBitExpressionWithOneOperand(em->m_operatorLabelLogNOT, node_expr);
            node_implies_inedge_outedge_constraints_vec.push_back(not_node_expr);
            continue;
        }
        else if (to_OR_out.size() == 1) {
            
            outlist_expr = to_OR_out.front();
        }

        else
            outlist_expr = get_OR_expr_from_vector(em, to_OR_out);
            
        
        t_Expression * right_expr;

        assert (inlist_expr != NULL && outlist_expr != NULL);
        
        vector<t_Expression *> v = em->buildVector(outlist_expr, inlist_expr);
        right_expr = em->createExpression(em->m_operatorLabelLogAND, v);
        

        t_Expression * not_node_expr = em->createOneBitExpressionWithOneOperand(em->m_operatorLabelLogNOT, node_expr);
        vector<t_Expression *> v2 = em->buildVector(not_node_expr, right_expr);
        t_Expression * implication_expr = em->createExpression(em->m_operatorLabelLogOR, v2);
        //t_Expression * implication_expr = em->createExpression(em->m_operatorLabelLogicalEquality, v2);

        node_implies_inedge_outedge_constraints_vec.push_back(implication_expr);

    }
    //remaining_nodes_to_consider.clear();

}

void GraphManagerNew::get_microarray_data_as_constraints(t_ExpressionManager * em, GraphNew * graph, vector<t_Expression *>& microarray_data_assertions_vec, set<int>& up_reg_nids, set<int>& down_reg_nids, set<int>& nids_to_consider, set<int>& nids_as_target, set<int>& all_nids_in_constraints) {
    //TypeOfExpressionTuple te1 = {TYPE_UNSIGNED_BITVECTOR, 1};
    TypeOfExpressionTuple te1 = {TYPE_BOOL, 1};

    static set<int> written_nids;

    for (auto iter = up_reg_nids.begin(); iter != up_reg_nids.end(); iter++) {

        int curr_nid = *iter;

        if (written_nids.find(curr_nid) == written_nids.end()) {
            written_nids.insert(curr_nid);

            nids_to_consider.insert(curr_nid);
            all_nids_in_constraints.insert(curr_nid);
            //nids_as_target.insert(curr_nid);
            string data_var = "__node_" + IntToString(curr_nid);
            t_Expression * data_expr = em->createSymbol(data_var, te1);
            microarray_data_assertions_vec.push_back(data_expr);
        }
    }
    for (auto iter = down_reg_nids.begin(); iter != down_reg_nids.end(); iter++) {

        int curr_nid = *iter;

        if (written_nids.find(curr_nid) == written_nids.end()) {
            written_nids.insert(curr_nid);
            nids_to_consider.insert(curr_nid);
            all_nids_in_constraints.insert(curr_nid);
            //nids_as_target.insert(curr_nid);
            string data_var = "__node_" + IntToString(curr_nid);
            t_Expression * data_expr = em->createSymbol(data_var, te1);
            microarray_data_assertions_vec.push_back(data_expr);
        }
    }

    // to disallow NFKB to happen
//    int nfkb_nid = graph->get_nid_from_rep_id(graph->get_rep_id_from_id("hsa4790"));
//    
//    string nfkb_var = "__node_" + IntToString(nfkb_nid);
//    t_Expression * nfkb_expr = em->createSymbol(nfkb_var, te1);
//    nfkb_expr = em->createOneBitExpressionWithOneOperand(em->m_operatorLabelLogNOT, nfkb_expr);
//    
//   microarray_data_assertions_vec.push_back(nfkb_expr);
}

void GraphManagerNew::get_query_assertions_as_constraints(t_ExpressionManager * em, vector<t_Expression *>& query_assertions_as_constraints_vec, vector<pair<int, int> >& connect_pairs, vector<pair<int, int> >& disconnect_pairs, set<int>& essential_nids, set<int>& avoid_nids, set<int>& nids_to_consider, set<int>& all_nids_in_constraints) {
    //TypeOfExpressionTuple te1 = {TYPE_UNSIGNED_BITVECTOR, 1};
    TypeOfExpressionTuple te1 = {TYPE_BOOL, 1};

    static set<string> written_pairs_connect;
    static set<string> written_pairs_disconnect;
    static set<int> written_nids;


    for (auto iter = connect_pairs.begin(); iter != connect_pairs.end(); iter++) {
        string connect_var = "__connect_" + IntToString((*iter).first) + "_" + IntToString((*iter).second);

        if (written_pairs_connect.find(connect_var) == written_pairs_connect.end()) {
            written_pairs_connect.insert(connect_var);
            nids_to_consider.insert((*iter).first);
            nids_to_consider.insert((*iter).second);
            all_nids_in_constraints.insert((*iter).first);
            all_nids_in_constraints.insert((*iter).second);
            t_Expression * connect_expr = em->createSymbol(connect_var, te1);
            query_assertions_as_constraints_vec.push_back(connect_expr);
        }
    }

    for (auto iter = disconnect_pairs.begin(); iter != disconnect_pairs.end(); iter++) {
        string connect_var = "__connect_" + IntToString((*iter).first) + "_" + IntToString((*iter).second);

        if (written_pairs_disconnect.find(connect_var) == written_pairs_disconnect.end()) {
            written_pairs_disconnect.insert(connect_var);
            nids_to_consider.insert((*iter).first);
            nids_to_consider.insert((*iter).second);
            all_nids_in_constraints.insert((*iter).first);
            all_nids_in_constraints.insert((*iter).second);
            t_Expression * connect_expr = em->createSymbol(connect_var, te1);
            t_Expression * not_connect_expr = em->createOneBitExpressionWithOneOperand(em->m_operatorLabelLogNOT, connect_expr);
            query_assertions_as_constraints_vec.push_back(not_connect_expr);
        }
    }

    for (auto iter = essential_nids.begin(); iter != essential_nids.end(); iter++) {

        int curr_nid = *iter;


        if (written_nids.find(curr_nid) == written_nids.end()) {
            written_nids.insert(curr_nid);
            nids_to_consider.insert(curr_nid);
            all_nids_in_constraints.insert(curr_nid);
            string data_var = "__node_" + IntToString(curr_nid);
            t_Expression * data_expr = em->createSymbol(data_var, te1);
            query_assertions_as_constraints_vec.push_back(data_expr);
        }
    }
    
    for (auto iter = avoid_nids.begin(); iter != avoid_nids.end(); iter++) {

        int curr_nid = *iter;
        string data_var = "__node_" + IntToString(curr_nid);
        t_Expression * data_expr = em->createSymbol(data_var, te1);
        t_Expression * not_data_expr = em->createOneBitExpressionWithOneOperand(em->m_operatorLabelLogNOT, data_expr);
        query_assertions_as_constraints_vec.push_back(not_data_expr);
        
    }
}

//void GraphManagerNew::get_type_consistency_constraints(t_ExpressionManager * em, vector<t_Expression *>& negated_edges_contraints_vec, GraphNew * graph, set<int>& all_eids_in_constraints, set<int>& up_reg_nids, set<int>& down_reg_nids) {
//    TypeOfExpressionTuple te1 = {TYPE_BOOL, 1};
//    vector<t_Expression *> to_AND;
//    t_Expression * negated_edges_expr;
//    
//    for (auto eids_itr = all_eids_in_constraints.begin(); eids_itr != all_eids_in_constraints.end(); eids_itr++) {
//        int curr_eid = *eids_itr;
//        
//        string edge_var = "__edge_" + IntToString(curr_eid);
//        t_Expression * edge_expr = em->createSymbol(edge_var, te1);
//                
//        int curr_edge_src = graph->get_source_node(curr_eid);
//        int curr_edge_tgt = graph->get_target_node(curr_eid);
//        
////        if (graph->get_outlist(curr_edge_src).size() == 1)
////            continue;
//        
//        if (up_reg_nids.find(curr_edge_tgt) != up_reg_nids.end()) {
//            if (up_reg_nids.find(curr_edge_src) != up_reg_nids.end()) {
//                if ((graph->edge_has_subtype(curr_eid, "inhibition")) || (graph->edge_has_subtype(curr_eid, "repression"))) {
//                    edge_expr = em->createOneBitExpressionWithOneOperand(em->m_operatorLabelLogNOT, edge_expr);
//                    to_AND.push_back(edge_expr);
//                }
//            }
//        }
//        if (down_reg_nids.find(curr_edge_tgt) != down_reg_nids.end()) {
//            if (up_reg_nids.find(curr_edge_src) != up_reg_nids.end()){
//                if ((graph->edge_has_subtype(curr_eid, "activation")) || (graph->edge_has_subtype(curr_eid, "expression"))) {
//                    edge_expr = em->createOneBitExpressionWithOneOperand(em->m_operatorLabelLogNOT, edge_expr);
//                    to_AND.push_back(edge_expr);
//                }
//            }
//        }
//              
//    }
//    
//    negated_edges_expr = build_AND_constraints_from_vector(to_AND, em);
//    negated_edges_contraints_vec.push_back(negated_edges_expr);
//    
//}

void GraphManagerNew::get_edge_type_consistency_constraints(t_ExpressionManager * em, vector<t_Expression *>& negated_edges_contraints_vec, GraphNew * graph, set<int>& eids_to_consider, set<int>& up_reg_nids, set<int>& down_reg_nids) {
    TypeOfExpressionTuple te1 = {TYPE_BOOL, 1};
    vector<t_Expression *> to_AND;
    t_Expression * negated_edges_expr;
    
    for (auto eids_itr = eids_to_consider.begin(); eids_itr != eids_to_consider.end(); eids_itr++) {
        int curr_eid = *eids_itr;
        // need to do this on eids that cannot be relaxed
                
        string edge_var = "__edge_" + IntToString(curr_eid);
        t_Expression * edge_expr = em->createSymbol(edge_var, te1);
                
        int curr_edge_src = graph->get_source_node(curr_eid);
        int curr_edge_tgt = graph->get_target_node(curr_eid);
        
                
        string src_active_var = "__nodeactive_" + IntToString(curr_edge_src);
        string tgt_active_var = "__nodeactive_" + IntToString(curr_edge_tgt);
        
        t_Expression * src_active_expr = em->createSymbol(src_active_var, te1);
        t_Expression * tgt_active_expr = em->createSymbol(tgt_active_var, te1);
        
////        if (up_reg_nids.find(curr_edge_src) != up_reg_nids.end()) {
////            to_AND.push_back(src_active_expr);
////        }
////        
////        if (up_reg_nids.find(curr_edge_tgt) != up_reg_nids.end()) {
////            to_AND.push_back(tgt_active_expr);
////        }
////        
////        
////        if (down_reg_nids.find(curr_edge_src) != down_reg_nids.end()) {
////            t_Expression * src_inactive_expr = em->createOneBitExpressionWithOneOperand(em->m_operatorLabelLogNOT, src_active_expr);
////            to_AND.push_back(src_inactive_expr);
////        }
////        
////        if (down_reg_nids.find(curr_edge_tgt) != down_reg_nids.end()) {
////            t_Expression * tgt_inactive_expr = em->createOneBitExpressionWithOneOperand(em->m_operatorLabelLogNOT, tgt_active_expr);
////            to_AND.push_back(tgt_inactive_expr);
////        }
            
        
        // condition for inactive
        t_Expression * right_expr;
        
        t_Expression * rev_right_expr;
        
        if (graph->edge_has_subtype(curr_eid, "inhibition") || graph->edge_has_subtype(curr_eid, "repression")) { // || graph->edge_has_subtype(curr_eid, "dephosphorylation")) {
            t_Expression * tgt_inactive_expr = em->createOneBitExpressionWithOneOperand(em->m_operatorLabelLogNOT, tgt_active_expr);
            right_expr = em->createOneBitExpressionWithTwoOperands(em->m_operatorLabelLogAND, src_active_expr, tgt_inactive_expr);
            
            // reverse case
            t_Expression * src_inactive_expr = em->createOneBitExpressionWithOneOperand(em->m_operatorLabelLogNOT, src_active_expr);
            rev_right_expr = em->createOneBitExpressionWithTwoOperands(em->m_operatorLabelLogAND, src_inactive_expr, tgt_active_expr);
            right_expr = em->createOneBitExpressionWithTwoOperands(em->m_operatorLabelLogOR, right_expr, rev_right_expr);
        }
        else {
            right_expr = em->createOneBitExpressionWithTwoOperands(em->m_operatorLabelLogAND, src_active_expr, tgt_active_expr);
            
            // reverse case
////            t_Expression * src_inactive_expr = em->createOneBitExpressionWithOneOperand(em->m_operatorLabelLogNOT, src_active_expr);
////            t_Expression * tgt_inactive_expr = em->createOneBitExpressionWithOneOperand(em->m_operatorLabelLogNOT, tgt_active_expr);
////            rev_right_expr = em->createOneBitExpressionWithTwoOperands(em->m_operatorLabelLogAND, src_inactive_expr, tgt_inactive_expr);
////            right_expr = em->createOneBitExpressionWithTwoOperands(em->m_operatorLabelLogOR, right_expr, rev_right_expr);
        }
        
        // implication
        edge_expr = em->createOneBitExpressionWithOneOperand(em->m_operatorLabelLogNOT, edge_expr);
        t_Expression * implication_expr = em->createOneBitExpressionWithTwoOperands(em->m_operatorLabelLogOR, edge_expr, right_expr);
        
        to_AND.push_back(implication_expr);
    }
    
    
    negated_edges_expr = get_AND_expr_from_vector(em, to_AND);
    negated_edges_contraints_vec.push_back(negated_edges_expr);
    
}

void GraphManagerNew::get_node_activation_status_relaxation_constraints(t_ExpressionManager * em, vector<t_Expression *>& node_activation_status_relaxation_constraints_vec, vector<t_Expression *>& all_nodes_relax_expr_vec,  GraphNew * graph, set<int>& nids_to_consider, set<int>& up_reg_nids, set<int>& down_reg_nids) {
    int up_down_size = up_reg_nids.size() + down_reg_nids.size();
    TypeOfExpressionTuple te1 = {TYPE_BOOL, 1};
    TypeOfExpressionTuple te2 = {TYPE_UNSIGNED_BITVECTOR, NODE_RELAX_BOUND_BIT_LENGTH(up_down_size)};
    
    string node_bound_var = "__nodestatusrelaxbound";
    
//    static set<int> written_nids;
    
    vector<t_Expression *> all_nodes_expr_vec;

    
    for (auto nids_itr = nids_to_consider.begin(); nids_itr != nids_to_consider.end(); nids_itr++) {
        int curr_nid = *nids_itr;
        
//        if (written_nids.find(curr_nid) != written_nids.end())
//            continue;
//        
//        written_nids.insert(curr_nid);
        
        
        
        if (up_reg_nids.find(curr_nid) != up_reg_nids.end()) {
            string node_present_var = "__node_" + IntToString(curr_nid);
            string node_active_var = "__nodeactive_" + IntToString(curr_nid);
            string node_relax_var = "__noderelax_" + IntToString(curr_nid);
            
            t_Expression * node_present_expr = em->createSymbol(node_present_var, te1);
            t_Expression * node_active_expr = em->createSymbol(node_active_var, te1);
            t_Expression * node_relax_expr = em->createSymbol(node_relax_var, te1);
            
            t_Expression * node_present_and_active_expr = em->createOneBitExpressionWithTwoOperands(em->m_operatorLabelLogAND, node_present_expr, node_active_expr);
            t_Expression * neg_node_present_and_active_expr = em->createOneBitExpressionWithOneOperand(em->m_operatorLabelLogNOT, node_present_and_active_expr);
                       
            t_Expression * expr_with_value_1 = em->createIntegerConstant(1, NODE_RELAX_BOUND_BIT_LENGTH(up_down_size));
            t_Expression * expr_with_value_0 = em->createIntegerConstant(0, NODE_RELAX_BOUND_BIT_LENGTH(up_down_size));
            vector<t_Expression *> ite_opers_vec;
            ite_opers_vec.push_back(neg_node_present_and_active_expr);
            ite_opers_vec.push_back(expr_with_value_1);
            ite_opers_vec.push_back(expr_with_value_0);
            t_Expression * node_int_expr = em->createExpression(em->m_operatorLabelIte, ite_opers_vec, te2);
            all_nodes_expr_vec.push_back(node_int_expr);
            
            t_Expression * relax_bound_equality_expr = em->createOneBitExpressionWithTwoOperands(em->m_operatorLabelLogicalEquality, node_relax_expr, neg_node_present_and_active_expr);
            all_nodes_relax_expr_vec.push_back(relax_bound_equality_expr);
        }
        
        
        if (down_reg_nids.find(curr_nid) != down_reg_nids.end()) {
            string node_present_var = "__node_" + IntToString(curr_nid);
            string node_active_var = "__nodeactive_" + IntToString(curr_nid);
            string node_relax_var = "__noderelax_" + IntToString(curr_nid);
            
            t_Expression * node_present_expr = em->createSymbol(node_present_var, te1);
            t_Expression * node_active_expr = em->createSymbol(node_active_var, te1);
            //t_Expression * node_inactive_expr = em->createOneBitExpressionWithOneOperand(em->m_operatorLabelLogNOT, node_active_expr);
            t_Expression * node_relax_expr = em->createSymbol(node_relax_var, te1);
            
            t_Expression * node_present_and_active_expr = em->createOneBitExpressionWithTwoOperands(em->m_operatorLabelLogAND, node_present_expr, node_active_expr);
            //t_Expression * neg_node_present_and_inactive_expr = em->createOneBitExpressionWithOneOperand(em->m_operatorLabelLogNOT, node_present_and_inactive_expr);
            
            t_Expression * expr_with_value_1 = em->createIntegerConstant(1, NODE_RELAX_BOUND_BIT_LENGTH(up_down_size));
            t_Expression * expr_with_value_0 = em->createIntegerConstant(0, NODE_RELAX_BOUND_BIT_LENGTH(up_down_size));
            vector<t_Expression *> ite_opers_vec;
            ite_opers_vec.push_back(node_present_and_active_expr);
            ite_opers_vec.push_back(expr_with_value_1);
            ite_opers_vec.push_back(expr_with_value_0);
            t_Expression * node_int_expr = em->createExpression(em->m_operatorLabelIte, ite_opers_vec, te2);
            all_nodes_expr_vec.push_back(node_int_expr);
            
            t_Expression * relax_bound_equality_expr = em->createOneBitExpressionWithTwoOperands(em->m_operatorLabelLogicalEquality, node_relax_expr, node_present_and_active_expr);
            all_nodes_relax_expr_vec.push_back(relax_bound_equality_expr);
        }
    }
    
//    if (all_nodes_expr_vec.empty())
//        return;
    
    t_Expression * sum_of_true_nodes = em->createTwoOperandOperatorFromMultipleOperands(em->m_operatorLabelADD, all_nodes_expr_vec, te2);
    t_Expression * num_of_nodes_bound_expr = em->createSymbol(node_bound_var, te2);
    
    t_Expression * less_than_expr = em->createOneBitExpressionWithTwoOperands(em->m_operatorLabelLessThanOrEqual, sum_of_true_nodes, num_of_nodes_bound_expr);
    
    if (less_than_expr != NULL)
        node_activation_status_relaxation_constraints_vec.push_back(less_than_expr);
       
      
}



void GraphManagerNew::get_edge_activation_status_relaxation_constraints(t_ExpressionManager * em, vector<t_Expression *>& edge_activation_status_relaxation_constraints_vec, vector<t_Expression *>& all_edges_relax_expr_vec,  GraphNew * graph, set<int>& eids_to_consider, set<int>& up_reg_nids, set<int>& down_reg_nids) {
    
    TypeOfExpressionTuple te1 = {TYPE_BOOL, 1};
    TypeOfExpressionTuple te2 = {TYPE_UNSIGNED_BITVECTOR, EDGE_RELAX_BOUND_BIT_LENGTH(graph)};
    
    string edge_bound_var = "__edgestatusrelaxbound";
    
//    static set<int> written_nids;
    
    vector<t_Expression *> all_edges_expr_vec;
    
    for (auto eids_itr = eids_to_consider.begin(); eids_itr != eids_to_consider.end(); eids_itr++) {
        int curr_eid = *eids_itr;
        int curr_src_nid = graph->get_source_node(curr_eid);
        int curr_tgt_nid = graph->get_target_node(curr_eid);
        
//        if (written_nids.find(curr_nid) != written_nids.end())
//            continue;
//        
//        written_nids.insert(curr_nid);
        
        
            
        string src_node_present_var = "__node_" + IntToString(curr_src_nid);
        string src_node_active_var = "__nodeactive_" + IntToString(curr_src_nid);

        string tgt_node_present_var = "__node_" + IntToString(curr_tgt_nid);
        string tgt_node_active_var = "__nodeactive_" + IntToString(curr_tgt_nid);
        
        string edge_relax_var = "__edgerelax_" + IntToString(curr_eid);
        t_Expression * edge_relax_expr = em->createSymbol(edge_relax_var, te1);
            
        // source node is present and active
        t_Expression * src_node_present_expr = em->createSymbol(src_node_present_var, te1);
        t_Expression * src_node_active_expr = em->createSymbol(src_node_active_var, te1);
        t_Expression * src_node_present_and_active_expr = em->createOneBitExpressionWithTwoOperands(em->m_operatorLabelLogAND, src_node_present_expr, src_node_active_expr);

        // target node is present and active
        t_Expression * tgt_node_present_expr = em->createSymbol(tgt_node_present_var, te1);
        t_Expression * tgt_node_active_expr = em->createSymbol(tgt_node_active_var, te1);
        t_Expression * tgt_node_present_and_active_expr = em->createOneBitExpressionWithTwoOperands(em->m_operatorLabelLogAND, tgt_node_present_expr, tgt_node_active_expr);
                
        // source node is present and inactive
        t_Expression * src_node_inactive_expr = em->createOneBitExpressionWithOneOperand(em->m_operatorLabelLogNOT, src_node_active_expr);
        t_Expression * src_node_present_and_inactive_expr = em->createOneBitExpressionWithTwoOperands(em->m_operatorLabelLogAND, src_node_present_expr, src_node_inactive_expr);
        // target node is present and inactive
        t_Expression * tgt_node_inactive_expr = em->createOneBitExpressionWithOneOperand(em->m_operatorLabelLogNOT, tgt_node_active_expr);
        t_Expression * tgt_node_present_and_inactive_expr = em->createOneBitExpressionWithTwoOperands(em->m_operatorLabelLogAND, tgt_node_present_expr, tgt_node_inactive_expr);
        
        vector<t_Expression *> to_OR;
        if (graph->edge_has_subtype(curr_eid, "inhibition") || (graph->edge_has_subtype(curr_eid, "repression"))) {
            
                     
            // both source and target nodes present and active
            t_Expression * adj_nodes_present_and_active_expr = em->createOneBitExpressionWithTwoOperands(em->m_operatorLabelLogAND, src_node_present_and_active_expr, tgt_node_present_and_active_expr);
            //t_Expression * neg_adj_nodes_present_and_active_expr = em->createOneBitExpressionWithOneOperand(em->m_operatorLabelLogNOT, adj_nodes_present_and_active_expr);
            
            t_Expression * expr_with_value_1 = em->createIntegerConstant(1, EDGE_RELAX_BOUND_BIT_LENGTH(graph));
            t_Expression * expr_with_value_0 = em->createIntegerConstant(0, EDGE_RELAX_BOUND_BIT_LENGTH(graph));
            vector<t_Expression *> ite_opers_vec;
            to_OR.push_back(adj_nodes_present_and_active_expr);
            
            // both source and target nodes present and inactive
            t_Expression * adj_nodes_present_and_inactive_expr = em->createOneBitExpressionWithTwoOperands(em->m_operatorLabelLogAND, src_node_present_and_inactive_expr, tgt_node_present_and_inactive_expr);
            //t_Expression * neg_adj_nodes_present_and_inactive_expr = em->createOneBitExpressionWithOneOperand(em->m_operatorLabelLogNOT, adj_nodes_present_and_inactive_expr);
                        
            to_OR.push_back(adj_nodes_present_and_inactive_expr);
            
            t_Expression * ORed_expr = get_OR_expr_from_vector(em, to_OR);
            
            ite_opers_vec.push_back(ORed_expr);
            ite_opers_vec.push_back(expr_with_value_1);
            ite_opers_vec.push_back(expr_with_value_0);
            t_Expression * ite_expr = em->createExpression(em->m_operatorLabelIte, ite_opers_vec, te2);
            
            all_edges_expr_vec.push_back(ite_expr);
            
            t_Expression * relax_bound_equality_expr = em->createOneBitExpressionWithTwoOperands(em->m_operatorLabelLogicalEquality, edge_relax_expr, ORed_expr);
            all_edges_relax_expr_vec.push_back(relax_bound_equality_expr);
        }
        
        
        else {
                     
            // source node present and active, and target node present and inactive
            t_Expression * src_node_present_active_tgt_node_present_inactive_expr = em->createOneBitExpressionWithTwoOperands(em->m_operatorLabelLogAND, src_node_present_and_active_expr, tgt_node_present_and_inactive_expr);
            //t_Expression * neg_src_node_present_active_tgt_node_present_active_expr  = em->createOneBitExpressionWithOneOperand(em->m_operatorLabelLogNOT, src_node_present_active_tgt_node_present_active_expr);
            
            t_Expression * expr_with_value_1 = em->createIntegerConstant(1, EDGE_RELAX_BOUND_BIT_LENGTH(graph));
            t_Expression * expr_with_value_0 = em->createIntegerConstant(0, EDGE_RELAX_BOUND_BIT_LENGTH(graph));
            vector<t_Expression *> ite_opers_vec;
            
            to_OR.push_back(src_node_present_active_tgt_node_present_inactive_expr);
            
            
            // source node present and inactive, and target node present and active
            t_Expression * src_node_present_inactive_tgt_node_present_active_expr = em->createOneBitExpressionWithTwoOperands(em->m_operatorLabelLogAND, src_node_present_and_inactive_expr, tgt_node_present_and_active_expr);
            to_OR.push_back(src_node_present_inactive_tgt_node_present_active_expr);
            
            // source node present and inactive, and target node present and inactive
            t_Expression * src_node_present_inactive_tgt_node_present_inactive_expr = em->createOneBitExpressionWithTwoOperands(em->m_operatorLabelLogAND, src_node_present_and_inactive_expr, tgt_node_present_and_inactive_expr);
           
            to_OR.push_back(src_node_present_inactive_tgt_node_present_inactive_expr);
            
            t_Expression * ORed_expr = get_OR_expr_from_vector(em, to_OR);
            
            ite_opers_vec.push_back(ORed_expr);
            ite_opers_vec.push_back(expr_with_value_1);
            ite_opers_vec.push_back(expr_with_value_0);
            t_Expression * ite_expr = em->createExpression(em->m_operatorLabelIte, ite_opers_vec, te2);
            
            all_edges_expr_vec.push_back(ite_expr);
            
            t_Expression * relax_bound_equality_expr = em->createOneBitExpressionWithTwoOperands(em->m_operatorLabelLogicalEquality, edge_relax_expr, ORed_expr);
            all_edges_relax_expr_vec.push_back(relax_bound_equality_expr);
        }
   
        
        
    }
    
    if (all_edges_expr_vec.empty())
        return;
    
    t_Expression * sum_of_true_edges = em->createTwoOperandOperatorFromMultipleOperands(em->m_operatorLabelADD, all_edges_expr_vec, te2);
    t_Expression * num_of_edges_bound_expr = em->createSymbol(edge_bound_var, te2);
    
    t_Expression * less_than_expr = em->createOneBitExpressionWithTwoOperands(em->m_operatorLabelLessThanOrEqual, sum_of_true_edges, num_of_edges_bound_expr);
    
    if (less_than_expr != NULL)
        edge_activation_status_relaxation_constraints_vec.push_back(less_than_expr);
       
      
}





void GraphManagerNew::get_every_path_has_diff_exp_node_constraints(t_ExpressionManager * em, vector<t_Expression *>& every_path_has_diff_exp_node_constraints_vec, GraphNew * graph, set<int>& nids_to_consider, set<int>& eids_to_consider, set<int>& up_reg_nids, set<int>& down_reg_nids, set<int>& nids_as_source, set<int>& nids_as_target) {
 
    vector<t_Expression *> every_path_has_diff_exp_node_constraints_vec_temp;
    
    set<int> diff_expr_nids;
    set_union(up_reg_nids.begin(), up_reg_nids.end(), down_reg_nids.begin(), down_reg_nids.end(), inserter(diff_expr_nids, diff_expr_nids.begin()));
    
    TypeOfExpressionTuple te1 = {TYPE_BOOL, 1};
    
    // 1. All selected incoming edges of the target must have  f set to true
    vector<t_Expression *> all_tgt_node_expr_vec;
    static set<int> written_nids1;
    for (auto nids_iter = nids_as_target.begin(); nids_iter != nids_as_target.end(); nids_iter++) {
        int curr_nid = *nids_iter;
        
        if (written_nids1.find(curr_nid) != written_nids1.end())
            continue;
        
        written_nids1.insert(curr_nid);
        
            
        vector<t_Expression *> node_all_edges_expr_vec;
        
        vector<int> inlist = graph->get_inlist(curr_nid);            

        if (inlist.empty())
            continue;

        for (auto inlist_iter = inlist.begin(); inlist_iter != inlist.end(); inlist_iter++) {
            int curr_inedge = *inlist_iter;

            if (eids_to_consider.find(curr_inedge) == eids_to_consider.end())
                continue;
            
            string edge_var = "__edge_" + IntToString(curr_inedge);
            string edge_flag_var = "__edgepathflag_" + IntToString(curr_inedge);

            t_Expression * edge_expr = em->createSymbol(edge_var, te1);
            t_Expression * neg_edge_expr = em->createOneBitExpressionWithOneOperand(em->m_operatorLabelLogNOT, edge_expr);
            t_Expression * edge_flag_expr = em->createSymbol(edge_flag_var, te1);

            t_Expression * implication_expr = em->createOneBitExpressionWithTwoOperands(em->m_operatorLabelLogOR, neg_edge_expr, edge_flag_expr);

            if (implication_expr != NULL)
                node_all_edges_expr_vec.push_back(implication_expr);

        }
        
        t_Expression * node_all_edges_expr = get_AND_expr_from_vector(em, node_all_edges_expr_vec);
        
        if (node_all_edges_expr != NULL)
                all_tgt_node_expr_vec.push_back(node_all_edges_expr);
    }
    
    t_Expression * incoming_edge_of_target_expr = get_AND_expr_from_vector(em, all_tgt_node_expr_vec);
    
    if (incoming_edge_of_target_expr != NULL)
        every_path_has_diff_exp_node_constraints_vec_temp.push_back(incoming_edge_of_target_expr);
  
    
  
    
    // 2. If a node is not differentially expressed and if it has at least one selected incoming edge that has f set to false, then all its outgoing edges (selected or not) must have f set to false.
    set<int> not_diff_expr_nids;
    static set<int> written_nids2;
    set_difference(nids_to_consider.begin(), nids_to_consider.end(), diff_expr_nids.begin(), diff_expr_nids.end(), inserter(not_diff_expr_nids, not_diff_expr_nids.begin()));

    vector<t_Expression *> all_non_diff_nodes_expr_vec;
    
    for (auto node_iter = not_diff_expr_nids.begin(); node_iter != not_diff_expr_nids.end(); node_iter++) {
        int curr_nid = *node_iter;
        
        if (written_nids2.find(curr_nid) != written_nids2.end())
            continue;
        
        written_nids2.insert(curr_nid);
        
        
        vector<int> inlist = graph->get_inlist(curr_nid);    
        if (inlist.empty())
                continue;        
            
        vector<t_Expression *> to_OR;
        for (auto inlist_iter = inlist.begin(); inlist_iter != inlist.end(); inlist_iter++) {
                int curr_inedge = *inlist_iter;
                
                if (eids_to_consider.find(curr_inedge) == eids_to_consider.end())
                    continue;
                
                string edge_var = "__edge_" + IntToString(curr_inedge);
                string edge_flag_var = "__edgepathflag_" + IntToString(curr_inedge);
                
                t_Expression * edge_expr = em->createSymbol(edge_var, te1);
                t_Expression * edge_flag_expr = em->createSymbol(edge_flag_var, te1);
                t_Expression * neg_edge_flag_expr = em->createOneBitExpressionWithOneOperand(em->m_operatorLabelLogNOT, edge_flag_expr);
                
                t_Expression * sel_edge_with_flag_false = em->createOneBitExpressionWithTwoOperands(em->m_operatorLabelLogAND, edge_expr, neg_edge_flag_expr);
                
                to_OR.push_back(sel_edge_with_flag_false);
        }
        
               
        t_Expression * ORed_negated_inedge_exprs = get_OR_expr_from_vector(em, to_OR);
        
        
        vector<t_Expression *> to_AND;
        vector<int> outlist = graph->get_outlist(curr_nid); 
        
        if (outlist.empty())
            continue;
        
        for (auto outlist_iter = outlist.begin(); outlist_iter != outlist.end(); outlist_iter++) {
                int curr_outedge = *outlist_iter;
                
                if (eids_to_consider.find(curr_outedge) == eids_to_consider.end())
                    continue;
                
                string edge_flag_var = "__edgepathflag_" + IntToString(curr_outedge);
                
                t_Expression * edge_flag_expr = em->createSymbol(edge_flag_var, te1);
                t_Expression * neg_edge_flag_expr = em->createOneBitExpressionWithOneOperand(em->m_operatorLabelLogNOT, edge_flag_expr);
                
                to_AND.push_back(neg_edge_flag_expr);
               
        }
        t_Expression * ANDed_negated_outedge_exprs = get_AND_expr_from_vector(em, to_AND);
        
        
        t_Expression * neg_ORed_negated_inedge_expr = em->createOneBitExpressionWithOneOperand(em->m_operatorLabelLogNOT, ORed_negated_inedge_exprs);
        t_Expression * implication_expr = em->createOneBitExpressionWithTwoOperands(em->m_operatorLabelLogOR, neg_ORed_negated_inedge_expr, ANDed_negated_outedge_exprs);
        
        if(implication_expr != NULL)
                all_non_diff_nodes_expr_vec.push_back(implication_expr);
    }
    
    t_Expression * all_non_diff_nodes_expr = get_AND_expr_from_vector(em, all_non_diff_nodes_expr_vec);
    
    if (all_non_diff_nodes_expr != NULL)
        every_path_has_diff_exp_node_constraints_vec_temp.push_back(all_non_diff_nodes_expr);
   
    
    
    // 3. All (selected or not) outgoing edges from source have f set to false
    
    
    vector<t_Expression *> all_src_node_expr_vec;
    static set<int> written_nids3;
    
    set<int> nids_as_source_minus_diff_expr_nids;
    set_difference(nids_as_source.begin(), nids_as_source.end(), diff_expr_nids.begin(), diff_expr_nids.end(), inserter(nids_as_source_minus_diff_expr_nids, nids_as_source_minus_diff_expr_nids.begin()));
    
    for (auto nids_iter = nids_as_source_minus_diff_expr_nids.begin(); nids_iter != nids_as_source_minus_diff_expr_nids.end(); nids_iter++) {
        int curr_nid = *nids_iter;
        
        if (written_nids3.find(curr_nid) != written_nids3.end())
            continue;
        
        written_nids3.insert(curr_nid);
        
        
        vector<t_Expression *> node_all_edges_expr_vec;
        
        vector<int> outlist = graph->get_outlist(curr_nid);            

        if (outlist.empty())
            continue;

        for (auto outlist_iter = outlist.begin(); outlist_iter != outlist.end(); outlist_iter++) {
            int curr_outedge = *outlist_iter;

            if (eids_to_consider.find(curr_outedge) == eids_to_consider.end())
                continue;
            
            string edge_flag_var = "__edgepathflag_" + IntToString(curr_outedge);

            t_Expression * edge_flag_expr = em->createSymbol(edge_flag_var, te1);

            t_Expression * neg_edge_flag_expr = em->createOneBitExpressionWithOneOperand(em->m_operatorLabelLogNOT, edge_flag_expr);
            node_all_edges_expr_vec.push_back(neg_edge_flag_expr);

        }
            
        
        t_Expression * node_all_edges_expr = get_AND_expr_from_vector(em, node_all_edges_expr_vec);
        
        if (node_all_edges_expr != NULL)
                all_src_node_expr_vec.push_back(node_all_edges_expr);
    }
    
    t_Expression * outgoing_edge_of_target_expr = get_AND_expr_from_vector(em, all_src_node_expr_vec);
    
    if (outgoing_edge_of_target_expr != NULL)
        every_path_has_diff_exp_node_constraints_vec_temp.push_back(outgoing_edge_of_target_expr);

   
    
    // 4. If a node is differentially expressed, all its outgoing edges (selected or not) have f set to true.
    vector<t_Expression *> all_diff_nodes_expr_vec;
    static set<int> written_nids4;
    for (auto node_iter = diff_expr_nids.begin(); node_iter != diff_expr_nids.end(); node_iter++) {
        int curr_nid = *node_iter;
        
        if (written_nids4.find(curr_nid) != written_nids4.end())
            continue;
        
        written_nids4.insert(curr_nid);
        
        
        vector<t_Expression *> node_all_edges_expr_vec;
        vector<int> outlist = graph->get_outlist(curr_nid);
        
        if (outlist.empty())
            continue;
        
        for (auto outlist_iter = outlist.begin(); outlist_iter != outlist.end(); outlist_iter++) {
            int curr_outedge = *outlist_iter;

            if (eids_to_consider.find(curr_outedge) == eids_to_consider.end())
                continue;
            
            string edge_flag_var = "__edgepathflag_" + IntToString(curr_outedge);

            t_Expression * edge_flag_expr = em->createSymbol(edge_flag_var, te1);

            node_all_edges_expr_vec.push_back(edge_flag_expr);
        }
        t_Expression * node_all_edges_expr = get_AND_expr_from_vector(em, node_all_edges_expr_vec);
        
        if (node_all_edges_expr != NULL)
                all_diff_nodes_expr_vec.push_back(node_all_edges_expr);
    }
    
    
    
    t_Expression * all_diff_nodes_expr = get_AND_expr_from_vector(em, all_diff_nodes_expr_vec);
    
    if (all_diff_nodes_expr != NULL)
        every_path_has_diff_exp_node_constraints_vec_temp.push_back(all_diff_nodes_expr);
    
    
    
    t_Expression * every_path_has_diff_exp_node_constraints = get_AND_expr_from_vector(em, every_path_has_diff_exp_node_constraints_vec_temp);
    
    if (every_path_has_diff_exp_node_constraints != NULL)
        every_path_has_diff_exp_node_constraints_vec.push_back(every_path_has_diff_exp_node_constraints);
    
}


void GraphManagerNew::get_total_nodes_lt_bound_constraints(t_ExpressionManager * em, vector<t_Expression *>& total_nodes_lt_bound_constraints_vec, GraphNew * graph, set<int>& nids_to_consider) {
    //TypeOfExpressionTuple te1 = {TYPE_UNSIGNED_BITVECTOR, 1};
    TypeOfExpressionTuple te1 = {TYPE_BOOL, 1};
    TypeOfExpressionTuple te2 = {TYPE_UNSIGNED_BITVECTOR, NODE_BOUND_BIT_LENGTH(graph)};

    vector<t_Expression *> all_nodes_expr_vec;
    string node_bound_var = "__nodebound";
    static set<int> written_nids;

    for (auto iter = nids_to_consider.begin(); iter != nids_to_consider.end(); iter++) {
        int curr_nid = *iter;

        if (written_nids.find(curr_nid) != written_nids.end())
            continue;

        string node_var = "__node_" + IntToString(curr_nid);


        t_Expression * node_expr = em->createSymbol(node_var, te1);
        t_Expression * expr_with_value_1 = em->createIntegerConstant(1, NODE_BOUND_BIT_LENGTH(graph));
        t_Expression * expr_with_value_0 = em->createIntegerConstant(0, NODE_BOUND_BIT_LENGTH(graph));
        vector<t_Expression *> ite_opers_vec;
        ite_opers_vec.push_back(node_expr);
        ite_opers_vec.push_back(expr_with_value_1);
        ite_opers_vec.push_back(expr_with_value_0);
        t_Expression * node_int_expr = em->createExpression(em->m_operatorLabelIte, ite_opers_vec, te2);
        all_nodes_expr_vec.push_back(node_int_expr);


    }
    t_Expression * sum_of_true_nodes = em->createTwoOperandOperatorFromMultipleOperands(em->m_operatorLabelADD, all_nodes_expr_vec, te2);
    //t_Expression * num_of_nodes_bound_expr = em->createIntegerConstant(num_of_nodes_bound, NODE_BOUND_BIT_LENGTH);
    t_Expression * num_of_nodes_bound_expr = em->createSymbol(node_bound_var, te2);
    t_Expression * less_than_expr = em->createOneBitExpressionWithTwoOperands(em->m_operatorLabelLessThanOrEqual, sum_of_true_nodes, num_of_nodes_bound_expr);
    total_nodes_lt_bound_constraints_vec.push_back(less_than_expr);
}

void GraphManagerNew::get_total_edges_lt_bound_constraints(t_ExpressionManager * em, vector<t_Expression *>& total_edges_lt_bound_constraints_vec, GraphNew * graph, set<int>& eids_to_consider) {

    //TypeOfExpressionTuple te1 = {TYPE_UNSIGNED_BITVECTOR, 1};
    TypeOfExpressionTuple te1 = {TYPE_BOOL, 1};
    TypeOfExpressionTuple te2 = {TYPE_UNSIGNED_BITVECTOR, EDGE_BOUND_BIT_LENGTH(graph)};

    vector<t_Expression *> all_edges_expr_vec;
    string edge_bound_var = "__edgebound";
    static set<int> written_eids;


    for (auto iter = eids_to_consider.begin(); iter != eids_to_consider.end(); iter++) {
        int curr_eid = *iter;

        if (written_eids.find(curr_eid) != written_eids.end())
            continue;

        string edge_var = "__edge_" + IntToString(curr_eid);


        t_Expression * edge_expr = em->createSymbol(edge_var, te1);
        t_Expression * expr_with_value_1 = em->createIntegerConstant(1, EDGE_BOUND_BIT_LENGTH(graph));
        t_Expression * expr_with_value_0 = em->createIntegerConstant(0, EDGE_BOUND_BIT_LENGTH(graph));
        vector<t_Expression *> ite_opers_vec;
        ite_opers_vec.push_back(edge_expr);
        ite_opers_vec.push_back(expr_with_value_1);
        ite_opers_vec.push_back(expr_with_value_0);
        t_Expression * edge_int_expr = em->createExpression(em->m_operatorLabelIte, ite_opers_vec, te2);
        all_edges_expr_vec.push_back(edge_int_expr);


    }
    t_Expression * sum_of_true_edges = em->createTwoOperandOperatorFromMultipleOperands(em->m_operatorLabelADD, all_edges_expr_vec, te2);
    //t_Expression * num_of_nodes_bound_expr = em->createIntegerConstant(num_of_edges_bound, EDGE_BOUND_BIT_LENGTH);
    t_Expression * num_of_edges_bound_expr = em->createSymbol(edge_bound_var, te2);
    t_Expression * less_than_expr = em->createOneBitExpressionWithTwoOperands(em->m_operatorLabelLessThanOrEqual, sum_of_true_edges, num_of_edges_bound_expr);
    total_edges_lt_bound_constraints_vec.push_back(less_than_expr);
}

void GraphManagerNew::get_assertion_expressions(t_ExpressionManager * em, vector<pair<string, int> >& var_value_pairs, vector<t_Expression *>& assertion_expression_vec, ofstream& bound_fout) {

//    for (auto iter = var_value_pairs.begin(); iter != var_value_pairs.end(); iter++) {
//        t_Expression * bound_expr = em->createIntegerConstant(iter->second, NODE_DISTANCE_VALUE_BIT_LENGTH);
//        string bound_value_str = em->getLabelOfExpression(bound_expr);
//        bound_fout << "(assert (= " + iter->first + " #" + bound_value_str.substr(1) + "))\n";
//
//    }
    
}



void GraphManagerNew::get_expression_edges_assertion_constraints(t_ExpressionManager * em, vector<int>& akt_expr_inedges, vector<t_Expression *>& expression_edges_assert_vec) {
    vector<t_Expression *> to_OR;
    TypeOfExpressionTuple te1 = {TYPE_BOOL, 1};
    
    for (auto iter = akt_expr_inedges.begin(); iter != akt_expr_inedges.end(); iter++) {
        int curr_eid = *iter;

        string edge_var = "__edge_" + IntToString(curr_eid);
        t_Expression * edge_expr = em->createSymbol(edge_var, te1);
        to_OR.push_back(edge_expr);

    }
    t_Expression * ORed_expr = get_OR_expr_from_vector(em, to_OR);
    expression_edges_assert_vec.push_back(ORed_expr);
}





void GraphManagerNew::get_negated_solution_expression(t_ExpressionManager * em, map<string, bool>& var_value_pairs, t_Expression * negated_soln_expression, string file_prefix) {
    vector<t_Expression *> to_AND;
    TypeOfExpressionTuple te1 = {TYPE_BOOL, 1};
    
    for (auto iter = var_value_pairs.begin(); iter != var_value_pairs.end(); iter++) {
        string var = iter->first;
        t_Expression * var_expr = em->createSymbol(var, te1);
        if (iter->second)
            to_AND.push_back(var_expr);
        else {
            var_expr = em->createOneBitExpressionWithOneOperand(em->m_operatorLabelLogNOT, var_expr);
            to_AND.push_back(var_expr);
        }
        
    }
    t_Expression * soln_expr = get_AND_expr_from_vector(em, to_AND);
    t_Expression * neg_soln_expr = em->createOneBitExpressionWithOneOperand(em->m_operatorLabelLogNOT, soln_expr);
    
    vector<t_Expression *> temp_vector;
    temp_vector.push_back(neg_soln_expr);
    string filename = file_prefix + "_neg_soln";
    
    em->mod_printExpressionsToFileInSMT(temp_vector, "\n", filename);
    
}

void GraphManagerNew::get_negated_solution_expression1(t_ExpressionManager * em, map<int, bool>& nid_to_value_pairs, t_Expression * negated_soln_expression, string file_prefix, ofstream& neg_fout) {
    
    neg_fout  << "( assert ( not ( and ";
    for (auto iter = nid_to_value_pairs.begin(); iter != nid_to_value_pairs.end(); iter++) {
        int curr_nid = iter->first;
        
        if (iter->second) {
            neg_fout << " " << "__node_" << curr_nid;
            
        }
        else {
            neg_fout << " (not " << "__node_" << curr_nid << ")";
            
        }
        
    }
    neg_fout << ")))\n";
    
}

t_Expression * GraphManagerNew::get_expr_var_lt_const(t_ExpressionManager * em, string var_name, int var_value) {
//    t_Expression * less_than_expr = NULL;
//
//    TypeOfExpressionTuple te1 = {TYPE_UNSIGNED_BITVECTOR, NODE_DISTANCE_VALUE_BIT_LENGTH};
//
//    t_Expression * var_expr = em->createSymbol(var_name, te1);
//    t_Expression * bound_expr = em->createIntegerConstant(var_value, NODE_DISTANCE_VALUE_BIT_LENGTH);
//
//    cout << em->getLabelOfExpression(bound_expr) << endl;
//
//
//    less_than_expr = em->createOneBitExpressionWithTwoOperands(em->m_operatorLabelLessThan, var_expr, bound_expr);
}

t_Expression * GraphManagerNew::get_AND_expr_from_vector(t_ExpressionManager * em, vector<t_Expression*>& vec) {
    t_Expression* to_return = NULL;

    //TypeOfExpressionTuple te = {TYPE_UNSIGNED_BITVECTOR, 1};
    TypeOfExpressionTuple te = {TYPE_BOOL, 1};

    if (vec.empty()) {
        return NULL;
    }
    else if (vec.size() == 1)
        to_return = vec[0];

    else {
        to_return = vec[0];
        for (vector<t_Expression*>::iterator itr = vec.begin() + 1; itr != vec.end(); itr++) {
            t_Expression* temp = em->createOneBitExpressionWithTwoOperands(em->m_operatorLabelLogAND, to_return, *itr);
            to_return = temp;
        }
    }

    return to_return;
}

t_Expression * GraphManagerNew::get_OR_expr_from_vector(t_ExpressionManager * em, vector<t_Expression*>& vec) {
    t_Expression* to_return = NULL;
    //TypeOfExpressionTuple te = {TYPE_UNSIGNED_BITVECTOR, 1};
    TypeOfExpressionTuple te = {TYPE_BOOL, 1};

    if (vec.empty()) {
        cout << "Returning NULL expression from get_OR_expr_from_vector" << endl;
        return NULL;
    } else if (vec.size() == 1)
        to_return = vec[0];

    else {
        to_return = vec[0];
        for (vector<t_Expression*>::iterator itr = vec.begin() + 1; itr != vec.end(); itr++) {
            t_Expression* temp = em->createOneBitExpressionWithTwoOperands(em->m_operatorLabelLogOR, to_return, *itr);
            to_return = temp;
        }
    }

    return to_return;
}

string GraphManagerNew::process_smt_answer(GraphNew * graph, string smt_out_filename) {
    ifstream ifs(smt_out_filename.c_str());

    if (ifs.peek() == std::ifstream::traits_type::eof()) // check if ifs is empty
        return "UNDEFINED";

    string line;

    while (getline(ifs, line)) {
        if (line == "sat") {
            //cout << "SAT" << endl;
            //process_sat_output(graph, z3_out_filename, eids_to_remove);
            return "SAT";
        } else if (line == "unsat") {
            //cout << "UNSAT" << endl;
            return "UNSAT";
        } else
            return "UNDEFINED";
    }

}


void GraphManagerNew::process_smt_output(GraphNew * graph, string file_prefix, string smt_out_filename, set<int>& up_reg_nids, map<int, bool>& nid_to_value_pairs, map<int, bool>& eid_to_value_pairs, string smt_solver, bool counting_solns) {
    
    static int soln_counter = 1;
    int graphnum = graph->get_graph_id();
    SMT_solver solver = convert(smt_solver);
    
    ifstream ifs(smt_out_filename.c_str());
    
    string connect_result, nodes_result, edges_result, present_nodes_repids, active_nodes_repids, inactive_nodes_repids, relaxed_nodes_repids_filename, relaxed_edges_repids_filename, relaxed_edges_readable_filename;
        
    if (counting_solns) {
        connect_result = file_prefix + "_soln" + soln_counter + "_connect_result";
        nodes_result = file_prefix + "_soln" + soln_counter + "_nodes_result";
        edges_result = file_prefix + "_soln" + soln_counter + "_edges_result";
        present_nodes_repids = file_prefix + "_soln" + soln_counter + "_result_nodes_repids";
        active_nodes_repids = file_prefix + "_soln" + soln_counter + "_active_nodes_repids";
        inactive_nodes_repids = file_prefix + "_soln" + soln_counter + "_inactive_nodes_repids";
        relaxed_nodes_repids_filename = file_prefix + "_soln" + soln_counter + "_relaxed_nodes_repids";
        relaxed_edges_repids_filename = file_prefix + "_soln" + soln_counter + "_relaxed_edges_repids";
        relaxed_edges_readable_filename = file_prefix + "_soln" + soln_counter + "_relaxed_edges_readable";
    }
    
    else {
        connect_result = file_prefix + "_connect_result";
        nodes_result = file_prefix + "_nodes_result";
        edges_result = file_prefix + "_edges_result";
        present_nodes_repids = file_prefix + "_result_nodes_repids";
        active_nodes_repids = file_prefix + "_active_nodes_repids";
        inactive_nodes_repids = file_prefix + "_inactive_nodes_repids";
        relaxed_nodes_repids_filename = file_prefix + "_relaxed_nodes_repids";
        relaxed_edges_repids_filename = file_prefix + "_relaxed_edges_repids";
        relaxed_edges_readable_filename = file_prefix + "_relaxed_edges_readable";        
    }
    
    string line, var, value;
    std::size_t start, end;

    ofstream connect(connect_result.c_str());
    ofstream nodes(nodes_result.c_str());
    ofstream edges(edges_result.c_str());
    ofstream nodes_repids(present_nodes_repids.c_str());
    ofstream active_repids(active_nodes_repids.c_str());
    ofstream inactive_repids(inactive_nodes_repids.c_str());
    ofstream relaxed_nodes_repids(relaxed_nodes_repids_filename.c_str());
    ofstream relaxed_edges_repids(relaxed_edges_repids_filename.c_str());
    ofstream relaxed_edges_readable(relaxed_edges_readable_filename.c_str());

    set<int> eids_to_remove;
    set<int> eids_present;
    
    
    if (ifs.is_open()) {
        while (getline(ifs, line)) {

            if (line.find("define-fun") != std::string::npos) {
                start = line.find("__");
                if (start == std::string::npos)
                    continue;
                end = line.find(" ()");
                var = line.substr(start + 2, end - (start + 2));
                //var = line.substr(start + 2);
                list<string> tokens;
                split_string_into_list(var, "_", tokens);

                string type = tokens.front();
                
                if (type == "connect") {
                    tokens.pop_front();
                    connect << graph->get_all_display_ids_of_node(stringToInteger(tokens.front()))[0] << "\t";
                    tokens.pop_front();
                    connect << graph->get_all_display_ids_of_node(stringToInteger(tokens.front()))[0] << "\t";
                    getline(ifs, value);
                    
                    if (value.find("true") != std::string::npos) {
                        connect << "connected" << endl;
                        string new_var = "__" + var;
                        //var_value_pairs.insert(pair<string, bool>(new_var, true));
                    }
                    else if (value.find("false") != std::string::npos) {
                        connect << "not connected" << endl;
                        string new_var = "__" + var;
                        //var_value_pairs.insert(pair<string, bool>(new_var, false));
                    }
                 
                } 
                
                
                else if (type == "node") {
                    tokens.pop_front();
                    int nid = stoi(tokens.front());
                      
                    nodes << graph->get_all_display_ids_of_node(nid)[0] << "\t";
                    string repid = graph->get_rep_id_from_nid(nid);
                    getline(ifs, value);
                    if (value.find("true") != std::string::npos) {
                        string new_var = "__" + var;
                        nid_to_value_pairs.insert(pair<int, bool>(nid, true));
                        nodes << "present" << endl;
                    }
                    else if (value.find("false") != std::string::npos) {
                        string new_var = "__" + var;
                        nid_to_value_pairs.insert(pair<int, bool>(nid, false));
                        nodes << "absent" << endl;
                        
                        if (up_reg_nids.find(nid) != up_reg_nids.end()) {
                            relaxed_nodes_repids << graph->get_rep_id_from_nid(nid) << " " << graph->get_all_display_ids_of_node(nid)[0] << endl;
                        }
                    }
                    else {
                        cerr  << "Error in parsing node from smt output file" << endl;
                        exit(1);
                    }
                    
                                        
                } 
                
                else if (type == "nodeactive") {
                    tokens.pop_front();
                    int nid = stoi(tokens.front());
                    
                    getline(ifs, value);
                    if (value.find("true") != std::string::npos) {
                        string new_var = "__" + var;
                        //var_value_pairs.insert(pair<string, bool>(new_var, true));
                        active_repids << graph->get_rep_id_from_nid(nid) << endl;
                    }
                    else if (value.find("false") != std::string::npos) {
                        string new_var = "__" + var;
                        //var_value_pairs.insert(pair<string, bool>(new_var, false));
                        inactive_repids << graph->get_rep_id_from_nid(nid) << endl;
                        
                        if (up_reg_nids.find(nid) != up_reg_nids.end()) {
                            relaxed_nodes_repids << graph->get_rep_id_from_nid(nid) << " " << graph->get_all_display_ids_of_node(nid)[0] << endl;
                        }
                    }

                                     
                }
                
                else if (type == "noderelax") {
                    tokens.pop_front();
                    int nid = stoi(tokens.front());
                                        
                    getline(ifs, value);
                    if (value.find("true") != std::string::npos) {
                        relaxed_nodes_repids << graph->get_rep_id_from_nid(nid) << " " << graph->get_all_display_ids_of_node(nid)[0] << endl;
                    }
                                       
                }
                
                
                else if (type == "edge") {
                    tokens.pop_front();
                    int eid = stoi(tokens.front());
                    
                    getline(ifs, value);

                    if (value.find("true") != std::string::npos) {
                        eids_present.insert(eid);
                        string new_var = "__" + var;
                        eid_to_value_pairs.insert(pair<int, bool>(eid, true));
                    }
                    else {
                        eids_to_remove.insert(eid);
                        string new_var = "__" + var;
                        eid_to_value_pairs.insert(pair<int, bool>(eid, false));
                    }
                                                        
                } 
                
                
               
                else if (type == "edgerelax") {
                    tokens.pop_front();
                    int eid = stoi(tokens.front());
                    
                    int src_nid = graph->get_source_node(eid);
                    assert (src_nid != -1);
                    int tgt_nid = graph->get_target_node(eid);
                    assert (tgt_nid != -1);
                    
                    
                    getline(ifs, value);
                            
                    if (value.find("true") != std::string::npos) {
                        vector<string> type_vec = graph->get_edge_subtypes_of_edge(eid);
                        if(type_vec.empty())
                            type_vec.push_back("-");
                        string all_types_as_string = concatenate_strings(type_vec, "_");
                        
                        relaxed_edges_repids << graph->get_rep_id_from_nid(src_nid)<< " " << all_types_as_string << " " << graph->get_rep_id_from_nid(tgt_nid) << endl;
                        relaxed_edges_readable << graph->get_all_display_ids_of_node(src_nid)[0] << " " << all_types_as_string << " " << graph->get_all_display_ids_of_node(tgt_nid)[0] << endl;
                        
                    }

                } 
                
                
                else if (type == "nodedistance") {
                    continue;
                }
                
                else {
                    continue;
                }
                
                
            }
            
        }

        
        ifs.close();
    } else {
        cout << "Unable to open z3 output file";
        return;
    }
    connect.close();
    nodes.close();
    edges.close();

    soln_counter++;
    
//    int subgraph_gid = graph_man->select_operation_on_graph(graphnum, node_repids_present);
//    //int subgraph_gid = get_subgraph_edges_removed(graph->get_graph_id(), eids_to_remove);
//    
//    cout << "\nResultant subgraph id: " << subgraph_gid << endl;

}

void GraphManagerNew::count_smt_solutions(t_ExpressionManager * em, GraphNew * graph, string file_prefix, int soln_bound) {
    
    
    string smt_count_filename = file_prefix + ".smt2";
    string smt_count_out_filename = file_prefix + "_smt_output";
    string z3_count_error_filename = file_prefix + "_smt_error";

    string header_count_filename = file_prefix + "_header";
    string footer_count_filename = file_prefix + "_footer";
    string decl_count_filename = file_prefix + "_decl";
    string cons_count_filename = file_prefix + "_cons";
    string bound_count_filename = file_prefix + "_bound";
    string bound_count_cons_filename = file_prefix + "_bound_cons";

    string neg_soln_filename = file_prefix + "_neg_soln_cons";
    string neg_soln_filename_decl = file_prefix + "_neg_soln_decl";
    // write header and footer files
    ofstream header_fout(header_count_filename.c_str());
    ofstream footer_fout(footer_count_filename.c_str());

    header_fout << "(set-info :smt-lib-version 2.0)\n" << endl;
    footer_fout << "\n(check-sat)\n(get-model)\n(exit)\n" << endl;

    header_fout.close();
    footer_fout.close();
            
    int num_of_solns = 0;
    
    map<int, bool> nid_to_value_pairs;
    map<int, bool> eid_to_value_pairs;
    
    t_Expression * negated_soln_expression;
    smt_count_out_filename = file_prefix + "_smt_output";
    
    
    do {
        
            time_t time1, time2;
            double time_in_sec;
            time(&time1);
            
            

        cout << "Finding soln " << num_of_solns + 1 << " .." << endl;
        
        
        
        string run_z3_cmd = "timeout " + IntToString(TIMEOUT_IN_SEC) + " " + "z3" + " -smt2 " + smt_count_filename + " > " + smt_count_out_filename;
      
        time(&time2);
        system(run_z3_cmd.c_str());
        time(&time2);
        
        time_in_sec = difftime(time2, time1);
        
#ifdef DEBUG_FLAG                            
    debug_log << "Itearation  :" << endl;
#endif      

        
        string is_sat = process_smt_answer(graph, smt_count_out_filename);
        if (is_sat != "SAT") {
            cout << "No more solutions" << endl;
            break;
        }

        if (num_of_solns > soln_bound) {
            cout << "More than " << soln_bound << " solutions" << endl;
            break;
        }
        
        
        
        nid_to_value_pairs.clear();
        eid_to_value_pairs.clear();
        set<int> up_reg_nids;
        
        process_smt_output(graph, file_prefix, smt_count_out_filename, up_reg_nids, nid_to_value_pairs, eid_to_value_pairs, "z3");
        
        
        
        ofstream neg_soln_fout(neg_soln_filename.c_str());
        get_negated_solution_expression1(em, nid_to_value_pairs, negated_soln_expression, file_prefix, neg_soln_fout);
        neg_soln_fout.close();
        
        
        string system_command2 = "cat " + neg_soln_filename + " >> " + cons_count_filename;
        system(system_command2.c_str());
        
        
        
        num_of_solns++;
        
        //string system_command1 = "cat " + header_count_filename + " " + decl_count_filename + " " + cons_count_filename + " " + bound_count_cons_filename + " " + footer_count_filename + " > " + smt_count_filename;
        string system_command1 = "cat " + header_count_filename + " " + decl_count_filename + " " + cons_count_filename + " " +  footer_count_filename + " > " + smt_count_filename;
        
        system(system_command1.c_str());
        
    } while (true);
    
    cout << num_of_solns << " solutions found" << endl;
    
}
//////
//////void GraphManagerNew::count_smt_solutions_with_z3(bool b_mode, z3::context& c, z3::solver& s, map<string, z3::expr>& all_z3_var_to_expr_map, string file_prefix, GraphNew * graph, int soln_bound) {
//////
//////            
//////    int num_of_solns = 0;
//////    
//////    map<string, bool> var_value_pairs;
//////    t_Expression * negated_soln_expression;
//////    
//////    z3::check_result sat_state;
//////    
//////    int map_size = all_z3_var_to_expr_map.size();
//////    set<int> edge_eids;
//////    
//////    string all_result_gids_filename = file_prefix + "_all_solns_gids.txt";
//////    ofstream file_out (all_result_gids_filename.c_str());
//////    
//////    do {
//////        
//////        time_t time1, time2;
//////        double time_in_sec;
//////        time(&time1);
//////            
//////            
//////
//////        cout << "Finding soln " << num_of_solns + 1 << " .." << endl;
//////        
//////        time(&time2);
//////        sat_state = s.check();
//////        time(&time2);
//////        
//////        time_in_sec = difftime(time2, time1);
//////        
//////#ifdef DEBUG_FLAG                            
//////        debug_log << "Iteration  : " << num_of_solns + 1 << endl;
//////#endif      
//////
//////        
//////        
//////        if (sat_state != z3::sat) {
//////            cout << "No more solutions" << endl;
//////            break;
//////        }
//////
//////        if (num_of_solns > soln_bound) {
//////            cout << "More than " << soln_bound << " solutions" << endl;
//////            break;
//////        }
//////        
//////        try {
//////            z3::model m = s.get_model();
//////            
//////            int num_constants = m.num_consts();
//////            //assert(num_constants == all_z3_expr_vec.size());
//////            z3::expr neg_expr = c.bool_val(true);
//////
//////            for (auto i = all_z3_var_to_expr_map.begin(); i != all_z3_var_to_expr_map.end(); i++) {
//////                z3::expr ex = i->second;
//////                if (ex.is_bool()) {
//////                    
//////                    z3::expr val = m.eval(ex);
//////                    //neg_expr = neg_expr && (ex == val);
//////                    
//////                    if (val) {
//////                    
//////                        string var = i->first;
//////                        
//////                        string edge_var_prefix = "__edge_";
//////                        int edge_id;
//////                        
//////                        std::size_t pos = var.find(edge_var_prefix);
//////                        if (pos != std::string::npos) {
//////                            edge_id = stringToInteger(std::string(var.begin() + edge_var_prefix.size(), var.end()));
//////                            
//////                            if (eq(m.eval(ex),c.bool_val(true)) )
//////                                edge_eids.insert(edge_id);
//////                            
//////                            neg_expr = neg_expr && (ex == val);
//////                        }
//////                        
//////                    }
//////                }
//////            }
//////            
//////            int new_gid = get_subgraph_with_edge_ids(graph, edge_eids);
//////            
//////            edge_eids.clear();
//////            
//////            GraphNew * new_graph = get_graph(new_gid);
//////            if (new_graph == NULL) {
//////                cerr << "NULL graph" << endl;
//////                continue;
//////            }
//////            
//////            file_out << new_gid << "\t";
//////            
////////            int soln_counter = num_of_solns + 1;
////////            string filename = file_prefix + "_soln" + soln_counter + ".xml";
////////            ofstream fout(filename.c_str());
////////            if (fout.is_open()) {
////////               new_graph->write_to_xml_file(fout, b_mode, "KEGG");
////////               file_out << filename << " y" << " 1" << endl;
////////            }
//////            
//////
//////            s.add(!neg_expr);
//////           
//////        } catch (z3::exception &e) {
//////            cerr << "Z3 exception in GraphManagerNew::count_smt_solutions_with_z3: " << e.msg() << endl;
//////        }
//////
//////        
//////        num_of_solns++;
//////        
//////        
//////    } while (true);
//////    
//////    cout << num_of_solns << " solutions found" << endl;
//////    file_out.close();
//////}


void GraphManagerNew::solve_mincut_constraints(t_ExpressionManager * em, GraphNew * graph, string file_prefix, int num_of_nodes_bound, int num_of_edges_bound, int path_length_bound, int node_status_relax_bound, int edge_status_relax_bound, int choice, int up_reg_down_reg_size, string smt_solver) {
    string smt_filename = file_prefix + ".smt2";
    string smt_out_filename = file_prefix + "_smt_output";
    string smt_error_filename = file_prefix + "_smt_error";

    string header_filename = file_prefix + "_header";
    string footer_filename = file_prefix + "_footer";
    string decl_filename = file_prefix + "_decl";
    string cons_filename = file_prefix + "_cons";
    string bound_filename = file_prefix + "_bound";
    string bound_cons_filename = file_prefix + "_bound_cons";

    // write header and footer files
    ofstream header_fout(header_filename.c_str());
    ofstream footer_fout(footer_filename.c_str());

    header_fout << "(set-logic QF_BV)\n" << endl;
    header_fout << "(set-info :smt-lib-version 2.0)\n" << endl;
    header_fout << "(set-option :produce-models true)\n" << endl;
    if (smt_solver == "cvc4")
        header_fout << "(set-logic ALL_SUPPORTED)\n" << endl;
    
    footer_fout << "\n(check-sat)\n(get-model)\n(exit)\n" << endl;

    header_fout.close();
    footer_fout.close();

    bool is_sat = false;
    bool rewrite_smt_flag = true;


    // value hard-coded temporarily - remove later
    // relaxation bound
////    int node_status_relax_bound = 0;
////    int edge_status_relax_bound = 0;
    binary_search_for_exact_bound(em, graph, file_prefix, num_of_nodes_bound, num_of_edges_bound, path_length_bound, node_status_relax_bound, edge_status_relax_bound, choice, up_reg_down_reg_size, smt_solver);

}

void GraphManagerNew::binary_search_for_exact_bound(t_ExpressionManager * em, GraphNew * graph, string file_prefix, int num_of_nodes_bound, int num_of_edges_bound, int path_length_bound, int node_status_relax_bound, int edge_status_relax_bound, int choice, int up_reg_down_reg_size, string smt_solver) {
    
    SMT_solver solver = convert(smt_solver);
    int relax_bound = node_status_relax_bound + edge_status_relax_bound;
    
    string bin_search_report = file_prefix + "_bin_search_report";
    string smt_filename = file_prefix + ".smt2";
    string smt_out_filename = file_prefix + "_smt_output";
    string smt_error_filename = file_prefix + "_smt_error";

    string header_filename = file_prefix + "_header";
    string footer_filename = file_prefix + "_footer";
    string decl_filename = file_prefix + "_decl";
    string cons_filename = file_prefix + "_cons";
    string bound_filename = file_prefix + "_bound";
    string bound_cons_filename = file_prefix + "_bound_cons";

    int upper_bound_cur = 1;
    int upper_bound_prev = 0;
    int highest_unsat_bound_seen = 0;
    int highest_sat_bound_seen = inf;

    int lowest_sat_bound_seen = 0;

    sat_state_t sat_state = UNDEFINED;
    sat_state_t sat_state_prev = UNDEFINED;

    
    ofstream fout_report(bin_search_report.c_str());
    ifstream fin;
    bool loop_forever = true;

    fout_report << endl;

    do {
        vector<pair<string, int> > var_value_pairs;
        vector<t_Expression *> assertion_expression_vec;


        loop_forever = false;
        upper_bound_cur = 1;
        upper_bound_prev = 0;
        highest_unsat_bound_seen = 0;

        while (true) {

            if (choice == BIN_SEARCH_ON_NODE_BOUND)
                num_of_nodes_bound = upper_bound_cur;
            else if (choice == BIN_SEARCH_ON_EDGE_BOUND)
                num_of_edges_bound = upper_bound_cur;
            else if (choice == BIN_SEARCH_ON_PATH_BOUND)
                path_length_bound = upper_bound_cur;
            else if (choice == BIN_SEARCH_ON_NODE_RELAX_BOUND)
                node_status_relax_bound = upper_bound_cur;
            else if (choice == BIN_SEARCH_ON_EDGE_RELAX_BOUND)
                edge_status_relax_bound = upper_bound_cur;
            else if (choice == NO_BIN_SEARCH) {
                upper_bound_cur = num_of_nodes_bound;
            } else if (choice == EXPERIMENTAL) {
                num_of_nodes_bound = upper_bound_cur;
            }
            var_value_pairs.clear();
            assertion_expression_vec.clear();
            var_value_pairs.push_back(pair<string, int>("__nodebound", num_of_nodes_bound));
            var_value_pairs.push_back(pair<string, int>("__edgebound", num_of_edges_bound));
            var_value_pairs.push_back(pair<string, int>("__pathbound", path_length_bound));
            var_value_pairs.push_back(pair<string, int>("__nodestatusrelaxbound", node_status_relax_bound));
            var_value_pairs.push_back(pair<string, int>("__edgestatusrelaxbound", edge_status_relax_bound));
//            var_value_pairs.push_back(pair<string, int>("__relax-bound", relax_bound));
            
            
            
            ofstream bound_fout(bound_cons_filename.c_str());
            
            t_Expression * num_of_nodes_bound_expr = em->createIntegerConstant(num_of_nodes_bound, NODE_BOUND_BIT_LENGTH(graph));
            string num_of_nodes_bound_value_str = em->getLabelOfExpression(num_of_nodes_bound_expr);
            bound_fout << "(assert (= __nodebound #" + num_of_nodes_bound_value_str.substr(1) + "))\n";
            
            t_Expression * num_of_edges_bound_expr = em->createIntegerConstant(num_of_edges_bound, EDGE_BOUND_BIT_LENGTH(graph));
            string num_of_edges_bound_value_str = em->getLabelOfExpression(num_of_edges_bound_expr);
            bound_fout << "(assert (= __edgebound #" + num_of_edges_bound_value_str.substr(1) + "))\n";
            
            t_Expression * path_length_bound_expr = em->createIntegerConstant(path_length_bound, PATH_BOUND_BIT_LENGTH(path_length_bound));
            string path_length_bound_value_str = em->getLabelOfExpression(path_length_bound_expr);
            bound_fout << "(assert (= __pathbound #" + path_length_bound_value_str.substr(1) + "))\n";
            
            t_Expression * node_status_relax_bound_expr = em->createIntegerConstant(node_status_relax_bound, NODE_RELAX_BOUND_BIT_LENGTH(up_reg_down_reg_size));
            string node_status_relax_bound_value_str = em->getLabelOfExpression(node_status_relax_bound_expr);
            bound_fout << "(assert (= __nodestatusrelaxbound #" + node_status_relax_bound_value_str.substr(1) + "))\n";
            
            t_Expression * edge_status_relax_bound_expr = em->createIntegerConstant(edge_status_relax_bound, EDGE_RELAX_BOUND_BIT_LENGTH(graph));
            string edge_status_relax_bound_value_str = em->getLabelOfExpression(edge_status_relax_bound_expr);
            bound_fout << "(assert (= __edgestatusrelaxbound #" + edge_status_relax_bound_value_str.substr(1) + "))\n";
            
            // temporarily asserting absence of PIK3R5
//            int pik3r5_nid = graph->get_nid_from_rep_id(graph->get_rep_id_from_id("hsa23533"));
//            assert (pik3r5_nid != -1);
//            bound_fout << "(assert (not __node_" << pik3r5_nid << "))" << endl;
//            cout << "PIK3R5 asserted absent" << endl;
            
//            int akt_nid = graph->get_nid_from_rep_id(graph->get_rep_id_from_id("hsa10000"));
//            assert (akt_nid != -1);
//            bound_fout << "(assert (not __node_" << akt_nid << "))" << endl;
//            cout << "AKT asserted absent" << endl;
            
            bound_fout.close();

            string system_command1 = "cat " + header_filename + " " + decl_filename + " " + cons_filename + " " + bound_cons_filename + " " + footer_filename + " > " + smt_filename;
            system(system_command1.c_str());

            string run_z3_cmd = "";
            
            switch (solver) {
                case Z3:
                    smt_solver = Z3_PATH_NAME;
                    run_z3_cmd = "timeout " + IntToString(TIMEOUT_IN_SEC) + " " + smt_solver + " -smt2 " + smt_filename + " > " + smt_out_filename;
                    break;


                case CVC4:
                    run_z3_cmd = "timeout " + IntToString(TIMEOUT_IN_SEC) + " " + smt_solver + " --lang smt " + smt_filename + " > " + smt_out_filename;
                    break;


                case BOOLECTOR:
                    run_z3_cmd = "timeout " + IntToString(TIMEOUT_IN_SEC) + " " + smt_solver + " " + smt_filename + " > " + smt_out_filename;
                    break;

                default:
                    run_z3_cmd = "timeout " + IntToString(TIMEOUT_IN_SEC) + " " + smt_solver + " " + smt_filename + " > " + smt_out_filename;
                    
            }

            cout << run_z3_cmd << endl;

            time_t time1, time2;
            double time_in_sec;
            time(&time1);
            system(run_z3_cmd.c_str());
            time(&time2);
            time_in_sec = difftime(time2, time1);

            string is_sat = process_smt_answer(graph, smt_out_filename);


            //fout_report << "\nUpper bound : " << upper_bound_cur << endl;
            fout_report << " (" << upper_bound_cur;
            // double to string
            std::ostringstream time_ss;
            time_ss << time_in_sec;
            std::string time_str = time_ss.str();
            //fout_report << "\nTime taken : " << time_str << endl;
            fout_report << "," << time_str << ") "; // << endl;

            if (is_sat == "SAT") {
                sat_state = SAT;
                fout_report << "SAT" << endl;

            } else if (is_sat == "UNSAT") {
                sat_state = UNSAT;
                fout_report << "UNSAT" << endl;
            } else {
                sat_state = TIMEOUT;
                fout_report << "timed out" << endl;
            }




            if (choice == NO_BIN_SEARCH)
                break;

            //if (strict_sat_boundaries) {
            if (choice != EXPERIMENTAL) {
                if (sat_state == SAT || sat_state == TIMEOUT) {
                    if ((upper_bound_cur - highest_unsat_bound_seen) == 1) {
                        break;
                    } else {
                        sat_state_prev = sat_state;
                        sat_state = UNDEFINED;
                        int temp = upper_bound_cur;
                        upper_bound_cur = (highest_unsat_bound_seen + upper_bound_cur) / 2;
                        upper_bound_prev = temp;
                    }
                } else if (sat_state == UNSAT) {
                    if (sat_state_prev == UNSAT || sat_state_prev == UNDEFINED) {
                        sat_state_prev = UNSAT;
                        sat_state = UNDEFINED;
                        highest_unsat_bound_seen = upper_bound_cur;
                        upper_bound_prev = upper_bound_cur;
                        upper_bound_cur = 2 * upper_bound_prev;
                    } else if (sat_state_prev == TIMEOUT || sat_state_prev == SAT) {
                        sat_state_prev = UNSAT;
                        sat_state = UNDEFINED;
                        if (upper_bound_prev - upper_bound_cur == 1) {
                            highest_unsat_bound_seen = upper_bound_cur;
                            upper_bound_prev = upper_bound_cur;
                            upper_bound_cur++;
                        } else {
                            if (highest_unsat_bound_seen < upper_bound_cur) {
                                highest_unsat_bound_seen = upper_bound_cur;
                            }
                            int temp = upper_bound_cur;
                            upper_bound_cur = (upper_bound_prev + upper_bound_cur) / 2;
                            upper_bound_prev = temp;
                        }
                    } else {
                        assert(false);
                    }
                } else {
                    assert(false);
                }
            }

            else if (choice == EXPERIMENTAL) {
                upper_bound_cur += 2;
                if (upper_bound_cur > 1000)
                    break;
            }
            else {
                if (sat_state == SAT) {
                    break;
                } else if (sat_state == UNSAT || sat_state == TIMEOUT) {
                    sat_state_prev = sat_state;
                    sat_state = UNDEFINED;
                    upper_bound_prev = upper_bound_cur;
                    highest_unsat_bound_seen = upper_bound_cur;
                    upper_bound_cur *= 2;
                } else {
                    cerr << "Error: sat state must be one of SAT, UNSAT, TIMEOUT at this stage" << endl;
                    assert(false);
                }
            }

        }


        if (choice == NO_BIN_SEARCH)
            break;

    } while (loop_forever);



}

//void GraphManagerNew::get_common_nodes_from_graphs(set <int>& graph_set, map<string, int>& rep_id_to_freq_map) {
//    
//    for (auto graph_iter = graph_set.begin(); graph_iter != graph_set.end(); graph_iter++){
//        
//        GraphNew * graph = get_graph(*graph_iter);
//        if (graph == NULL)
//            cout << "NULL graph" << endl;
//        
//        vector<int> nids = graph->get_node_ids();
//        
//        for (auto n_iter = nids.begin(); n_iter != nids.end(); n_iter++) {
//            int curr_nid = *n_iter;
//            
//            string curr_node_rep_id = graph->get_rep_id_from_nid(curr_nid);
//            
//            if (curr_node_rep_id == "hsa23533")
//                cout << "PIK3R5 is in gid " << *graph_iter << endl;
//            
//            auto iter = rep_id_to_freq_map.find(curr_node_rep_id);
//            if (iter == rep_id_to_freq_map.end())
//                rep_id_to_freq_map.insert(pair<string, int>(curr_node_rep_id, 1));
//            else {
//                iter->second++;
//            }
//        }
//    }
//    
//    cout << "PIK3R5 freq " << rep_id_to_freq_map["hsa23533"] << endl;
//    cout << "AKT3 freq " << rep_id_to_freq_map["hsa10000"] << endl;
//}

void GraphManagerNew::get_common_nodes_from_graphs(set <int>& graph_set, map<string, set<int> >& rep_id_to_gid_set_map) {
    
    for (auto graph_iter = graph_set.begin(); graph_iter != graph_set.end(); graph_iter++){
        
        GraphNew * graph = get_graph(*graph_iter);
        if (graph == NULL)
            cout << "NULL graph" << endl;
        
        vector<int> nids = graph->get_node_ids();
        
        for (auto n_iter = nids.begin(); n_iter != nids.end(); n_iter++) {
            int curr_nid = *n_iter;
            
            string curr_node_rep_id = graph->get_rep_id_from_nid(curr_nid);
            
            
            rep_id_to_gid_set_map[curr_node_rep_id].insert(*graph_iter);
            
        }
    }
    
}


//void GraphManagerNew::get_common_edges_from_graphs(set <int>& graph_set, map<string, int>& edge_to_freq) {
//    
//    for (auto graph_iter = graph_set.begin(); graph_iter != graph_set.end(); graph_iter++){
//        if (*graph_iter == -1)
//            continue;
//        GraphNew * graph = get_graph(*graph_iter);
//        vector<int> eids = graph->get_edge_ids();
//        
//        for (auto e_iter = eids.begin(); e_iter != eids.end(); e_iter++) {
//            int curr_eid = *e_iter;
//            vector<string> types_vec = graph->get_edge_subtypes_of_edge(curr_eid);
//            sort(types_vec.begin(), types_vec.end());
//            string subtypes_str = concatenate_strings(types_vec,"_");
//            //string edge_name_str = graph->get_rep_id_from_nid(graph->get_source_node(curr_eid)) + "__" + subtypes_str + "__" + graph->get_rep_id_from_nid(graph->get_target_node(curr_eid));
//            string edge_name_str = graph->get_rep_id_from_nid(graph->get_source_node(curr_eid)) + "__" + graph->get_rep_id_from_nid(graph->get_target_node(curr_eid));
//            
//            auto iter = edge_to_freq.find(edge_name_str);
//            if (iter == edge_to_freq.end())
//                edge_to_freq.insert(pair<string, int>(edge_name_str, 1));
//            else {
//                iter->second++;
//            }
//        }
//    }
//    
//    
//}

void GraphManagerNew::get_common_edges_from_graphs(set <int>& graph_set, map<string, set<int> >& edge_to_gid_set_map) {
    
    for (auto graph_iter = graph_set.begin(); graph_iter != graph_set.end(); graph_iter++){
        if (*graph_iter == -1)
            continue;
        GraphNew * graph = get_graph(*graph_iter);
        vector<int> eids = graph->get_edge_ids();
        
        for (auto e_iter = eids.begin(); e_iter != eids.end(); e_iter++) {
            int curr_eid = *e_iter;
            
            string edge_name_str = graph->get_rep_id_from_nid(graph->get_source_node(curr_eid)) + "__" + graph->get_rep_id_from_nid(graph->get_target_node(curr_eid));
            
            edge_to_gid_set_map[edge_name_str].insert(*graph_iter);
        }
    }
    
    
}

void GraphManagerNew::get_common_nodes_from_merged_graph(GraphNew * merged_graph, set<string>& source_nodes_set, set<string>& target_nodes_set, map<string, set<int> >& node_to_gid_set_map, int relax_cutoff) {
    
    
    int max_freq = 0;
    for (auto i = node_to_gid_set_map.begin(); i != node_to_gid_set_map.end(); i++) {
        if (max_freq <= i->second.size())
            max_freq = i->second.size();
    }
    
    cout << "max_freq " << max_freq << endl;
    
    //float relax_cutoff_pc = 100 * (1.0 / relax_cutoff);
    float relax_cutoff_pc = relax_cutoff / 100.0;
    cout << "relax_cutoff_pc " << relax_cutoff_pc << endl;
    
    int cutoff = (int) (max_freq * relax_cutoff_pc);
    cout << "cutoff " << cutoff << endl;
    
    
    vector<int> nids = merged_graph->get_node_ids();
    
    
    for(auto i = node_to_gid_set_map.begin(); i != node_to_gid_set_map.end(); i++) {
        if (i->second.size() >= cutoff)
            cout << merged_graph->get_all_display_ids_of_node(merged_graph->get_nid_from_rep_id(i->first))[0] << endl;
            
    }
    
    cout << endl;
}


void GraphManagerNew::get_subgraph_from_common_edges(GraphNew * merged_graph, set<string>& source_nodes_set, set<string>& target_nodes_set, map<string, set<int> >& edge_to_gid_set_map, int relax_cutoff) {
    int new_gid = -1;
    
    string filename = "cpaths_colorfile";
    ofstream color_out(filename.c_str());
    
    int max_freq = 0;
    for(auto i = edge_to_gid_set_map.begin(); i != edge_to_gid_set_map.end(); i++) {
        if (max_freq <= i->second.size())
            max_freq = i->second.size();
    }
    
    cout << "max_freq " << max_freq << endl;
    
    //float relax_cutoff_pc = 100 * (1.0 / relax_cutoff);
    float relax_cutoff_pc = relax_cutoff / 100.0;
    cout << "relax_cutoff_pc " << relax_cutoff_pc << endl;
    
    int cutoff = (int) (max_freq * relax_cutoff_pc);
    cout << "cutoff " << cutoff << endl;
    
    
    vector<int> eids = merged_graph->get_edge_ids();
    set<int> present_eids_of_mgraph;
    
    for(auto i = edge_to_gid_set_map.begin(); i != edge_to_gid_set_map.end(); i++) {
        list<string> list_of_tokens;
        if (i->second.size() >= cutoff) {
            
            split_string_into_list(i->first, "__", list_of_tokens);
            
            string curr_src_repid = list_of_tokens.front();
            list_of_tokens.pop_front();
            string curr_tgt_repid = list_of_tokens.front();
            list_of_tokens.pop_front();
            
            color_out << curr_src_repid << " " << curr_tgt_repid << " 255 0 0" << endl;
        }
            
    }
    
   
}



//anjan 05-01-2017 -- Brandes's algo to compute betweenness centrality in unweighted graph

void GraphManagerNew::compute_Betweenness_centrality(GraphNew * original_graph, map<pair<int, int>, double> &CB_edge) {
    int num_of_nodes = original_graph->get_node_ids().size(); //get the number of nodes
    vector<double> CB(num_of_nodes); //CB is the Betweenness centrality for nodes


    for (int i = 0; i < num_of_nodes; i++) {
        stack<int> S;
        vector < list<int >> w_list(num_of_nodes + 1);
        vector<int> sigma(num_of_nodes + 1); //sigma(w) stands for number of shortest path from s to w
        vector<int> distance(num_of_nodes + 1); //distance(w) stands for distance from s to w
        queue<int> Q;
        fill(sigma.begin(), sigma.end(), 0);
        fill(distance.begin(), distance.end(), -1);
        //int s = GET_NODE_ID(original_graph, i);
        int s = i;
        sigma[s] = 1;
        distance[s] = 0;
        Q.push(s);
        while (!Q.empty()) {
            int v = Q.front();
            Q.pop();
            S.push(v);
            vector<int> outlist = original_graph->get_outlist(GET_NODE_ID(original_graph, v));
            for (vector<int> ::iterator itr = outlist.begin(); itr != outlist.end(); itr++) {
                int w = GET_NODE_SEQ_NUM(original_graph, original_graph->get_target_node(*itr));
                //int w = original_graph->get_target_node(*itr);
                //w found for the first time?
                if (distance[w] < 0) {
                    Q.push(w);
                    distance[w] = distance[v] + 1;
                }
                //shortest path to w via v
                if (distance[w] == distance[v] + 1) {
                    sigma[w] = sigma[w] + sigma[v];
                    w_list[w].push_front(v);
                }
            }
        }
        vector<double> delta(num_of_nodes + 1);
        //S returns vertices in order of non-increasing distance from s
        while (!S.empty()) {
            int w = S.top();
            S.pop();
            double coeff = (double) (1.0 + delta[w]) / sigma[w];
            for (list<int> ::iterator itr = w_list[w].begin(); itr != w_list[w].end(); itr++) {
                int v = *itr;
                double c = sigma[v] * coeff;
                int v_eid = GET_NODE_ID(original_graph, w);
                int w_eid = GET_NODE_ID(original_graph, v);
                if (CB_edge.find(make_pair(v_eid, w_eid)) == CB_edge.end()){
                    CB_edge[make_pair(w_eid, v_eid)] += c;
                    CB_edge[make_pair(v_eid, w_eid)] = CB_edge[make_pair(w_eid, v_eid)];
                }else{
                    CB_edge[make_pair(v_eid, w_eid)] += c;
                    CB_edge[make_pair(w_eid, v_eid)] = CB_edge[make_pair(v_eid, w_eid)];
                }

                delta[v] = delta[v] + c;
            }
            if (w != s) {
                CB[w] = CB[w] + delta[w];
            }
        }
    }
    /*for(int i=0;i<num_of_nodes;i++){
            cout<<i<<" has betweenness centrality: "<<CB[i]<<endl;
    }*/
    for(map<pair<int, int>, double>::iterator itr = CB_edge.begin(); itr!=CB_edge.end(); itr++){
            cout<<get<0>(itr->first)<<"-"<<get<1>(itr->first)<<":"<<itr->second<<endl;

    }

}


//anjan 20-jan-2017 - assign path
int GraphManagerNew::mincut_ford_extended(GraphNew * original_graph, GraphNew ** res_graph , int i, int j, int N, set<int>& set_s, map<int, int>& map1, map<string, long int>& map2, vector<bool>& path_flag, map<int, int>& eid_to_path_map){
	static GraphNew * residual_graph;
	static int num_of_nodes, new_gid, itr_no;
	static map<int, int> map_nseq_to_res_graph_nid;
	unordered_map<int, int> pred;
	unordered_map<int, int> pred_edge;
	static map<string, long int> map_src_tgt_to_eid;
	static vector < vector<bool>> edge_exist(N + 1, vector<bool>(N + 1));
	vector<int> q(N + 1);
	vector<bool> is_outgoing_edges_explored(N + 1);
	int result = 0;

	itr_no++; //node 0 has no out-list in original graph. due to mismatch in the original graph, we need to take this.
	//create the gra[h at the first iteration
	if (itr_no == 1) {
		residual_graph = new GraphNew;
		num_of_nodes = N;
		new_gid = ++GraphManagerNew::graph_id_count;
		residual_graph->set_graph_id(new_gid);
		add_graph(new_gid, residual_graph);
                
                // populate adjacency matrix
                //fill_adj_matrix_for_graph(residual_graph);
	}

	int src = GET_NODE_ID(original_graph, i);
	int sink = GET_NODE_ID(original_graph, j);

	//cout << i << "---" << j << endl;
	//create node i and j
	int new_nid = create_node(itr_no, i, residual_graph, map_nseq_to_res_graph_nid, N, original_graph->get_outlist(src).size());
	create_node(itr_no, j, residual_graph, map_nseq_to_res_graph_nid, 0, 0);

	pred[i] = -1;
	pred_edge[i] = -1;
	int v_org = j;
	while(ford_BFS(original_graph, residual_graph, is_outgoing_edges_explored, map_nseq_to_res_graph_nid, map_src_tgt_to_eid, edge_exist, q, src, sink, itr_no, pred, pred_edge)){
		//find the min capacity in the path

		//augmentinng the min capacity in the path
		while(pred[v_org] != -1){
			int u_org = pred[v_org]; //
			int res_edge = pred_edge[v_org];
			int src_res = residual_graph->get_source_node(res_edge);
			int v_res = residual_graph->get_target_node(res_edge);
			int curr_edge_flow = residual_graph->get_other_value2_in_edge(res_edge);
			//got a path
			int org_edge = residual_graph->get_other_value4_in_edge(res_edge);
			eid_to_path_map.insert(pair<int, int>(org_edge, result+1));
			// update capacity
			residual_graph->set_other_value2_in_edge(res_edge, curr_edge_flow - 1); //1 will be changed later
			int rev_edge_id = get_node_from_src_tgt(v_res, src_res, map_src_tgt_to_eid);
			int rev_edge_flow = residual_graph->get_other_value2_in_edge(rev_edge_id);
			residual_graph->set_other_value2_in_edge(rev_edge_id, rev_edge_flow + 1);

			v_org = u_org;

		}
		pred.clear();
		pred_edge.clear();
		pred[i] = -1;
		pred_edge[i] = -1;
		v_org = j;

		result++;
		path_flag[result] = true;
	}

	set_s.insert(i);
	//get_min_cut_edges(original_graph, residual_graph, map_nseq_to_res_graph_nid, i, j, cut_edges, set_s, map_src_tgt_to_eid);
	//cout<<endl<<result<<endl;

	map1 = map_nseq_to_res_graph_nid;
	map2 = map_src_tgt_to_eid;
	*res_graph = residual_graph;
	return result;
}

void GraphManagerNew::populate_map_src_tgt_to_eid(GraphNew *graph, map<string, long int>& map_src_tgt_to_eid, int start_node){
	//make a bfs search to get all the edges
	set<int> visited;
	list<int> bfs_queue;
	int start_node_id = start_node;

	bfs_queue.push_back(start_node_id);
	while (!bfs_queue.empty()) {
		int curr_node = bfs_queue.front();
		bfs_queue.pop_front();
		if (visited.find(curr_node) == visited.end()) {// can be make more efficient by taking a boolean vector work as a flag
			visited.insert(curr_node);
			// traverse outlist
			vector<int> outlist_of_node = graph->get_outlist(curr_node);
			for (vector<int>::iterator outlist_of_i_itr = outlist_of_node.begin(); outlist_of_i_itr != outlist_of_node.end(); outlist_of_i_itr++) {
				int curr_edge = (*outlist_of_i_itr);
				//fill the map
				int curr_node_id = graph->get_source_node(curr_edge);
				int succ_node_id = graph->get_target_node(curr_edge);
			    stringstream ss;
			    ss << curr_node_id<<":"<< succ_node_id;
			    map_src_tgt_to_eid.insert(pair<string, long int>(ss.str(), curr_edge));

				bfs_queue.push_back(succ_node_id);
			}
		}
	}


}


void GraphManagerNew::populate_set_s(GraphNew * graph, int start_node_seq, set<int>& set_s){
	set<int> visited;
	list<int> bfs_queue;
	int start_node_id = GET_NODE_ID(graph, start_node_seq);

	bfs_queue.push_back(start_node_id);
	while (!bfs_queue.empty()) {
		int curr_node = bfs_queue.front();
		bfs_queue.pop_front();
		if (visited.find(curr_node) == visited.end()) {// can be make more efficient by taking a boolean vector work as a flag
			visited.insert(curr_node);
			// traverse outlist
			vector<int> outlist_of_node = graph->get_outlist(curr_node);
			for (vector<int>::iterator outlist_of_i_itr = outlist_of_node.begin(); outlist_of_i_itr != outlist_of_node.end(); outlist_of_i_itr++) {
				int curr_edge = (*outlist_of_i_itr);
				if(!graph->get_delete_status_for_edge(curr_edge)&&!NOT_INTERAC_EDGE(graph, curr_edge)&&!graph->edge_has_subtype(curr_edge, "dummy_d_to_u")){
					int succ_node_id = graph->get_target_node(curr_edge);
					set_s.insert(GET_NODE_SEQ_NUM(graph, succ_node_id));
					bfs_queue.push_back(succ_node_id);
				}
			}

		}
	}

}

int GraphManagerNew::mincut_ford_cbp(GraphNew * graph, int src_seq, int target_seq, vector<int> node_ids, set<int>& cut_edges, set<int>& set_s){
	int num_of_nodes = node_ids.size();
	GraphNew *res_graph;
	map<int, int> map_nseq_to_res_graph_nid;
	map<string, long int> map_src_tgt_to_eid_res;
	map<string, long int> map_src_tgt_to_eid_org;
	int start_node_id = node_ids[0];
	vector<bool> path_flag_dyn(num_of_nodes);
	vector<bool> path_flag(num_of_nodes);
	map<int, int>eid_to_path_map_dyn;
	map<int, int>eid_to_path_map;

	cout <<src_seq << "---" << target_seq << endl;
	//calculate max flow
	//populate the map_src_tgt_to_eid_org
	cut_edges.clear();
	set_s.clear();

	populate_map_src_tgt_to_eid(graph, map_src_tgt_to_eid_org, start_node_id);
	int current_size = mincut_ford_extended(graph, &res_graph, src_seq, target_seq, node_ids.size(), set_s, map_nseq_to_res_graph_nid, map_src_tgt_to_eid_res, path_flag, eid_to_path_map);
	//calculate Betweenness_centrality
	map<pair<int, int>, double> CB_edge;
	compute_Betweenness_centrality(graph, CB_edge);
	//collect the CB_edges in a struct and sort them
	struct a
	{
	    double num1;
	    pair<int, int> num2;
	};

	vector<a> sorted_edge;
	//assign the elements in the map to the struct
	int i=0;
	for(map<pair<int, int>, double>::iterator itr = CB_edge.begin(); itr!=CB_edge.end(); itr++){
		sorted_edge.push_back(a());
		sorted_edge[i].num1 = itr->second;
		sorted_edge[i++].num2 = itr->first;
	}

	//sort the array of struct
	//sort(array, array+i, array[0]);
	sort(sorted_edge.begin(), sorted_edge.end(), [](a lhs, a rhs){ return lhs.num1 > rhs.num1; });
	int next_max_index = 0;
	vector < pair<int, int> > balanced_cut_edges;
	bool flag=true;
	while(flag){
		//get the maximum weighted edge
		int src_node_org = get<0>(sorted_edge[next_max_index].num2);
		int target_node_org = get<1>(sorted_edge[next_max_index++].num2);
		//get the edge from it
		int eid = get_node_from_src_tgt(src_node_org, target_node_org, map_src_tgt_to_eid_org);
		//get the path number
		int path_no = eid_to_path_map[eid]; //path_no == 0 means the eid is not assigned to any path
		// If the edge is not belongs to any of the class of path leave it
		//---//For the path, we use a path_flag(boolean) vector
		//If the edge belongs to any class then check deleting this edge reduce mincut value -- no - non-delete the edge, yes - take this edge
		//If the path exists
		if(path_flag[path_no]&&!NOT_INTERAC_EDGE(graph, eid)){
			graph->set_delete_status_for_edge(eid, true);
			int mincut_value = mincut_ford_extended(graph, &res_graph, src_seq, target_seq, node_ids.size(), set_s, map_nseq_to_res_graph_nid, map_src_tgt_to_eid_res, path_flag_dyn, eid_to_path_map_dyn);
			if(mincut_value == 0){
				balanced_cut_edges.push_back(make_pair(src_node_org, target_node_org));
				cut_edges.insert(get_node_from_src_tgt(src_node_org, target_node_org, map_src_tgt_to_eid_org));
				populate_set_s(graph, src_seq, set_s);
				flag = false;
			}else if(current_size > mincut_value){
				balanced_cut_edges.push_back(make_pair(src_node_org, target_node_org));
				cut_edges.insert(get_node_from_src_tgt(src_node_org, target_node_org, map_src_tgt_to_eid_org));
				current_size = mincut_value;
				path_flag[path_no] = false; //to skip all the edges that belongs to the same path
			}else
				graph->set_delete_status_for_edge(eid, false);
		}

	}

	//turn all the edges status in cutedges to nondeleted
	for (set<int>::iterator itr = cut_edges.begin(); itr != cut_edges.end(); itr++){
		//cout<<graph->get_delete_status_for_edge(*itr);
		graph->set_delete_status_for_edge(*itr, false);
	}

}



//Excess-scaling algo --starts - anjan-28-may-2017 - algo is taken from the paper A fast and simple algo for mincut by Ahuja-orlin
int GraphManagerNew::Initialize_preflow(GraphNew * residual_graph, int src_org_id, int tgt_org_id, map<int, int>& map_nseq_to_res_graph_nid){
	int src_res_id = map_nseq_to_res_graph_nid[src_org_id];
    vector<int> outlist = residual_graph->get_outlist(src_res_id);
    for (vector<int>::iterator out_itr = outlist.begin(); out_itr != outlist.end(); out_itr++) {
        int res_eid = *out_itr;
        int res_eid_tgt = residual_graph->get_target_node(res_eid);
        //update node and residual edges
        int curr_edge_capacity = residual_graph->get_other_value2_in_edge(res_eid);
        int flow = curr_edge_capacity;
        int tgt_excess = residual_graph->get_component_ids_of_node(res_eid_tgt)[3];
        int org_tgt_seq = residual_graph->get_component_ids_of_node(res_eid_tgt)[0];
        if(org_tgt_seq != tgt_org_id)
        	residual_graph->update_component_of_node_at_index(res_eid_tgt, 3, tgt_excess + flow);
        residual_graph->set_other_value2_in_edge(res_eid, curr_edge_capacity - flow);
    }
}

int GraphManagerNew::push_node(GraphNew * residual_graph, int res_node_u, int res_eid, int delta, vector<list< int >>& nodeHeightLists, map<int, int>& map_nseq_to_res_graph_nid, map<string, long int>& map_src_tgt_to_eid, int src, int target, int& push_node_count){
	int res_eid_tgt = residual_graph->get_target_node(res_eid);
	int org_seq_tgt = residual_graph->get_component_ids_of_node(res_eid_tgt)[0];
	int tgt_excess = residual_graph->get_component_ids_of_node(res_eid_tgt)[3];
	int curr_excess = residual_graph->get_component_ids_of_node(res_node_u)[3];
	int curr_edge_capacity = residual_graph->get_other_value2_in_edge(res_eid);
	int push_amount = (curr_excess < curr_edge_capacity)? curr_excess : curr_edge_capacity;
	push_amount = (push_amount < (delta - tgt_excess))? push_amount : (delta - tgt_excess);
	//update nodes
	residual_graph->update_component_of_node_at_index(res_node_u, 3, curr_excess - push_amount);
	if((org_seq_tgt != src)&&(org_seq_tgt != target))
		residual_graph->update_component_of_node_at_index(res_eid_tgt, 3, tgt_excess + push_amount);
	//update edge
	residual_graph->set_other_value2_in_edge(res_eid, curr_edge_capacity - push_amount);
	//update residual edge
	int rev_edge_id = get_node_from_src_tgt(res_eid_tgt, res_node_u, map_src_tgt_to_eid);
	int rev_edge_flow = residual_graph->get_other_value2_in_edge(rev_edge_id);
	residual_graph->set_other_value2_in_edge(rev_edge_id, rev_edge_flow + push_amount);

	if(residual_graph->get_component_ids_of_node(res_node_u)[3] <= delta/2){
		//delete this node from nodeHeightLists
		int curr_height = residual_graph->get_component_ids_of_node(res_node_u)[2];
		int org_seq = residual_graph->get_component_ids_of_node(res_node_u)[0];
		nodeHeightLists[curr_height].remove(org_seq);
		push_node_count--;
	}

	if((org_seq_tgt != src)&&(org_seq_tgt != target)&&(residual_graph->get_component_ids_of_node(res_eid_tgt)[3] > delta/2)){
		//add this node to nodeHeightLists if not present
		int curr_height = residual_graph->get_component_ids_of_node(res_eid_tgt)[2];
		bool found = (std::find(nodeHeightLists[curr_height].begin(), nodeHeightLists[curr_height].end(), org_seq_tgt) != nodeHeightLists[curr_height].end());
		if(!found){
			nodeHeightLists[curr_height].push_back(org_seq_tgt);
			push_node_count++;
		}
	}

}

int GraphManagerNew::relabel_node(GraphNew * residual_graph, int res_node_u, vector<list< int >>& nodeHeightLists){
	//delete this node from nodeHeightLists
	int curr_height = residual_graph->get_component_ids_of_node(res_node_u)[2];
	int org_seq = residual_graph->get_component_ids_of_node(res_node_u)[0];
	nodeHeightLists[curr_height].remove(org_seq);
	//find the min-height neighbour
	int min_height = inf;
	vector<int> outlist = residual_graph->get_outlist(res_node_u);
	for (vector<int>::iterator out_itr = outlist.begin(); out_itr != outlist.end(); out_itr++) {
		int res_eid = *out_itr;
		int res_eid_tgt = residual_graph->get_target_node(res_eid);
		int curr_height = residual_graph->get_component_ids_of_node(res_node_u)[2];
		if(curr_height < min_height)
			min_height = curr_height;
	}
	//update res_node_u's height
	residual_graph->update_component_of_node_at_index(res_node_u, 2, min_height+1);
	//add this node to nodeHeightLists
	nodeHeightLists[min_height+1].push_back(org_seq);
}

int GraphManagerNew::select_for_push_relabel(GraphNew * original_graph, GraphNew * residual_graph, int res_node_u, int delta, vector<list< int >>& nodeHeightLists, map<int, int>& map_nseq_to_res_graph_nid, map<string, long int>& map_src_tgt_to_eid, vector<bool>& is_outgoing_edges_explored, vector < vector<bool>>& edge_exist, int src, int target, int itr_no, int& push_node_count){
	bool found = false;
	int res_eid;
	int curr_edge_capacity;
	int tgt_height;
	int curr_height = residual_graph->get_component_ids_of_node(res_node_u)[2];

	int org_seq = residual_graph->get_component_ids_of_node(res_node_u)[0];
    if (is_outgoing_edges_explored[org_seq] == false) {//think as a first time
        get_outgoing_edges_explored(original_graph, residual_graph, map_nseq_to_res_graph_nid, map_src_tgt_to_eid, edge_exist, GET_NODE_ID(original_graph, org_seq), itr_no);
        is_outgoing_edges_explored[org_seq] = true;
    }

	vector<int> outlist = residual_graph->get_outlist(res_node_u);
	for (vector<int>::iterator out_itr = outlist.begin(); out_itr != outlist.end(); out_itr++) {
		//find appropriate edge for push
		res_eid = *out_itr;
		int res_eid_tgt = residual_graph->get_target_node(res_eid);
		curr_edge_capacity = residual_graph->get_other_value2_in_edge(res_eid);

		tgt_height = residual_graph->get_component_ids_of_node(res_eid_tgt)[2];
		if((curr_edge_capacity > 0)&&(curr_height == tgt_height + 1)){
			found = true;
			break;
		}
	}
	if(found)
		push_node(residual_graph, res_node_u, res_eid, delta, nodeHeightLists, map_nseq_to_res_graph_nid, map_src_tgt_to_eid, src, target, push_node_count);
	else
		relabel_node(residual_graph, res_node_u, nodeHeightLists);
}


int GraphManagerNew::mincut_excess_scaling(GraphNew * original_graph, int i, int j, int N, set<int>& cut_edges, set<int>& set_s, int max_cap_edge) {// N is the number of nodes, i is the curr node SEQ, j is the parent node SEQ.
	static GraphNew * residual_graph;
	static int num_of_nodes, new_gid, itr_no;
	static map<int, int> map_nseq_to_res_graph_nid;
	static map<string, long int> map_src_tgt_to_eid;
	static vector < vector<bool>> edge_exist(N + 1, vector<bool>(N + 1));
	vector<int> q(N + 1);
	vector<bool> is_outgoing_edges_explored(N + 1);
	int result = 0;
	int push_node_count =0;
	set<int> node_height_set;

	itr_no++; //node 0 has no out-list in original graph. due to mismatch in the original graph, we need to take this.
	//create the gra[h at the first iteration
	if (itr_no == 1) {
		residual_graph = new GraphNew;
		num_of_nodes = N;
		new_gid = ++GraphManagerNew::graph_id_count;
		residual_graph->set_graph_id(new_gid);
		add_graph(new_gid, residual_graph);
                
                // populate adjacency matrix
                //fill_adj_matrix_for_graph(residual_graph);
	}

	int src = GET_NODE_ID(original_graph, i);
	int sink = GET_NODE_ID(original_graph, j);

	//cout << i << "---" << j << endl;
	//create node i and j
	int new_nid = create_node(itr_no, i, residual_graph, map_nseq_to_res_graph_nid, N, 0);
	create_node(itr_no, j, residual_graph, map_nseq_to_res_graph_nid, 0, 0);
    if (is_outgoing_edges_explored[i] == false) {
        get_outgoing_edges_explored(original_graph, residual_graph, map_nseq_to_res_graph_nid, map_src_tgt_to_eid, edge_exist, GET_NODE_ID(original_graph, i), itr_no);
        is_outgoing_edges_explored[i] = true;
    }
    Initialize_preflow(residual_graph, i, j, map_nseq_to_res_graph_nid);
    int U = ceil(max_cap_edge);
    int delta = pow (2, log2(U));
    vector<list< int >> nodeHeightLists(2*N);

	int src_res_id = map_nseq_to_res_graph_nid[i];
    vector<int> outlist = residual_graph->get_outlist(src_res_id);
    for (vector<int>::iterator out_itr = outlist.begin(); out_itr != outlist.end(); out_itr++) {
        int res_eid = *out_itr;
        int res_eid_tgt = residual_graph->get_target_node(res_eid);
        int org_eid_tgt = residual_graph->get_component_ids_of_node(res_eid_tgt)[0];
        int tgt_excess = residual_graph->get_component_ids_of_node(res_eid_tgt)[3];
        if((tgt_excess > delta/2)&&(org_eid_tgt!=i)&&(org_eid_tgt!=j)){
        	nodeHeightLists[0].push_back(org_eid_tgt);
        	push_node_count++;
        }
    }

    //populate_node_heights(residual_graph, node_height_set, i);
    while(delta >= 1){
    	bool flag;
    	int res_node_u;
    	//pick a vertex u having excess > delta/2 and min_height;
    	while(push_node_count>0){
    		flag = false;
        	for(int node_hgt = 0; node_hgt < 2*N; node_hgt++){
        		if(!nodeHeightLists[node_hgt].empty()){
        			for(std::list<int>::iterator it=nodeHeightLists[node_hgt].begin(); it!=nodeHeightLists[node_hgt].end(); it++){
        				if(map_nseq_to_res_graph_nid.find(*it) != map_nseq_to_res_graph_nid.end()){
        					int res_node_seq = map_nseq_to_res_graph_nid[*it];
        					//cout<<node_hgt<<"-->";
        					if((residual_graph->get_component_ids_of_node(res_node_seq)[3] >= delta/2)&&(residual_graph->get_component_ids_of_node(res_node_seq)[1] == itr_no)){
        						res_node_u = res_node_seq;
        						flag = true;
        					}
        				}
        				if(flag)
        					break;
        			}
        		}
        		if(flag)
        			break;
        	}
        	if(flag)
        		select_for_push_relabel(original_graph, residual_graph, res_node_u, delta, nodeHeightLists, map_nseq_to_res_graph_nid, map_src_tgt_to_eid, is_outgoing_edges_explored, edge_exist, i, j, itr_no, push_node_count);//for push or relabel

    	}
    	delta = delta/2;
    }
    //return f;
    get_min_cut_edges(original_graph, residual_graph, map_nseq_to_res_graph_nid, i, j, cut_edges, set_s, map_src_tgt_to_eid);
    /*for (set<int>::iterator out_itr = cut_edges.begin(); out_itr != cut_edges.end(); out_itr++) {
    	cout<<*out_itr<<endl;
    }*/
}
//Excess-scaling algo --ends - anjan-29-may-2017






// Methods for constraints using Z3 C++ API
void GraphManagerNew::create_bool_expressions_one_id_with_z3(z3::context& c, vector<int>& ids, string var_prefix, map<string, z3::expr>& var_to_expr_map) {
    
    for (auto iter = ids.begin(); iter != ids.end(); iter++) {
        int curr_id = *iter;
        string curr_var_name = var_prefix + curr_id;
        z3::expr curr_expr = c.bool_const(curr_var_name.c_str());
        var_to_expr_map.insert(pair<string, z3::expr>(curr_var_name, curr_expr));
    }
}

void GraphManagerNew::create_bool_expressions_two_ids_with_z3(z3::context& c, vector<pair<int,int> >& id_pairs, string var_prefix, string delimiter, map<string, z3::expr>& var_to_expr_map) {
    
    for (auto iter = id_pairs.begin(); iter != id_pairs.end(); iter++) {
        int curr_id1 = iter->first;
        int curr_id2 = iter->second;
        string curr_var_name = var_prefix + curr_id1 + delimiter + curr_id2;
        z3::expr curr_expr = c.bool_const(curr_var_name.c_str());
        var_to_expr_map.insert(pair<string, z3::expr>(curr_var_name, curr_expr));
    }
}

void GraphManagerNew::create_bv_expressions_one_id_with_z3(z3::context& c, vector<int>& ids, string var_prefix, int width, map<string, z3::expr>& var_to_expr_map) {
    
    for (auto iter = ids.begin(); iter != ids.end(); iter++) {
        int curr_id = *iter;
        string curr_var_name = var_prefix + curr_id;
        z3::expr curr_expr = c.bv_const(curr_var_name.c_str(), width);
        var_to_expr_map.insert(pair<string, z3::expr>(curr_var_name, curr_expr));
    }
}

void GraphManagerNew::create_bv_expression_single_var_with_z3(z3::context& c, string var, int width, map<string, z3::expr>& var_to_expr_map) {
    z3::expr curr_expr = c.bv_const(var.c_str(), width);
    var_to_expr_map.insert(pair<string, z3::expr>(var, curr_expr));
}


void GraphManagerNew::get_connectivity_with_z3(z3::context& c, z3::solver& s, map<string, z3::expr>& all_z3_var_to_expr_map, int graph_gid, int ugraph_gid, vector< vector< bool > >& closure_matrix, vector<set<int> >& cut_edges, vector<int>& gomoryhu_parents, vector< vector<int> >& call_level_matrix, vector< vector<int> >& edge_level_matrix, vector< vector<int> >& call_count_matrix, vector< vector<int> >& edge_count_matrix, vector<pair<int, int> >& connect_pairs, int path_bound, set<int>& nids_as_source, set<int>& nids_as_target, set<int>& up_reg_nids_to_use, set<int>& down_reg_nids_to_use, set<int>& essential_nids, set<int>& avoid_nids, set<int>& essential_eids, set<int>& avoid_eids, set<int>& active_nids, set<int>& inactive_nids, set<int>& confirmed_up_reg_nids, set<int>& confirmed_down_reg_nids, set<int>& relaxed_nids, set<int>& nonrelaxed_nids, set<int>& relaxed_eids, set<int>& nonrelaxed_eids, string fold_change_filename, string file_prefix) {

    GraphNew * graph = get_graph(graph_gid);
    if (graph == NULL) {
        cerr << "No graph for graph id " << graph_gid << endl;
        return;
    }

    GraphNew * ugraph = get_graph(ugraph_gid);
    if (ugraph == NULL) {
        cerr << "No graph for graph id " << ugraph_gid << endl;
        return;
    }

    generate_connectivity_constraints_with_z3(c, s, all_z3_var_to_expr_map, graph, ugraph, closure_matrix, cut_edges, gomoryhu_parents, call_level_matrix, edge_level_matrix, call_count_matrix, edge_count_matrix, connect_pairs, path_bound, nids_as_source, nids_as_target, up_reg_nids_to_use, down_reg_nids_to_use, essential_nids, avoid_nids, essential_eids, avoid_eids, active_nids, inactive_nids, confirmed_up_reg_nids, confirmed_down_reg_nids, relaxed_nids, nonrelaxed_nids, relaxed_eids, nonrelaxed_eids, fold_change_filename, file_prefix);

}



void GraphManagerNew::generate_connectivity_constraints_with_z3(z3::context& c, z3::solver& s, map<string, z3::expr>& all_z3_var_to_expr_map, GraphNew * graph, GraphNew * ugraph, vector< vector< bool > >& closure_matrix, vector<set<int> >& cut_edges, vector<int>& gomoryhu_parents, vector< vector<int> >& call_level_matrix, vector< vector<int> >& edge_level_matrix, vector< vector<int> >& call_count_matrix, vector< vector<int> >& edge_count_matrix, vector<pair<int, int> >& connect_pairs, int path_bound, set<int>& nids_as_source, set<int>& nids_as_target, set<int>& up_reg_nids_to_use, set<int>& down_reg_nids_to_use, set<int>& essential_nids, set<int>& avoid_nids, set<int>& essential_eids, set<int>& avoid_eids, set<int>& active_nids, set<int>& inactive_nids, set<int>& confirmed_up_reg_nids, set<int>& confirmed_down_reg_nids, set<int>& relaxed_nids, set<int>& nonrelaxed_nids, set<int>& relaxed_eids, set<int>& nonrelaxed_eids, string fold_change_filename, string file_prefix) {
    
    string all_pair_file_name = file_prefix + "_mincuts";
    ofstream hout(all_pair_file_name.c_str());

    map<string, int> nodes_in_all_mincuts;
    
    set<int> all_nids_in_constraints;
    set<int> all_eids_in_constraints;

    set<int> nids_to_consider;
    set<int> eids_to_consider;
    list<pair<int, int> > connect_pairs_to_consider;

    for (auto iter = connect_pairs.begin(); iter != connect_pairs.end(); iter++)  // current thing works only for one source-target pair
        connect_pairs_to_consider.push_back(*iter);
    
    int main_src_nid = connect_pairs_to_consider.front().first; 


                
    get_query_assertions_as_constraints_with_z3(c, s, all_z3_var_to_expr_map, connect_pairs, up_reg_nids_to_use, down_reg_nids_to_use, essential_nids, avoid_nids, essential_eids, avoid_eids, active_nids, inactive_nids, confirmed_up_reg_nids, confirmed_down_reg_nids, relaxed_nids, nonrelaxed_nids, relaxed_eids, nonrelaxed_eids, nids_to_consider, all_nids_in_constraints);


    set<string> up_reg_rep_ids, down_reg_rep_ids;
    for (auto i = up_reg_nids_to_use.begin(); i != up_reg_nids_to_use.end(); i++)
        up_reg_rep_ids.insert(graph->get_rep_id_from_nid(*i));
    for (auto i = down_reg_nids_to_use.begin(); i != down_reg_nids_to_use.end(); i++)
        down_reg_rep_ids.insert(graph->get_rep_id_from_nid(*i));
    

    get_connection_constraints_using_mincut_with_z3(c, s, all_z3_var_to_expr_map, graph, ugraph, closure_matrix, call_level_matrix, edge_level_matrix, call_count_matrix, edge_count_matrix, cut_edges, gomoryhu_parents, connect_pairs_to_consider, up_reg_nids_to_use, down_reg_nids_to_use, essential_nids, avoid_nids, active_nids, inactive_nids, confirmed_up_reg_nids, confirmed_down_reg_nids, relaxed_nids, nonrelaxed_nids, relaxed_eids, nonrelaxed_eids, nids_to_consider, eids_to_consider, up_reg_rep_ids, down_reg_rep_ids, fold_change_filename, all_nids_in_constraints, all_eids_in_constraints, nodes_in_all_mincuts, hout);

    get_edge_implies_connection_constraints_with_z3(c, s, all_z3_var_to_expr_map, graph, nids_to_consider, eids_to_consider, connect_pairs_to_consider, all_nids_in_constraints);

    get_targets_dist_lt_bound_constraints_with_z3(c, s, all_z3_var_to_expr_map, graph, nids_as_target, path_bound);

    get_node_implies_inedge_outedge_constraints_with_z3(c, s, all_z3_var_to_expr_map, graph, up_reg_nids_to_use, down_reg_nids_to_use, nids_to_consider, eids_to_consider, nids_as_source, nids_as_target, all_nids_in_constraints, all_eids_in_constraints);

    get_total_nodes_lt_bound_constraints_with_z3(c, s, all_z3_var_to_expr_map, graph, nids_to_consider);
    get_total_edges_lt_bound_constraints_with_z3(c, s, all_z3_var_to_expr_map, graph, eids_to_consider);

    get_node_activation_status_relaxation_constraints_with_z3(c, s, all_z3_var_to_expr_map, graph, nids_to_consider, up_reg_nids_to_use, down_reg_nids_to_use, nids_as_source, nids_as_target);
    
    get_every_path_has_diff_exp_node_constraints_with_z3(c, s, all_z3_var_to_expr_map, graph, nids_to_consider, eids_to_consider, up_reg_nids_to_use, down_reg_nids_to_use, nids_as_source, nids_as_target);
    
    get_edge_activation_status_relaxation_constraints_with_z3(c, s, all_z3_var_to_expr_map, graph, eids_to_consider, up_reg_nids_to_use, down_reg_nids_to_use);
    
    // Currently asserting single source node must be active
    string main_src_active_var = "__nodeactive_" + IntToString(main_src_nid);
    s.add(all_z3_var_to_expr_map.at(main_src_active_var));
    
}


void GraphManagerNew::get_connection_constraints_using_mincut_with_z3(z3::context& c, z3::solver& s, map<string, z3::expr>& all_z3_var_to_expr_map, GraphNew * graph, GraphNew * ugraph, vector< vector< bool > >& closure_matrix, vector< vector<int> >& call_level_matrix, vector< vector<int> >& edge_level_matrix, vector< vector<int> >& call_count_matrix, vector< vector<int> >& edge_count_matrix, vector<set<int> >& cut_edges, vector<int>& gomoryhu_parents, list<pair<int, int> >& connect_pairs_to_consider, set<int>& up_reg_nids_to_use, set<int>& down_reg_nids_to_use, set<int>& essential_nids, set<int>& avoid_nids, set<int>& active_nids, set<int>& inactive_nids, set<int>& confirmed_up_reg_nids, set<int>& confirmed_down_reg_nids, set<int>& relaxed_nids, set<int>& nonrelaxed_nids, set<int>& relaxed_eids, set<int>& nonrelaxed_eids, set<int>& nids_to_consider, set<int>& eids_to_consider, set<string>& up_reg_rep_ids, set<string>& down_reg_rep_ids, string fold_change_filename, set<int>& all_nids_in_constraints, set<int>& all_eids_in_constraints, map<string, int>& nodes_in_all_mincuts, ofstream& hout) {

    
    
    static set<string> written_pairs;
//    static bool already_called = false;
    
    static vector<bool> selected_mincut_vec(gomoryhu_parents.size(), false);
    
    pair<int, int> first_pair = connect_pairs_to_consider.front();
    int first_pair_src_nid = first_pair.first;
    int first_pair_tgt_nid = first_pair.second;
    
    int call_pair_source_nseq = GET_NODE_SEQ_NUM(graph, first_pair_src_nid);
    int call_pair_target_nseq = GET_NODE_SEQ_NUM(graph, first_pair_tgt_nid);

    cout << "Source: " << kegg_hsa_id_to_display_name_map[graph->get_rep_id_from_nid(first_pair_src_nid)] << "(" << (graph->get_rep_id_from_nid(first_pair_src_nid)) << ")" 
             << " Target: " << kegg_hsa_id_to_display_name_map[graph->get_rep_id_from_nid(first_pair_tgt_nid)] << "(" << (graph->get_rep_id_from_nid(first_pair_tgt_nid)) << ")" << endl;
    
//    if (already_called) {
//        cerr << "Multiple calls for s-t pair." << endl;
//        exit(1);
//    }
//    else {
//        already_called = true;
//    }
    
    
    call_level_matrix[call_pair_source_nseq][call_pair_target_nseq] = 1;
    call_count_matrix[call_pair_source_nseq][call_pair_target_nseq] = 1;
    
    while (!connect_pairs_to_consider.empty()) {
        pair<int, int> curr_pair = connect_pairs_to_consider.front();
        connect_pairs_to_consider.pop_front();
        int source_nid = curr_pair.first;
        int target_nid = curr_pair.second;
        
        call_pair_source_nseq = GET_NODE_SEQ_NUM(graph, source_nid);
        call_pair_target_nseq = GET_NODE_SEQ_NUM(graph, target_nid);
        
        string src_node_var = "__node_" + IntToString(source_nid);
        string tgt_node_var = "__node_" + IntToString(target_nid);
        string connect_var = "__connect_" + IntToString(source_nid) + "_" + IntToString(target_nid);

        
        if (written_pairs.find(connect_var) == written_pairs.end()) {
            written_pairs.insert(connect_var);
            
//            if (source_nid == target_nid) {
//                if (all_z3_var_to_expr_map.find(connect_var) == all_z3_var_to_expr_map.end()) {
//                    all_z3_var_to_expr_map.insert(pair<string, z3::expr>(connect_var, c.bool_const(connect_var.c_str())));
//                }
//                s.add(all_z3_var_to_expr_map.at(connect_var) == true);
//                continue;
//            }


            nids_to_consider.insert(source_nid);
            nids_to_consider.insert(target_nid);
            all_nids_in_constraints.insert(source_nid);
            all_nids_in_constraints.insert(target_nid);
//            get_connection_implies_end_nodes_constraints_with_z3(c, s, all_z3_var_to_expr_map, connect_var, src_node_var, tgt_node_var);

            int src_nid_in_ugraph = ugraph->get_nid_from_rep_id(graph->get_rep_id_from_nid(source_nid));
            int tgt_nid_in_ugraph = ugraph->get_nid_from_rep_id(graph->get_rep_id_from_nid(target_nid));

            
            set<int> directed_cut_eids;
            
	    // changed by sukanya in May 2019
	    vector<int> outlist_of_src = graph->get_outlist(source_nid);
	    for (auto out_iter = outlist_of_src.begin(); out_iter != outlist_of_src.end(); out_iter++) {
		directed_cut_eids.insert(*out_iter);
	    }
            ////get_min_cut_edges_from_ghtree(graph, ugraph, closure_matrix, cut_edges, gomoryhu_parents, selected_mincut_vec, GET_NODE_SEQ_NUM(ugraph, src_nid_in_ugraph), GET_NODE_SEQ_NUM(ugraph, tgt_nid_in_ugraph), directed_cut_eids);
            
            
            for (auto e = directed_cut_eids.begin(); e != directed_cut_eids.end(); e++) {
                int curr_eid = *e;
                int curr_eid_src = graph->get_source_node(curr_eid);
                int curr_eid_tgt = graph->get_target_node(curr_eid);
                int curr_eid_src_nseq = GET_NODE_SEQ_NUM(graph, curr_eid_src);
                int curr_eid_tgt_nseq = GET_NODE_SEQ_NUM(graph, curr_eid_tgt);
                
                int curr_entry = call_level_matrix[call_pair_source_nseq][curr_eid_src_nseq];
                int new_curr_entry = min(curr_entry, 1 + call_level_matrix[call_pair_source_nseq][call_pair_target_nseq]);
                 
                if (new_curr_entry < curr_entry) {
                    call_level_matrix[call_pair_source_nseq][curr_eid_src_nseq] = new_curr_entry;
                    
                }
                
                curr_entry = call_level_matrix[curr_eid_tgt_nseq][call_pair_target_nseq];
                new_curr_entry = min(curr_entry, 1 + call_level_matrix[call_pair_source_nseq][call_pair_target_nseq]);
                
                if (new_curr_entry < curr_entry) {
                    call_level_matrix[curr_eid_tgt_nseq][call_pair_target_nseq] = new_curr_entry;
                    
                }
                
                curr_entry = edge_level_matrix[curr_eid_src_nseq][curr_eid_tgt_nseq];
                new_curr_entry = min(curr_entry, 1 + call_level_matrix[call_pair_source_nseq][call_pair_target_nseq]);
                
                
                if (new_curr_entry < curr_entry)
                    edge_level_matrix[curr_eid_src_nseq][curr_eid_tgt_nseq] = new_curr_entry;
                
                if (call_pair_source_nseq != curr_eid_src_nseq)
                        call_count_matrix[call_pair_source_nseq][curr_eid_src_nseq]++;
                
                if (curr_eid_tgt_nseq != call_pair_target_nseq)
                        call_count_matrix[curr_eid_tgt_nseq][call_pair_target_nseq]++;
                
                edge_count_matrix[curr_eid_src_nseq][curr_eid_tgt_nseq]++;
            }
                
            

            if (directed_cut_eids.empty()) {
                
                s.add(!all_z3_var_to_expr_map.at(connect_var));
                continue;
            }
            
            if (directed_cut_eids.size() == 1) {
                //cout << "Mincut between " << graph->get_rep_id_from_nid(source_nid) << " and " << graph->get_rep_id_from_nid(target_nid) << " has 1 edge" << endl;

                //int curr_edge = ugraph->get_other_value1_in_edge(*directed_cut_eids.begin());
                int curr_edge = *directed_cut_eids.begin();

                //int curr_edge = *directed_cut_eids.begin();
                eids_to_consider.insert(curr_edge);
                nids_to_consider.insert(graph->get_source_node(curr_edge)); //
                nids_to_consider.insert(graph->get_target_node(curr_edge)); //

                all_eids_in_constraints.insert(curr_edge);
                all_nids_in_constraints.insert(graph->get_source_node(curr_edge));
                all_nids_in_constraints.insert(graph->get_target_node(curr_edge));
                string edge_var = "__edge_" + IntToString(curr_edge);


                z3::expr right_expr = c.bool_const("m3_right_expr");

                
                
                if ((graph->get_source_node(curr_edge) == source_nid) && (graph->get_target_node(curr_edge) == target_nid)) {
                    right_expr = all_z3_var_to_expr_map.at(edge_var);
                    
                } else {
                    z3::expr to_AND = c.bool_val(true);
                    to_AND = to_AND && all_z3_var_to_expr_map.at(edge_var);
                    
                                
                    if (graph->get_source_node(curr_edge) != source_nid) {
//                        string new_connect_var = "__connect_" + IntToString(source_nid) + "_" + IntToString(graph->get_source_node(curr_edge));
//                        if (all_z3_var_to_expr_map.find(new_connect_var) == all_z3_var_to_expr_map.end()) {
//                            all_z3_var_to_expr_map.insert(pair<string, z3::expr>(new_connect_var, c.bool_const(new_connect_var.c_str())));
//                        }
//                        to_AND = to_AND && all_z3_var_to_expr_map.at(new_connect_var);
                           
                  
                        if (source_nid != graph->get_source_node(curr_edge)){ // not the same node
                            connect_pairs_to_consider.push_back(pair<int, int>(source_nid, graph->get_source_node(curr_edge)));
                            
                        }
                    }
                    if (graph->get_target_node(curr_edge) != target_nid) {
//                        string new_connect_var = "__connect_" + IntToString(graph->get_target_node(curr_edge)) + "_" + IntToString(target_nid);
//                        if (all_z3_var_to_expr_map.find(new_connect_var) == all_z3_var_to_expr_map.end()) {
//                            all_z3_var_to_expr_map.insert(pair<string, z3::expr>(new_connect_var, c.bool_const(new_connect_var.c_str())));
//                        }
//                        to_AND = to_AND && all_z3_var_to_expr_map.at(new_connect_var);
                        
                        if (graph->get_target_node(curr_edge) != target_nid) { // not the same node
                            connect_pairs_to_consider.push_back(pair<int, int>(graph->get_target_node(curr_edge), target_nid));
                            
                        }

                    }

                    right_expr = to_AND;
                    
                }

//                s.add(all_z3_var_to_expr_map.at(connect_var) == right_expr);

            }
            else {
                
                z3::expr to_OR = c.bool_val(false);
                
                for (auto mincut_iter = directed_cut_eids.begin(); mincut_iter != directed_cut_eids.end(); mincut_iter++) {
                    
                    int curr_edge = *mincut_iter;
                    eids_to_consider.insert(curr_edge);
                    nids_to_consider.insert(graph->get_source_node(curr_edge)); //
                    nids_to_consider.insert(graph->get_target_node(curr_edge)); //

                    all_eids_in_constraints.insert(curr_edge);
                    all_nids_in_constraints.insert(graph->get_source_node(curr_edge));
                    all_nids_in_constraints.insert(graph->get_target_node(curr_edge));

                    string edge_var = "__edge_" + IntToString(curr_edge);


                    if ((graph->get_source_node(curr_edge) == source_nid) && (graph->get_target_node(curr_edge) == target_nid)) {
                        to_OR = to_OR || all_z3_var_to_expr_map.at(edge_var);

                    } else {
                        z3::expr to_AND = c.bool_val(true);
                        
                        to_AND = to_AND && all_z3_var_to_expr_map.at(edge_var);
                        
                        if (graph->get_source_node(curr_edge) != source_nid) {
//                            string new_connect_var = "__connect_" + IntToString(source_nid) + "_" + IntToString(graph->get_source_node(curr_edge));
//                            if (all_z3_var_to_expr_map.find(new_connect_var) == all_z3_var_to_expr_map.end()) {
//                                all_z3_var_to_expr_map.insert(pair<string, z3::expr>(new_connect_var, c.bool_const(new_connect_var.c_str())));
//                            }
//                            to_AND = to_AND && all_z3_var_to_expr_map.at(new_connect_var);
                            
                            if (source_nid != graph->get_source_node(curr_edge)) { // not the same node
                                connect_pairs_to_consider.push_back(pair<int, int>(source_nid, graph->get_source_node(curr_edge)));
                                
                            }

                        }
                        if (graph->get_target_node(curr_edge) != target_nid) {
//                            string new_connect_var = "__connect_" + IntToString(graph->get_target_node(curr_edge)) + "_" + IntToString(target_nid);
//                            if (all_z3_var_to_expr_map.find(new_connect_var) == all_z3_var_to_expr_map.end()) {
//                                all_z3_var_to_expr_map.insert(pair<string, z3::expr>(new_connect_var, c.bool_const(new_connect_var.c_str())));
//                            }
//                            to_AND = to_AND && all_z3_var_to_expr_map.at(new_connect_var);
                            
                            if (graph->get_target_node(curr_edge) != target_nid) { // not the same node
                                connect_pairs_to_consider.push_back(pair<int, int>(graph->get_target_node(curr_edge), target_nid));
                                
                            }

                        }

                        to_OR = to_OR || to_AND;
                    }

                }

//                s.add(all_z3_var_to_expr_map.at(connect_var) == to_OR);


            }

        }
    

    }

}


void GraphManagerNew::get_connection_implies_end_nodes_constraints_with_z3(z3::context& c, z3::solver& s, map<string, z3::expr>& all_z3_var_to_expr_map, string connect_var, string src_node_var, string tgt_node_var) {

    s.add(implies(all_z3_var_to_expr_map.at(connect_var), all_z3_var_to_expr_map.at(src_node_var) && all_z3_var_to_expr_map.at(tgt_node_var)));
    
}


void GraphManagerNew::get_edge_implies_connection_constraints_with_z3(z3::context& c, z3::solver& s, map<string, z3::expr>& all_z3_var_to_expr_map, GraphNew * graph, set<int>& nids_to_consider, set<int>& eids_to_consider, list<pair<int, int> >& connect_pairs_to_consider, set<int>& all_nids_in_constraints) {

    static set<int> written_edges;


    for (auto eids_iter = eids_to_consider.begin(); eids_iter != eids_to_consider.end(); eids_iter++) {
        int curr_eid = *eids_iter;
        int src_nid = graph->get_source_node(curr_eid);
        int tgt_nid = graph->get_target_node(curr_eid);
        nids_to_consider.insert(src_nid);
        nids_to_consider.insert(tgt_nid);
        all_nids_in_constraints.insert(src_nid);
        all_nids_in_constraints.insert(tgt_nid);


        if (written_edges.find(curr_eid) == written_edges.end()) {
            written_edges.insert(curr_eid);

            string edge_var = "__edge_" + IntToString(curr_eid);
//            string connect_var = "__connect_" + IntToString(src_nid) + "_" + IntToString(tgt_nid);
//            
//            if (all_z3_var_to_expr_map.find(connect_var) == all_z3_var_to_expr_map.end()) {
//                all_z3_var_to_expr_map.insert(pair<string, z3::expr>(connect_var, c.bool_const(connect_var.c_str())));
//            } 
//            
//            s.add (implies(all_z3_var_to_expr_map.at(edge_var), all_z3_var_to_expr_map.at(connect_var)));
            
            
            connect_pairs_to_consider.push_back(pair<int, int>(src_nid, tgt_nid));


            // edge present implies end nodes are present
            string src_var = "__node_" + IntToString(src_nid);
            string tgt_var = "__node_" + IntToString(tgt_nid);
            
            s.add (implies(all_z3_var_to_expr_map.at(edge_var), all_z3_var_to_expr_map.at(src_var) && all_z3_var_to_expr_map.at(tgt_var)));
            
            
            // for ordering -- src_dist < tgt_dist
            get_src_dist_lt_tgt_dist_constraints_with_z3(c, s, all_z3_var_to_expr_map, graph, curr_eid);


        }
    }
    
}


void GraphManagerNew::get_src_dist_lt_tgt_dist_constraints_with_z3(z3::context& c, z3::solver& s, map<string, z3::expr>& all_z3_var_to_expr_map, GraphNew * graph, int curr_eid) {
    
    
    string edge_var = "__edge_" + IntToString(curr_eid);
    string src_distance_var = "__nodedistance_" + IntToString(graph->get_source_node(curr_eid));
    string tgt_distance_var = "__nodedistance_" + IntToString(graph->get_target_node(curr_eid));

    static set<int> written_eids;

    if (written_eids.find(curr_eid) != written_eids.end())
        return;
    
    s.add (implies(all_z3_var_to_expr_map.at(edge_var), ult(all_z3_var_to_expr_map.at(src_distance_var), all_z3_var_to_expr_map.at(tgt_distance_var))));
    
}

void GraphManagerNew::get_targets_dist_lt_bound_constraints_with_z3(z3::context& c, z3::solver& s, map<string, z3::expr>& all_z3_var_to_expr_map, GraphNew * graph, set<int>& nids_as_target, int path_bound_value) {
    
    static set<int> written_nids;

    string path_bound_var = "__pathbound";
    
    for (auto iter = nids_as_target.begin(); iter != nids_as_target.end(); iter++) {
        int curr_nid = *iter;

        if (written_nids.find(curr_nid) != written_nids.end())
            continue;

        string node_dist_var = "__nodedistance_" + IntToString(curr_nid);
        s.add (ule(all_z3_var_to_expr_map.at(node_dist_var), all_z3_var_to_expr_map.at(path_bound_var)));
        
    }

    z3::expr path_bound_value_expr = c.bv_val((unsigned) path_bound_value, (unsigned) PATH_BOUND_BIT_LENGTH(path_bound_value));
    s.add (ule(all_z3_var_to_expr_map.at(path_bound_var), path_bound_value_expr));

}

void GraphManagerNew::get_node_implies_inedge_outedge_constraints_with_z3(z3::context& c, z3::solver& s, map<string, z3::expr>& all_z3_var_to_expr_map, GraphNew * graph, set<int>& up_reg_nids, set<int>& down_reg_nids, set<int>& nids_to_consider, set<int>& eids_to_consider, set<int>& nids_as_source, set<int>& nids_as_target, set<int>& all_nids_in_constraints, set<int>& all_eids_in_constraints) {


    get_source_has_outedge_constraints_with_z3(c, s, all_z3_var_to_expr_map, graph, nids_as_source, nids_to_consider, eids_to_consider, all_nids_in_constraints, all_eids_in_constraints);
    get_target_has_inedge_constraints_with_z3(c, s, all_z3_var_to_expr_map, graph, up_reg_nids, down_reg_nids, nids_as_target, nids_to_consider, eids_to_consider, all_nids_in_constraints, all_eids_in_constraints);


    set<int> all_nodes_minus_sources;
    set<int> remaining_nodes_to_consider;
    set_difference(nids_to_consider.begin(), nids_to_consider.end(), nids_as_source.begin(), nids_as_source.end(), inserter(all_nodes_minus_sources, all_nodes_minus_sources.begin()));
    set_difference(all_nodes_minus_sources.begin(), all_nodes_minus_sources.end(), nids_as_target.begin(), nids_as_target.end(), inserter(remaining_nodes_to_consider, remaining_nodes_to_consider.begin()));

    get_node_has_inedge_outedge_constraints_with_z3(c, s, all_z3_var_to_expr_map, graph, up_reg_nids, down_reg_nids, remaining_nodes_to_consider, nids_to_consider, eids_to_consider, all_nids_in_constraints, all_eids_in_constraints);

    
}


void GraphManagerNew::get_source_has_outedge_constraints_with_z3(z3::context& c, z3::solver& s, map<string, z3::expr>& all_z3_var_to_expr_map, GraphNew * graph, set<int>& nids_as_source, set<int>& nids_to_consider, set<int>& eids_to_consider, set<int>& all_nids_in_constraints, set<int>& all_eids_in_constraints) {
    
    static set<int> written_as_source;

    for (auto nids_iter = nids_as_source.begin(); nids_iter != nids_as_source.end(); nids_iter++) {
        int curr_nid = *nids_iter;

        if (written_as_source.find(curr_nid) != written_as_source.end())
            continue;
        written_as_source.insert(curr_nid);

        string node_var = "__node_" + IntToString(curr_nid);
        
        
        vector<int> outlist = graph->get_outlist(curr_nid);

        z3::expr to_OR = c.bool_val(false);

        for (auto out_iter = outlist.begin(); out_iter != outlist.end(); out_iter++) {
            int curr_edge = *out_iter;

            if (eids_to_consider.find(curr_edge) != eids_to_consider.end()) {
                    string edge_var = "__edge_" + IntToString(curr_edge);
                    to_OR = to_OR || all_z3_var_to_expr_map.at(edge_var);

                    all_eids_in_constraints.insert(curr_edge);
                    int edge_src_nid = graph->get_source_node(curr_edge);
                    int edge_tgt_nid = graph->get_target_node(curr_edge);
                    all_nids_in_constraints.insert(edge_src_nid);
                    all_nids_in_constraints.insert(edge_tgt_nid);
            }

        }
        
        s.add(implies(all_z3_var_to_expr_map.at(node_var), to_OR));    
    }
}
    

void GraphManagerNew::get_target_has_inedge_constraints_with_z3(z3::context& c, z3::solver& s, map<string, z3::expr>& all_z3_var_to_expr_map, GraphNew * graph, set<int>& up_reg_nids, set<int>& down_reg_nids, set<int>& nids_as_target, set<int>& nids_to_consider, set<int>& eids_to_consider, set<int>& all_nids_in_constraints, set<int>& all_eids_in_constraints) {
    
    static set<int> written_as_target;

    for (auto nids_iter = nids_as_target.begin(); nids_iter != nids_as_target.end(); nids_iter++) {
        int curr_nid = *nids_iter;

        if (written_as_target.find(curr_nid) != written_as_target.end())
            continue;
        written_as_target.insert(curr_nid);

        string node_var = "__node_" + IntToString(curr_nid);

        vector<int> inlist = graph->get_inlist(curr_nid);

        z3::expr to_OR = c.bool_val(false);
        for (auto in_iter = inlist.begin(); in_iter != inlist.end(); in_iter++) {
            int curr_edge = *in_iter;

            if (eids_to_consider.find(curr_edge) != eids_to_consider.end()) {


                string edge_var = "__edge_" + IntToString(curr_edge);
                
                to_OR = to_OR || all_z3_var_to_expr_map.at(edge_var);
                
                all_eids_in_constraints.insert(curr_edge);
                int edge_src_nid = graph->get_source_node(curr_edge);
                int edge_tgt_nid = graph->get_target_node(curr_edge);
                all_nids_in_constraints.insert(edge_src_nid);
                all_nids_in_constraints.insert(edge_tgt_nid);
            }

        }
        
        s.add(implies(all_z3_var_to_expr_map.at(node_var), to_OR));

    }

}

void GraphManagerNew::get_node_has_inedge_outedge_constraints_with_z3(z3::context& c, z3::solver& s, map<string, z3::expr>& all_z3_var_to_expr_map, GraphNew * graph, set<int>& up_reg_nids, set<int>& down_reg_nids, set<int>& remaining_nodes_to_consider, set<int>& nids_to_consider, set<int>& eids_to_consider, set<int>& all_nids_in_constraints, set<int>& all_eids_in_constraints) {
    
    static set<int> written_nids;

    //nids_to_consider - both out and in edges
    for (auto nids_iter = remaining_nodes_to_consider.begin(); nids_iter != remaining_nodes_to_consider.end(); nids_iter++) {
        int curr_nid = *nids_iter;

        if (written_nids.find(curr_nid) != written_nids.end())
            continue;
        written_nids.insert(curr_nid);

        vector<int> inlist = graph->get_inlist(curr_nid);
        vector<int> outlist = graph->get_outlist(curr_nid);


        string node_var = "__node_" + IntToString(curr_nid);
        assert (!inlist.empty() && !outlist.empty());

        
        // inlist

        z3::expr to_OR_in = c.bool_val(false);
        
        t_Expression * inlist_expr = NULL;
       
          
        
        for (auto in_iter = inlist.begin(); in_iter != inlist.end(); in_iter++) {
            int curr_edge = *in_iter;

            if (eids_to_consider.find(curr_edge) != eids_to_consider.end()) {
                string edge_var = "__edge_" + IntToString(curr_edge);
                
                to_OR_in = to_OR_in || all_z3_var_to_expr_map.at(edge_var);
                
                //all_eids_in_constraints.insert(curr_edge);
                int edge_src_nid = graph->get_source_node(curr_edge);
                int edge_tgt_nid = graph->get_target_node(curr_edge);
                all_nids_in_constraints.insert(edge_src_nid);
                all_nids_in_constraints.insert(edge_tgt_nid);
            }

        }

         // outlist

        z3::expr to_OR_out = c.bool_val(false);
        for (auto out_iter = outlist.begin(); out_iter != outlist.end(); out_iter++) {
            int curr_edge = *out_iter;

            if (eids_to_consider.find(curr_edge) != eids_to_consider.end()) {
                string edge_var = "__edge_" + IntToString(curr_edge);
                

                to_OR_out = to_OR_out || all_z3_var_to_expr_map.at(edge_var);
                //all_eids_in_constraints.insert(curr_edge);
                int edge_src_nid = graph->get_source_node(curr_edge);
                int edge_tgt_nid = graph->get_target_node(curr_edge);
                all_nids_in_constraints.insert(edge_src_nid);
                all_nids_in_constraints.insert(edge_tgt_nid);
            }



        }

        s.add (implies(all_z3_var_to_expr_map.at(node_var), to_OR_in && to_OR_out));
    }
}

    
    

void GraphManagerNew::get_query_assertions_as_constraints_with_z3(z3::context& c, z3::solver& s, map<string, z3::expr>& all_z3_var_to_expr_map, vector<pair<int, int> >& connect_pairs, set<int>& up_reg_nids_to_use, set<int>& down_reg_nids_to_use, set<int>& essential_nids, set<int>& avoid_nids, set<int>& essential_eids, set<int>& avoid_eids, set<int>& active_nids, set<int>& inactive_nids, set<int>& confirmed_up_reg_nids, set<int>& confirmed_down_reg_nids, set<int>& relaxed_nids, set<int>& nonrelaxed_nids, set<int>& relaxed_eids, set<int>& nonrelaxed_eids, set<int>& nids_to_consider, set<int>& all_nids_in_constraints) {
    
    static set<string> written_pairs_connect;
    static set<string> written_pairs_disconnect;
    static set<int> written_nids;

    
                
//    
//    for (auto iter = connect_pairs.begin(); iter != connect_pairs.end(); iter++) {
//        string connect_var = "__connect_" + IntToString((*iter).first) + "_" + IntToString((*iter).second);
//
//        if (written_pairs_connect.find(connect_var) == written_pairs_connect.end()) {
//            written_pairs_connect.insert(connect_var);
//            
//            nids_to_consider.insert((*iter).first);
//            nids_to_consider.insert((*iter).second);
//
//            all_nids_in_constraints.insert((*iter).first);
//            all_nids_in_constraints.insert((*iter).second);
//            
//            s.add(all_z3_var_to_expr_map.at(connect_var));
//        }
//    }

    
    for (auto iter = essential_nids.begin(); iter != essential_nids.end(); iter++) {

        int curr_nid = *iter;

        if (written_nids.find(curr_nid) == written_nids.end()) {
            written_nids.insert(curr_nid);

            nids_to_consider.insert(curr_nid);
            
            all_nids_in_constraints.insert(curr_nid);
            
            string data_var = "__node_" + IntToString(curr_nid);
            
            s.add(all_z3_var_to_expr_map.at(data_var));
            
        }
    }
    
    for (auto iter = avoid_nids.begin(); iter != avoid_nids.end(); iter++) {

        int curr_nid = *iter;
        string data_var = "__node_" + IntToString(curr_nid);
        
        s.add(!all_z3_var_to_expr_map.at(data_var));
        
    }
    
    for (auto iter = essential_eids.begin(); iter != essential_eids.end(); iter++) {

        int curr_eid = *iter;
        string data_var = "__edge_" + IntToString(curr_eid);
        
        s.add(all_z3_var_to_expr_map.at(data_var));
        
    }
    
    for (auto iter = avoid_eids.begin(); iter != avoid_eids.end(); iter++) {

        int curr_eid = *iter;
        string data_var = "__edge_" + IntToString(curr_eid);
        
        s.add(!all_z3_var_to_expr_map.at(data_var));
        
    }
    
    for (auto iter = active_nids.begin(); iter != active_nids.end(); iter++) {

        int curr_nid = *iter;
        string data_var = "__nodeactive_" + IntToString(curr_nid);
        
        s.add(all_z3_var_to_expr_map.at(data_var));
        
    }
    
    for (auto iter = inactive_nids.begin(); iter != inactive_nids.end(); iter++) {

        int curr_nid = *iter;
        string data_var = "__nodeactive_" + IntToString(curr_nid);
        
        s.add(!all_z3_var_to_expr_map.at(data_var));
        
    }
    
    for (auto iter = nonrelaxed_nids.begin(); iter != nonrelaxed_nids.end(); iter++) {

        int curr_nid = *iter;
        string data_var = "__noderelax_" + IntToString(curr_nid);
        
        s.add(!all_z3_var_to_expr_map.at(data_var));
        
    }
    
    for (auto iter = nonrelaxed_eids.begin(); iter != nonrelaxed_eids.end(); iter++) {

        int curr_eid = *iter;
        string data_var = "__edgerelax_" + IntToString(curr_eid);
        
        s.add(!all_z3_var_to_expr_map.at(data_var));
        
    }
}



void GraphManagerNew::get_edge_type_consistency_constraints_with_z3(z3::context& c, z3::solver& s, map<string, z3::expr>& all_z3_var_to_expr_map, GraphNew * graph, set<int>& eids_to_consider) {
    
    z3::expr to_AND = c.bool_val(true);
               
    for (auto iter = eids_to_consider.begin(); iter != eids_to_consider.end(); iter++) {
        int curr_eid = *iter;

        string edge_var = "__edge_" + IntToString(curr_eid);
        int curr_edge_src = graph->get_source_node(curr_eid);
        int curr_edge_tgt = graph->get_target_node(curr_eid);
                        
        string src_active_var = "__nodeactive_" + IntToString(curr_edge_src);
        string tgt_active_var = "__nodeactive_" + IntToString(curr_edge_tgt);
        
        // condition for inactive
        z3::expr right_expr = c.bool_const("right_expr_edge_type");
                
        if (graph->edge_has_subtype(curr_eid, "inhibition") || graph->edge_has_subtype(curr_eid, "repression")) { 
             right_expr = all_z3_var_to_expr_map.at(src_active_var) && !all_z3_var_to_expr_map.at(tgt_active_var);
//            all_z3_var_to_expr_map.at(edge_var) = all_z3_var_to_expr_map.at(src_active_var) && !all_z3_var_to_expr_map.at(tgt_active_var);
//            right_expr = all_z3_var_to_expr_map.at(edge_var);
            
            // reverse case
             right_expr = right_expr || (!all_z3_var_to_expr_map.at(src_active_var) && all_z3_var_to_expr_map.at(tgt_active_var));
//            all_z3_var_to_expr_map.at(edge_var) = !all_z3_var_to_expr_map.at(src_active_var) && all_z3_var_to_expr_map.at(tgt_active_var);
//            right_expr = right_expr || all_z3_var_to_expr_map.at(edge_var);
        }
        else {
             right_expr = all_z3_var_to_expr_map.at(src_active_var) && all_z3_var_to_expr_map.at(tgt_active_var);            
//            all_z3_var_to_expr_map.at(edge_var) = all_z3_var_to_expr_map.at(src_active_var) && all_z3_var_to_expr_map.at(tgt_active_var);
//            right_expr = all_z3_var_to_expr_map.at(edge_var);
        }
        
        
        to_AND = to_AND && implies(all_z3_var_to_expr_map.at(edge_var), right_expr);
    }
    
    s.add(to_AND);
    
}


 void GraphManagerNew::get_node_activation_status_relaxation_constraints_with_z3(z3::context& c, z3::solver& s, map<string, z3::expr>& all_z3_var_to_expr_map, GraphNew * graph, set<int>& nids_to_consider, set<int>& up_reg_nids, set<int>& down_reg_nids, set<int>& nids_as_source, set<int>& nids_as_target) {
    int up_reg_down_reg_size = up_reg_nids.size() + down_reg_nids.size();
    
    
    string node_bound_var = "__nodestatusrelaxbound";
    
    z3::expr one  = c.bv_val(1, NODE_RELAX_BOUND_BIT_LENGTH(up_reg_down_reg_size));
    z3::expr zero = c.bv_val(0, NODE_RELAX_BOUND_BIT_LENGTH(up_reg_down_reg_size));
            
    z3::expr to_ADD = c.bv_val(0, NODE_RELAX_BOUND_BIT_LENGTH(up_reg_down_reg_size));

    // Added by Supratik: Nov 28, 2019
    string de_nodes_fname = "diff_expr_nodes.txt";
    ofstream dexpr_nodes(de_nodes_fname);
    // End of addition
        
    for (auto nids_itr = nids_to_consider.begin(); nids_itr != nids_to_consider.end(); nids_itr++) {
        int curr_nid = *nids_itr;
        
        if ((up_reg_nids.find(curr_nid) != up_reg_nids.end()) &&
	    (nids_as_source.find(curr_nid) == nids_as_source.end()) &&
	    (nids_as_target.find(curr_nid) == nids_as_target.end())) {

	  string node_present_var = "__node_" + IntToString(curr_nid);
	  string node_active_var = "__nodeactive_" + IntToString(curr_nid);
	  string node_relax_var = "__noderelax_" + IntToString(curr_nid);

	  // Added by Supratik: Nov 28, 2019
	  string hsa_id = graph->get_rep_id_from_nid(curr_nid);
	  string disp_name = kegg_hsa_id_to_display_name_map[hsa_id];	  
	  dexpr_nodes << "[+] " << hsa_id << " " << disp_name << endl;
	  // End of addition
            
	  z3::expr node_int_expr = z3::to_expr(c, Z3_mk_ite(c, !(all_z3_var_to_expr_map.at(node_present_var) && all_z3_var_to_expr_map.at(node_active_var)), one, zero));
          
	  s.add(!(all_z3_var_to_expr_map.at(node_present_var) && all_z3_var_to_expr_map.at(node_active_var)) == all_z3_var_to_expr_map.at(node_relax_var));
          
          
	  to_ADD = to_ADD + node_int_expr;
        }
        
        
        else if ((down_reg_nids.find(curr_nid) != down_reg_nids.end()) &&
		 (nids_as_source.find(curr_nid) == nids_as_source.end()) &&
		 (nids_as_target.find(curr_nid) == nids_as_target.end())) {

	  string node_present_var = "__node_" + IntToString(curr_nid);
	  string node_active_var = "__nodeactive_" + IntToString(curr_nid);
	  string node_relax_var = "__noderelax_" + IntToString(curr_nid);
            
	  // Added by Supratik: Nov 28, 2019
	  string hsa_id = graph->get_rep_id_from_nid(curr_nid);
	  string disp_name = kegg_hsa_id_to_display_name_map[hsa_id];	  
	  dexpr_nodes << "[-] " << hsa_id << " " << disp_name << endl;
	  // End of addition
            
	  z3::expr node_int_expr = z3::to_expr(c, Z3_mk_ite(c, all_z3_var_to_expr_map.at(node_present_var) && all_z3_var_to_expr_map.at(node_active_var), one, zero));
            
            
	  s.add((all_z3_var_to_expr_map.at(node_present_var) && all_z3_var_to_expr_map.at(node_active_var)) == all_z3_var_to_expr_map.at(node_relax_var));
	  
          
	  to_ADD = to_ADD + node_int_expr;
        }
        
    }
    
    
    s.add(ule(to_ADD, all_z3_var_to_expr_map.at(node_bound_var)));

    dexpr_nodes.close();
}


 void GraphManagerNew::get_edge_activation_status_relaxation_constraints_with_z3(z3::context& c, z3::solver& s, map<string, z3::expr>& all_z3_var_to_expr_map, GraphNew * graph, set<int>& eids_to_consider, set<int>& up_reg_nids, set<int>& down_reg_nids) {
    
    string edge_bound_var = "__edgestatusrelaxbound";
    
    z3::expr one  = c.bv_val(1, EDGE_RELAX_BOUND_BIT_LENGTH(graph));
    z3::expr zero = c.bv_val(0, EDGE_RELAX_BOUND_BIT_LENGTH(graph));
            
    z3::expr to_ADD = c.bv_val(0, EDGE_RELAX_BOUND_BIT_LENGTH(graph));
    
    for (auto eids_itr = eids_to_consider.begin(); eids_itr != eids_to_consider.end(); eids_itr++) {
        
        int curr_eid = *eids_itr;
        int curr_src_nid = graph->get_source_node(curr_eid);
        int curr_tgt_nid = graph->get_target_node(curr_eid);
                   
        string src_node_present_var = "__node_" + IntToString(curr_src_nid);
        string src_node_active_var = "__nodeactive_" + IntToString(curr_src_nid);

        string tgt_node_present_var = "__node_" + IntToString(curr_tgt_nid);
        string tgt_node_active_var = "__nodeactive_" + IntToString(curr_tgt_nid);
        
        string edge_relax_var = "__edgerelax_" + IntToString(curr_eid);
            
               
        z3::expr to_OR = c.bool_val(false);
        if (graph->edge_has_subtype(curr_eid, "inhibition") || (graph->edge_has_subtype(curr_eid, "repression"))) {
            
                     
            // both source and target nodes present and active
            to_OR = to_OR ||
                    ((all_z3_var_to_expr_map.at(src_node_present_var) && all_z3_var_to_expr_map.at(src_node_active_var)) &&
                    (all_z3_var_to_expr_map.at(tgt_node_present_var) && all_z3_var_to_expr_map.at(tgt_node_active_var)));
            
            
            // both source and target nodes present and inactive
            to_OR = to_OR ||
                    ((all_z3_var_to_expr_map.at(src_node_present_var) && !all_z3_var_to_expr_map.at(src_node_active_var)) &&
                    (all_z3_var_to_expr_map.at(tgt_node_present_var) && !all_z3_var_to_expr_map.at(tgt_node_active_var)));  
            
            
            z3::expr edge_int_expr = z3::to_expr(c, Z3_mk_ite(c, to_OR, one, zero));
            
            s.add(to_OR == all_z3_var_to_expr_map.at(edge_relax_var));
            
            to_ADD = to_ADD + edge_int_expr;
        }
        
        
        else {
                     
            // source node present and active, and target node present and inactive
            to_OR = to_OR ||
                    ((all_z3_var_to_expr_map.at(src_node_present_var) && all_z3_var_to_expr_map.at(src_node_active_var)) &&
                    (all_z3_var_to_expr_map.at(tgt_node_present_var) && !all_z3_var_to_expr_map.at(tgt_node_active_var)));
            
            
            // source node present and inactive, and target node present and active
            to_OR = to_OR ||
                    ((all_z3_var_to_expr_map.at(src_node_present_var) && !all_z3_var_to_expr_map.at(src_node_active_var)) &&
                    (all_z3_var_to_expr_map.at(tgt_node_present_var) && all_z3_var_to_expr_map.at(tgt_node_active_var)));
            
            
            // source node present and inactive, and target node present and inactive
            to_OR = to_OR ||
                    ((all_z3_var_to_expr_map.at(src_node_present_var) && !all_z3_var_to_expr_map.at(src_node_active_var)) &&
                    (all_z3_var_to_expr_map.at(tgt_node_present_var) && !all_z3_var_to_expr_map.at(tgt_node_active_var)));
            
                        
            z3::expr edge_int_expr = z3::to_expr(c, Z3_mk_ite(c, to_OR, one, zero));
            
            
            s.add(to_OR == all_z3_var_to_expr_map.at(edge_relax_var));
            
            
            to_ADD = to_ADD + edge_int_expr;
           
        }
    }
    
    s.add(ule(to_ADD, all_z3_var_to_expr_map.at(edge_bound_var)));
}



void GraphManagerNew::get_every_path_has_diff_exp_node_constraints_with_z3(z3::context& c, z3::solver& s, map<string, z3::expr>& all_z3_var_to_expr_map, GraphNew * graph, set<int>& nids_to_consider, set<int>& eids_to_consider, set<int>& up_reg_nids, set<int>& down_reg_nids, set<int>& nids_as_source, set<int>& nids_as_target) {
 
    z3::expr to_AND_all_conditions = c.bool_val(true);
    set<int> diff_expr_nids;
    set_union(up_reg_nids.begin(), up_reg_nids.end(), down_reg_nids.begin(), down_reg_nids.end(), inserter(diff_expr_nids, diff_expr_nids.begin()));
    
    // 1. All selected incoming edges of the target must have  f set to true
    z3::expr to_AND_tgt_node = c.bool_val(true);
    static set<int> written_nids1;
    for (auto nids_iter = nids_as_target.begin(); nids_iter != nids_as_target.end(); nids_iter++) {
        int curr_nid = *nids_iter;
        
        if (written_nids1.find(curr_nid) != written_nids1.end())
            continue;
        
        written_nids1.insert(curr_nid);
        
        z3::expr to_AND = c.bool_val(true);
        
        vector<int> inlist = graph->get_inlist(curr_nid);            

        if (inlist.empty())
            continue;

        for (auto inlist_iter = inlist.begin(); inlist_iter != inlist.end(); inlist_iter++) {
            int curr_inedge = *inlist_iter;

            if (eids_to_consider.find(curr_inedge) == eids_to_consider.end())
                continue;
            
            string edge_var = "__edge_" + IntToString(curr_inedge);
            string edge_flag_var = "__edgepathflag_" + IntToString(curr_inedge);

            to_AND = to_AND && implies(all_z3_var_to_expr_map.at(edge_var), all_z3_var_to_expr_map.at(edge_flag_var));

        }
        to_AND_tgt_node = to_AND_tgt_node && to_AND;
    }
    
    to_AND_all_conditions = to_AND_all_conditions && to_AND_tgt_node;
    
  
    
    // 2. If a node is not differentially expressed and if it has at least one selected incoming edge that has f set to false, then all its outgoing edges (selected or not) must have f set to false.
    set<int> not_diff_expr_nids;
    static set<int> written_nids2;
    set_difference(nids_to_consider.begin(), nids_to_consider.end(), diff_expr_nids.begin(), diff_expr_nids.end(), inserter(not_diff_expr_nids, not_diff_expr_nids.begin()));

    z3::expr to_AND_all_non_diff = c.bool_val(true);
    
    for (auto node_iter = not_diff_expr_nids.begin(); node_iter != not_diff_expr_nids.end(); node_iter++) {
        int curr_nid = *node_iter;
        
        if (written_nids2.find(curr_nid) != written_nids2.end())
            continue;
        
        written_nids2.insert(curr_nid);
        
        
        vector<int> inlist = graph->get_inlist(curr_nid);    
        if (inlist.empty())
                continue;        
            
        z3::expr to_OR = c.bool_val(false);
        for (auto inlist_iter = inlist.begin(); inlist_iter != inlist.end(); inlist_iter++) {
                int curr_inedge = *inlist_iter;
                
                if (eids_to_consider.find(curr_inedge) == eids_to_consider.end())
                    continue;
                
                string edge_var = "__edge_" + IntToString(curr_inedge);
                string edge_flag_var = "__edgepathflag_" + IntToString(curr_inedge);
                
                to_OR = to_OR || (all_z3_var_to_expr_map.at(edge_var) && !all_z3_var_to_expr_map.at(edge_flag_var));
        }
        
        
        z3::expr to_AND = c.bool_val(true);
        vector<int> outlist = graph->get_outlist(curr_nid); 
        
        if (outlist.empty())
            continue;
        
        for (auto outlist_iter = outlist.begin(); outlist_iter != outlist.end(); outlist_iter++) {
                int curr_outedge = *outlist_iter;
                
                if (eids_to_consider.find(curr_outedge) == eids_to_consider.end())
                    continue;
                
                string edge_flag_var = "__edgepathflag_" + IntToString(curr_outedge);
                
                to_AND = to_AND && (!all_z3_var_to_expr_map.at(edge_flag_var));
               
        }
        
        to_AND_all_non_diff = to_AND_all_non_diff && implies(to_OR, to_AND);
    }
    
    to_AND_all_conditions = to_AND_all_conditions && to_AND_all_non_diff;
    
   
    
    
    // 3. All (selected or not) outgoing edges from source have f set to false
    
    
    z3::expr to_AND_all_src_node = c.bool_val(true);
    
    static set<int> written_nids3;
    
    set<int> nids_as_source_minus_diff_expr_nids;
    set_difference(nids_as_source.begin(), nids_as_source.end(), diff_expr_nids.begin(), diff_expr_nids.end(), inserter(nids_as_source_minus_diff_expr_nids, nids_as_source_minus_diff_expr_nids.begin()));
    
    for (auto nids_iter = nids_as_source_minus_diff_expr_nids.begin(); nids_iter != nids_as_source_minus_diff_expr_nids.end(); nids_iter++) {
        int curr_nid = *nids_iter;
        
        if (written_nids3.find(curr_nid) != written_nids3.end())
            continue;
        
        written_nids3.insert(curr_nid);
        
        z3::expr to_AND = c.bool_val(true);
        
        vector<int> outlist = graph->get_outlist(curr_nid);            

        if (outlist.empty())
            continue;

        for (auto outlist_iter = outlist.begin(); outlist_iter != outlist.end(); outlist_iter++) {
            int curr_outedge = *outlist_iter;

            if (eids_to_consider.find(curr_outedge) == eids_to_consider.end())
                continue;
            
            string edge_flag_var = "__edgepathflag_" + IntToString(curr_outedge);

            to_AND = to_AND && (!all_z3_var_to_expr_map.at(edge_flag_var));
        }
        to_AND_all_src_node = to_AND_all_src_node && to_AND;
    }
    
    to_AND_all_conditions = to_AND_all_conditions && to_AND_all_src_node;
    
    
    
    // 4. If a node is differentially expressed, all its outgoing edges (selected or not) have f set to true.
    
    z3::expr to_AND_all_diff_nodes = c.bool_val(true);
    static set<int> written_nids4;
    for (auto node_iter = diff_expr_nids.begin(); node_iter != diff_expr_nids.end(); node_iter++) {
        int curr_nid = *node_iter;
        
        if (written_nids4.find(curr_nid) != written_nids4.end())
            continue;
        
        written_nids4.insert(curr_nid);
        
        z3::expr to_AND = c.bool_val(true);
        
        vector<int> outlist = graph->get_outlist(curr_nid);
        
        if (outlist.empty())
            continue;
        
        for (auto outlist_iter = outlist.begin(); outlist_iter != outlist.end(); outlist_iter++) {
            int curr_outedge = *outlist_iter;

            if (eids_to_consider.find(curr_outedge) == eids_to_consider.end())
                continue;
            
            string edge_flag_var = "__edgepathflag_" + IntToString(curr_outedge);

            to_AND = to_AND && (all_z3_var_to_expr_map.at(edge_flag_var));
            
            
        }
        to_AND_all_diff_nodes = to_AND_all_diff_nodes && to_AND;
        
    }
    
    to_AND_all_conditions = to_AND_all_conditions && to_AND_all_diff_nodes;
    
    s.add(to_AND_all_conditions);
    
}



void GraphManagerNew::get_total_nodes_lt_bound_constraints_with_z3(z3::context& c, z3::solver& s, map<string, z3::expr>& all_z3_var_to_expr_map, GraphNew * graph, set<int>& all_nids_in_constraints) {
    int nids_size = graph->get_node_ids().size();
    int node_bound_bit_length = (int) ceil(log2 ((double) nids_size));
    z3::expr to_ADD = c.bv_val(0, NODE_BOUND_BIT_LENGTH(graph));
    
    string node_bound_var = "__nodebound";
    static set<int> written_nids;
    
    int node_bound_value = graph->get_node_ids().size();
    z3::expr node_bound_value_expr = c.bv_val(node_bound_value, NODE_BOUND_BIT_LENGTH(graph));
    s.add (ule(all_z3_var_to_expr_map.at(node_bound_var), node_bound_value_expr));
    
    
    for (auto iter = all_nids_in_constraints.begin(); iter != all_nids_in_constraints.end(); iter++) {
        int curr_nid = *iter;

        if (written_nids.find(curr_nid) != written_nids.end())
            continue;

        string node_var = "__node_" + IntToString(curr_nid);
 
        z3::expr expr_with_value_1 = c.bv_val(1, NODE_BOUND_BIT_LENGTH(graph));
        z3::expr expr_with_value_0 = c.bv_val(0, NODE_BOUND_BIT_LENGTH(graph));

        to_ADD = to_ADD + z3::to_expr(c, Z3_mk_ite(c, all_z3_var_to_expr_map.at(node_var), expr_with_value_1, expr_with_value_0));

    }
    
    s.add (ule(to_ADD, all_z3_var_to_expr_map.at(node_bound_var)));
    
}


void GraphManagerNew::get_total_edges_lt_bound_constraints_with_z3(z3::context& c, z3::solver& s, map<string, z3::expr>& all_z3_var_to_expr_map, GraphNew * graph, set<int>& eids_to_consider) {

    z3::expr to_ADD = c.bv_val(0, EDGE_BOUND_BIT_LENGTH(graph));
    
    string edge_bound_var = "__edgebound";
    static set<int> written_eids;

    int edge_bound_value = graph->get_edge_ids().size();
    z3::expr edge_bound_value_expr = c.bv_val(edge_bound_value, EDGE_BOUND_BIT_LENGTH(graph));
    s.add (ule(all_z3_var_to_expr_map.at(edge_bound_var), edge_bound_value_expr));
    
    
    for (auto iter = eids_to_consider.begin(); iter != eids_to_consider.end(); iter++) {
        int curr_eid = *iter;

        if (written_eids.find(curr_eid) != written_eids.end())
            continue;

        string edge_var = "__edge_" + IntToString(curr_eid);

        z3::expr expr_with_value_1 = c.bv_val(1, EDGE_BOUND_BIT_LENGTH(graph));
        z3::expr expr_with_value_0 = c.bv_val(0, EDGE_BOUND_BIT_LENGTH(graph));
        
        to_ADD = to_ADD + z3::to_expr(c, Z3_mk_ite(c, all_z3_var_to_expr_map.at(edge_var), expr_with_value_1, expr_with_value_0));
        
    }
    
    s.add (ule(to_ADD, all_z3_var_to_expr_map.at(edge_bound_var)));
    
}

void GraphManagerNew::get_solution_z3(z3::context& c, z3::solver& s, map<string, z3::expr>& all_z3_var_to_expr_map, GraphNew * graph, list<pair<int,int> >& node_edge_pairs, int up_reg_down_reg_size) {
    int node_relax_bound = 1;
    z3::expr expr_n = c.bv_val(node_relax_bound, NODE_RELAX_BOUND_BIT_LENGTH(up_reg_down_reg_size));
    //s.push();
    s.add(ule(all_z3_var_to_expr_map.at("__nodestatusrelaxbound"), expr_n));
    cout << "node relax: " << node_relax_bound << endl;
    
//    s.push();
    int i = 0;
    z3::expr expr_i = c.bv_val(i, EDGE_RELAX_BOUND_BIT_LENGTH(graph));
    s.add(ule(all_z3_var_to_expr_map.at("__edgestatusrelaxbound"), expr_i));
    cout << "edge relax: " << i << endl;
    
    z3::check_result is_sat;
//    s.pop();
    

    /********* Commented out by Supratik: Nov 19, 2019 
     ********* This is needed only for debugging purposes  */

    string smtfile = "getSolutionZ3_smtfile.smt2";
    ofstream smt_out(smtfile.c_str());
    smt_out << s.to_smt2() << endl;
    smt_out.close();

    /**********/
                
                
    time_t time1, time2;
    double time_in_sec;
    time(&time1);
    is_sat = s.check();
    time(&time2);
    time_in_sec = difftime(time2, time1);
    
    cout << "OUTCOME: " << is_sat << endl;
        
    cout << "Time taken (sec): " << time_in_sec << endl;

    
//    node_relax_bound = 0;
//    expr_n = c.bv_val(node_relax_bound, NODE_RELAX_BOUND_BIT_LENGTH);
//    
//    //s.add(ule(all_z3_var_to_expr_map.at("__nodestatusrelaxbound"), expr_n));
//    cout << "node relax: " << node_relax_bound << endl;
//    
//    s.push();
//    i = 10;
//    expr_i = c.bv_val(i, EDGE_RELAX_BOUND_BIT_LENGTH);
//    s.add(ule(all_z3_var_to_expr_map.at("__edgestatusrelaxbound"), expr_i));
//    cout << "edge relax: " << i << endl;
//    
//    
//    is_sat = s.check();
//    cout << is_sat << endl;
//    s.pop();
}

void GraphManagerNew::get_PO_curve (z3::context& c, z3::solver& s, map<string, z3::expr>& all_z3_var_to_expr_map, GraphNew * graph, int node_relax_bound_lower_limit, int node_relax_bound_upper_limit, int edge_relax_bound_lower_limit, int edge_relax_bound_upper_limit, list<pair<int,int> >& node_edge_pairs, int up_reg_down_reg_size) {
    int num_of_nodes = graph->get_node_ids().size();
    int node_relax_bound = node_relax_bound_lower_limit;
    int max_node_relax_bound = (1<<NODE_RELAX_BOUND_BIT_LENGTH(up_reg_down_reg_size))- 1;
    int edge_relax_bound = edge_relax_bound_upper_limit;
        
    bool obtained_first_PO_point = false;
    
    string smtfile = "timefile.txt";
    ofstream fout(smtfile.c_str());
       
    string PO_points_file = "PO.dat";
    ofstream POout(PO_points_file.c_str());
    
    // string PO_points_txt_file = "PO.txt";
    // ofstream PO_txtout(PO_points_txt_file.c_str());
   
    
    while (edge_relax_bound > edge_relax_bound_lower_limit && node_relax_bound <= node_relax_bound_upper_limit) {
        z3::expr expr_n = c.bv_val(node_relax_bound, NODE_RELAX_BOUND_BIT_LENGTH(up_reg_down_reg_size));
        s.push();
        s.add(ule(all_z3_var_to_expr_map.at("__nodestatusrelaxbound"), expr_n));
        fout << endl;
        fout << "node relax: " << node_relax_bound << endl;
        cout << "Node relax bound: " << node_relax_bound << endl;
        int min_edges_relax = binary_search_for_exact_bound_with_z3(c, s, all_z3_var_to_expr_map, graph, fout, edge_relax_bound, edge_relax_bound_lower_limit, edge_relax_bound_upper_limit, obtained_first_PO_point);
        s.pop();
        
        
        if (min_edges_relax < 0) {
            cerr << "No valid edge relax value found in binary search with node relax bound " << node_relax_bound << endl;
            
            if (node_relax_bound == max_node_relax_bound) {
                cout << "Reached max node relax bound for bit width " << NODE_RELAX_BOUND_BIT_LENGTH(up_reg_down_reg_size) << endl;
                break;
            }
            
        } 
        else {
            pair<int,int> curr_node_edge_pair = make_pair(node_relax_bound, min_edges_relax);
            cout << "(" << node_relax_bound << "," << min_edges_relax << ")" << endl;
            POout << node_relax_bound << "\t" << min_edges_relax << endl;
            // PO_txtout << "(" << node_relax_bound << "," << min_edges_relax << ")" << endl;
            fout << "(" << node_relax_bound << "," << min_edges_relax << ")" << endl;
            node_edge_pairs.push_back(curr_node_edge_pair);
            obtained_first_PO_point = true;
        }
        
        
        if (min_edges_relax > 0) {
            edge_relax_bound = min_edges_relax;
        }
        node_relax_bound++;
        
    }
    POout.close();
    // PO_txtout.close();
    fout.close();
}



void GraphManagerNew::solve_mincut_constraints_with_z3(z3::context& c, z3::solver& s, map<string, z3::expr>& all_z3_var_to_expr_map, GraphNew * graph, string file_prefix, int binary_search_nodes_bound) {    
    //int smallest_value = binary_search_for_exact_bound_with_z3(c, s, all_z3_var_to_expr_map, graph);

}

int GraphManagerNew::binary_search_for_exact_bound_with_z3(z3::context& c, z3::solver& s, map<string, z3::expr>& all_z3_var_to_expr_map, GraphNew * graph, ofstream& fout, int prev_edge_relax_bound, int edge_relax_bound_lower_limit, int edge_relax_bound_upper_limit, bool obtained_first_PO_point) {
    
    
    int upper_bound_cur = 1;
    int highest_unsat_bound_seen = edge_relax_bound_lower_limit;
    int lowest_sat_bound_seen = prev_edge_relax_bound;
//    int temp_edge_relax_bound = prev_edge_relax_bound + 1;
    
    vector <sat_state_t> status(prev_edge_relax_bound - edge_relax_bound_lower_limit + 1);
    std::fill(status.begin(), status.end(), UNDEFINED);
    sat_state_t flag = UNSAT;
    z3::check_result is_sat;
    
    bool timeout_at_max_edges = false;
    
    if (!obtained_first_PO_point) {
        for (int i = edge_relax_bound_lower_limit; (i <= prev_edge_relax_bound) && (flag == UNSAT);) {
            assert (i>=edge_relax_bound_lower_limit);
            
            cout << "i " << i << endl;
            fout << "i " << i << endl;
            
            if (status.at(i - edge_relax_bound_lower_limit) == TIMEOUT) {
                is_sat = z3::unknown;
            }
            else if (status.at(i - edge_relax_bound_lower_limit) == SAT) {
                is_sat = z3::sat;
            }
            else if (status.at(i - edge_relax_bound_lower_limit) == UNSAT) {
                is_sat = z3::unsat;
            }
            else {
                z3::expr expr_i = c.bv_val(i, EDGE_RELAX_BOUND_BIT_LENGTH(graph));
                s.push();
                s.add(ule(all_z3_var_to_expr_map.at("__edgestatusrelaxbound"), expr_i));
                fout << "edge relax: " << i << endl;
                cout << " Edge relax bound: " << i;
                time_t time1, time2;
                double time_in_sec;
                time(&time1);
                is_sat = s.check();
                time(&time2);
                time_in_sec = difftime(time2, time1);

                fout << "OUTCOME: " << is_sat << endl;
                cout << "OUTCOME: " << is_sat << endl;

                fout << "Time taken (sec): " << time_in_sec << endl;

                s.pop();
            }

            fout << is_sat << endl;
            cout << "  " << is_sat << endl;

            if (is_sat == z3::unsat) {
                highest_unsat_bound_seen = i;
                status.at(i - edge_relax_bound_lower_limit) = UNSAT;

                if (i < prev_edge_relax_bound) {
                    i = (edge_relax_bound_lower_limit - 1 + 2 * (i - edge_relax_bound_lower_limit + 1) <= prev_edge_relax_bound) ? (edge_relax_bound_lower_limit - 1 + 2 * (i - edge_relax_bound_lower_limit + 1)) : prev_edge_relax_bound;                
                }
                else 
                    break; // breaks out of loop with flag UNSAT
            }
            else if (is_sat == z3::sat) {
                lowest_sat_bound_seen = i;
                status.at(i - edge_relax_bound_lower_limit) = SAT;
                flag = SAT; // breaks out of loop with flag SAT
            }
            else {
                status.at(i - edge_relax_bound_lower_limit) = TIMEOUT;
                if (i < prev_edge_relax_bound) {
                    if (!timeout_at_max_edges) 
                        i = i + 1; 
                    else {
                        if (i-1 >= highest_unsat_bound_seen)
                            i = i - 1;
                        else 
                            return -1; // status has number of unsats followed by all timeouts                       
                    }
                }
                else { // i == prev_edge_relax_bound
                    timeout_at_max_edges = true;
                    for (; (i >= highest_unsat_bound_seen) && (status.at(i - edge_relax_bound_lower_limit) == TIMEOUT); i--) // find the largest i such that status.at(i-1) is undefined followed by all timeouts, or timeouts all throughout the array
                        ;
                    if ((i < highest_unsat_bound_seen) || (status.at(i - edge_relax_bound_lower_limit) == UNSAT)){
                        return -1; // status has number of unsats followed by all timeouts, or timeouts all throughout the array   
                    }
                }    

            }
        }
    }
    else {
        flag = SAT;
    }
    
    
    if (flag == UNSAT) {
        fout << "Returning -2" << endl;
        return -2; // whole range is unsat
    }
    else { // search between highest_unsat_bound_seen and lowest_sat_bound_seen
        // flag must be sat here. Therefore status.at(lowest_sat_bound_seen - edge_relax_bound_lower_limit) == SAT
        
        assert (flag == SAT);
        //assert (status.at(lowest_sat_bound_seen - edge_relax_bound_lower_limit) == SAT);
        //assert ( (status.at(highest_unsat_bound_seen - edge_relax_bound_lower_limit) == UNSAT) || (status.at(highest_unsat_bound_seen - edge_relax_bound_lower_limit) == TIMEOUT) );
        
        
        int i = (highest_unsat_bound_seen + lowest_sat_bound_seen) / 2;
        
        timeout_at_max_edges = false;
        
//        bool loop_condition = ((status.at(highest_unsat_bound_seen - edge_relax_bound_lower_limit) == UNSAT) && 
//                            (highest_unsat_bound_seen < lowest_sat_bound_seen - 1))
//                            ||
//                            (((status.at(highest_unsat_bound_seen - edge_relax_bound_lower_limit) != UNSAT) ||
//                            (highest_unsat_bound_seen <= lowest_sat_bound_seen - 1));
        
        while ((highest_unsat_bound_seen < lowest_sat_bound_seen - 1)) {
          
            cout << "inside binary search" << endl;
            fout << "inside binary search" << endl;
            
            cout << "i " << i << endl;
            fout << "i " << i << endl;
            
            if (status.at(i - edge_relax_bound_lower_limit) == TIMEOUT) {
                is_sat = z3::unknown;
            }
            else if (status.at(i - edge_relax_bound_lower_limit) == SAT) {
                is_sat = z3::sat;
            }
            else if (status.at(i - edge_relax_bound_lower_limit) == UNSAT) {
                is_sat = z3::unsat;
            }
            else {
                z3::expr expr_i = c.bv_val(i, EDGE_RELAX_BOUND_BIT_LENGTH(graph));
                s.push();
                s.add(ule(all_z3_var_to_expr_map.at("__edgestatusrelaxbound"), expr_i));
                fout << "edge relax: " << i << endl;
                cout << " Edge relax bound: " << i;
                time_t time3, time4;
                double time_in_sec2;
                time(&time3);
                is_sat = s.check();                
                time(&time4);
                time_in_sec2 = difftime(time4, time3);
                

                fout << "OUTCOME: " << is_sat << endl;
                cout << "OUTCOME: " << is_sat << endl;
     
                fout << "Time taken (sec): " << time_in_sec2 << endl;
                           
                s.pop();
                        
            }
            fout << is_sat << endl;
            cout << "  " << is_sat << endl;
            
            if (is_sat == z3::unsat) {
                highest_unsat_bound_seen = i;
                status.at(i - edge_relax_bound_lower_limit) = UNSAT;
                if (highest_unsat_bound_seen == lowest_sat_bound_seen)
                    return -1;
                
                i = (highest_unsat_bound_seen + lowest_sat_bound_seen) / 2;
            }
            else if (is_sat == z3::sat) {
                lowest_sat_bound_seen = i;
                status.at(i - edge_relax_bound_lower_limit) = SAT;
                i = (highest_unsat_bound_seen + lowest_sat_bound_seen) / 2;
                timeout_at_max_edges = false;
            }
            else {
                status.at(i - edge_relax_bound_lower_limit) = TIMEOUT;
                if (i < lowest_sat_bound_seen) {
                    if (!timeout_at_max_edges) 
                        i = i + 1; 
                    else {
                        if (i >= highest_unsat_bound_seen)
                            i = i - 1;
                        else 
                            return -1; // status has number of unsats followed by all timeouts , or timeouts all throughout the array                      
                    }
                }
                else { // i == lowest_sat_bound_seen
                    timeout_at_max_edges = true;
                    for (; (i >= highest_unsat_bound_seen) && (status.at(i - edge_relax_bound_lower_limit) == TIMEOUT); i--) // find the largest i such that status.at(i-1) is undefined followed by all timeouts, or timeouts all throughout the array
                        ;
                    if ((i < highest_unsat_bound_seen) || (status.at(i - edge_relax_bound_lower_limit) == UNSAT)){
                        return -1; // status has number of unsats followed by all timeouts, or timeouts all throughout the array    
                    }
                }    

            }
            
//            loop_condition = ((status.at(highest_unsat_bound_seen - edge_relax_bound_lower_limit) == UNSAT) && 
//                            (highest_unsat_bound_seen < lowest_sat_bound_seen - 1))
//                            ||
//                            (((status.at(highest_unsat_bound_seen - edge_relax_bound_lower_limit) != UNSAT) ||
//                            (highest_unsat_bound_seen <= lowest_sat_bound_seen - 1));
        }
        
    }
    
    if (lowest_sat_bound_seen != highest_unsat_bound_seen) {
        assert (lowest_sat_bound_seen == highest_unsat_bound_seen + 1);
    }
    
    return lowest_sat_bound_seen;
}

void GraphManagerNew::get_PO_curve_within_limits(z3::context& c, z3::solver& s, map<string, z3::expr>& expr_map, GraphNew * graph, int eu_user, int nl_user, int el_user, int nu_user, list<pair<int,int> >& PO_value_pairs, ofstream& fout) {
 
    
    
}
    

void GraphManagerNew::get_PO_points_within_limits(z3::context& c, z3::solver& s, map<string, z3::expr>& expr_map, GraphNew * graph, int y, int z, int eu, int nl, int el, int nu, vector<pair<int,int> >& PO_value_pairs, ofstream& fout, int call_type, int up_reg_down_reg_size) {//, vector<vector <sat_state_t> >& sat_state_matrix) {


    static vector< vector<sat_state_t> > sat_state_matrix(y+1, vector<sat_state_t>(z+1, sat_state_t::UNDEFINED));

    if (call_type == 0) { // Need to reset sat_state_matrix if a fresh call (not a recursive call) to the
                          // function has been made (this implies call_type == 0)
      vector< vector<sat_state_t> > temp_sat_state_matrix(y+1, vector<sat_state_t>(z+1, sat_state_t::UNDEFINED));
      sat_state_matrix = temp_sat_state_matrix;
    }
    
    fout << endl;
    fout << "new call with node relax in [" << nl << ", " << nu << "] and edge relax in [" << el << ", " << eu << "] of type " << call_type << endl;

    if ((nu < nl) || (eu < el)) {
        fout << "Invalid window: Quitting search" << endl;
        return;
    }
    
    
    PO_point_result_tuple *result;
    
    
    // Step 1
    
    
    int N_h = nu;
    int N_l = nl;
    int E_h = eu;
    int E_l = el;
    
    int curr_n = -1;
    int curr_e = -1;
    
    z3::check_result is_sat;
    
    bool seen_sat_along_diagonal = false;
    bool seen_non_sat_along_diagonal = false;
    
    int first_sat_n = -1, first_sat_e = -1;
    
    do {
      int curr_n1 = (N_l + N_h) / 2;
      int curr_e1 = (E_l + E_h) / 2;

      if ((curr_n1 == curr_n) && (curr_e1 == curr_e)) {
	// This can happen only if N_h \in {N_l, N_l + 1} and E_h \in {E_l, E_l + 1},
	// and (curr_n, curr_e) = (N_l, E_l)
	// This is because (i) (curr_n, curr_e) is either supposed to be (-1,-1), in
	// which case the condition in the if statement can't be satisfied, or 
	// (ii) curr_n is supposed to be one of the end-points of [N_l, N_h] and
	// curr_e is supposed to be one of the end-points of [E_l, E_h].
	// In case (ii), sat_state_matrix[E_l, N_l] is expected to have either a
	// sat, unsat or timeout value.

	assert((N_h <= N_l+1) && (E_h <= E_l+1));
	assert ((curr_n == N_l) && (curr_e == E_l));

	// find next "higher" point along diagonal
	curr_n1 = next_along_diagonal(curr_n, N_h); // (curr_n + 1 <= N_h)? curr_n + 1 : N_h;
	curr_e1 = next_along_diagonal(curr_e, E_h); // (curr_e + 1 <= E_h)? curr_e + 1 : E_h;
	if ((curr_n1 == curr_n) && (curr_e1 == curr_e)) {
	  break; // 
	}
      }
      else {
	curr_n = curr_n1;
	curr_e = curr_e1;
      }
      
      if (sat_state_matrix.at(curr_e).at(curr_n) == sat_state_t::SAT) {
	fout << "Point " << curr_e << " " << curr_n << "already sat" << endl;
	is_sat = z3::sat;
      }
      else if (sat_state_matrix.at(curr_e).at(curr_n) == sat_state_t::UNSAT){
	fout << "Point " << curr_e << " " << curr_n << " already unsat" << endl;
	is_sat = z3::unsat;
      }
      else {
	
	z3::expr expr_curr_n = c.bv_val(curr_n, NODE_RELAX_BOUND_BIT_LENGTH(up_reg_down_reg_size));
	z3::expr expr_curr_e = c.bv_val(curr_e, EDGE_RELAX_BOUND_BIT_LENGTH(graph));
	s.push();
	// s.add(ule(expr_map.at("__nodestatusrelaxbound"), expr_curr_n));
	// s.add(ule(expr_map.at("__edgestatusrelaxbound"), expr_curr_e));
	s.add(ule(expr_map.at("__nodestatusrelaxbound"), expr_curr_n));
	s.add(ule(expr_map.at("__edgestatusrelaxbound"), expr_curr_e));
	fout << "Relax bounds: " << curr_e << " " << curr_n << endl;

	/********* Commented out by Supratik: Nov 19, 2019 
	 ********* This is needed only for debugging purposes */

	string smt_file = "PO_constraints_nr_";
	smt_file += (to_string(curr_n) + "_er_" + to_string(curr_e) + ".smt2");
	ofstream smt_out(smt_file.c_str());
	smt_out << s.to_smt2() << endl;
	smt_out.close();

	/**********/
        
	clock_t t;        
	t = clock();
	is_sat = s.check();
	t = clock() - t;
	fout << "Time taken (sec): " << ((float)t)/CLOCKS_PER_SEC << endl;
	s.pop();
        
	if (is_sat == z3::sat) {
	  sat_state_matrix.at(curr_e).at(curr_n) = sat_state_t::SAT;   
	}
	else if (is_sat == z3::unsat) {
	  sat_state_matrix.at(curr_e).at(curr_n) = sat_state_t::UNSAT;
	}
      }
      
      fout << is_sat << endl;
      
      
      if (is_sat == z3::sat) {
	seen_sat_along_diagonal = true;
	first_sat_n = curr_n;
	first_sat_e = curr_e;
	N_h = prev_along_diagonal(curr_n, N_l);
	E_h = prev_along_diagonal(curr_e, E_l);
	
	fout <<  "N_h: " <<  N_h << " E_h: " << E_h << endl;
        
      }
      else {
	seen_non_sat_along_diagonal = true;
	N_l = next_along_diagonal(curr_n, N_h);
	E_l = next_along_diagonal(curr_e, E_h);
	
	fout << "N_l: " <<  N_l << " E_l: " << E_l << endl;
      }
      
    } while(1);
    
    if (!seen_sat_along_diagonal) {
      result = new PO_point_result_tuple(0, -1, -1, -1, -1);
    }
    else {
      int nd = first_sat_n;
      int ed = first_sat_e;

      if ((nl == nu) || (el == eu)) {
	// The window is a straight line or a point.
	// So we can save a few SAT calls and directly
        // obtain the relevant PO point.
	
	if (sat_state_matrix.at(ed).at(nd) == sat_state_t::SAT) {
	  result = new PO_point_result_tuple(1, ed, nd, -1, -1);
	}
	else {
	  assert(false); // Should never come here
	}
      }
      else { // Step 2

        pair<int, int> soln_lower;
        pair<int, int> soln_upper;
        
	// Finding smallest n within box such that (ed, n) is sat
	fout << endl;
	fout << "Finding smallest n" << endl;
	N_h = nd;
	N_l = nl;

	z3::expr expr_ed = c.bv_val(ed, EDGE_RELAX_BOUND_BIT_LENGTH(graph));
	s.push();
	s.add(ule(expr_map.at("__edgestatusrelaxbound"), expr_ed));

	while (N_h > N_l) { // Loop invariant: (ed, N_h) always has a sat solution
	  curr_n = (N_h + N_l) / 2; // Note that curr_n must be < N_h, since N_h > N_l
          
	  if (sat_state_matrix.at(ed).at(curr_n) == sat_state_t::SAT) {
	    fout << "Point " << ed << " " << curr_n << " already sat" << endl;
	    is_sat = z3::sat;
	  }
	  else if (sat_state_matrix.at(ed).at(curr_n) == sat_state_t::UNSAT) {
	    fout << "Point " << ed << " " << curr_n << " already unsat" << endl;
	    is_sat = z3::unsat;
	  }
	  else {
	    z3::expr expr_curr_n = c.bv_val(curr_n, NODE_RELAX_BOUND_BIT_LENGTH(up_reg_down_reg_size));            
	    s.push();
	    s.add(ule(expr_map.at("__nodestatusrelaxbound"), expr_curr_n));            
	    fout << "Relax bounds (node call): " << ed << " " << curr_n << endl;

	    /********* Commented out by Supratik: Nov 19, 2019 
	     ********* This is needed only for debugging purposes */

	    string smt_file1 = "PO_constraints_nr_";
	    smt_file1 += (to_string(curr_n) + "_er_" + to_string(ed) + ".smt2");
	    ofstream smt_out1(smt_file1.c_str());
	    smt_out1 << s.to_smt2() << endl;
	    smt_out1.close();

	    /**********/
	    
	    clock_t t1 = clock();
	    is_sat = s.check();
	    t1 = clock() - t1;
	    fout << "Time taken (sec): " << ((float)t1)/CLOCKS_PER_SEC << endl;
	    s.pop();
            
	    if (is_sat == z3::sat) {
	      sat_state_matrix.at(ed).at(curr_n) = sat_state_t::SAT;
	    }
	    else if (is_sat == z3::unsat) {
	      sat_state_matrix.at(ed).at(curr_n) = sat_state_t::UNSAT;
	    }
            
	  }
          
	  fout << is_sat << endl; // --

	  if (is_sat == z3::sat) {
	    N_h = curr_n;
	  }
	  else {
	    if (N_l == curr_n)
	      break;
	    N_l = curr_n;
	  }            
	  fout <<  "N_h: " <<  N_h << " N_l: " << N_l << endl;
          
	}
	s.pop();
	
	soln_lower = make_pair(ed, N_h);
	fout << "Soln lower " << ed << " " << N_h << endl;
	
	// Finding smallest e within box such that (e, nd) is sat
	fout << endl;
	fout << "Finding smallest e" << endl;
	E_h = ed;
	E_l = el;
        
	z3::expr expr_nd = c.bv_val(nd, NODE_RELAX_BOUND_BIT_LENGTH(up_reg_down_reg_size));
	s.push();
	s.add(ule(expr_map.at("__nodestatusrelaxbound"), expr_nd));
        
	while (E_h > E_l) { // Loop invariant: (nd, E_h) always has a sat solution
	  curr_e = (E_h + E_l) / 2; // Note that curr_e must be < E_h, since E_h > E_l
          
	  if (sat_state_matrix.at(curr_e).at(nd) == sat_state_t::SAT) {
	    fout << "Point " << curr_e << " " << nd << " already sat" << endl;
	    is_sat = z3::sat;
	  }            
	  else if (sat_state_matrix.at(curr_e).at(nd) == sat_state_t::UNSAT){
	    fout << "Point " << curr_e << " " << nd << " already unsat" << endl;
	    is_sat = z3::unsat;
	  }
	  else {
	    z3::expr expr_curr_e = c.bv_val(curr_e, EDGE_RELAX_BOUND_BIT_LENGTH(graph));
	    s.push();
	    s.add(ule(expr_map.at("__edgestatusrelaxbound"), expr_curr_e));
	    fout << "Relax bounds (edge call): " << curr_e << " " << nd << endl;

	    /********* Commented out by Supratik: Nov 19, 2019 
	     ********* This is needed only for debugging purposes */

	    string smt_file2 = "PO_constraints_nr_";
	    smt_file2 += (to_string(nd) + "_er_" + to_string(curr_e) + ".smt2");
	    ofstream smt_out2(smt_file2.c_str());
	    smt_out2 << s.to_smt2() << endl;
	    smt_out2.close();

	    /**********/
	    
	    clock_t t1 = clock();
	    is_sat = s.check();
	    t1 = clock() - t1;
	    fout << "Time taken (sec): " << ((float)t1)/CLOCKS_PER_SEC << endl;
	    s.pop();
            
            
	    if (is_sat == z3::sat) {
	      sat_state_matrix.at(curr_e).at(nd) = sat_state_t::SAT;
	    }
	    else if (is_sat == z3::unsat) {
	      sat_state_matrix.at(curr_e).at(nd) = sat_state_t::UNSAT;
	    }
	  }
	  
	  fout << is_sat << endl;
          
	  if (is_sat == z3::sat) {
	    E_h = curr_e;
	  }
	  else {
	    if (E_l == curr_e)
	      break;
	    E_l = curr_e;
	  }
	  fout <<  "E_h: " <<  E_h << " E_l: " << E_l << endl;            
        }        
        s.pop();
        
        soln_upper = make_pair(E_h, nd);
        fout << "Soln upper " << E_h << " " << nd << endl;
        
	if ((soln_upper.first != soln_lower.first) && (soln_upper.second != soln_lower.second)) {
	  result = new PO_point_result_tuple(2, ed, N_h, E_h, nd);
	}
	else {
	  result = new PO_point_result_tuple(1, E_h, N_h, -1, -1);
	}
      }
    
    
      if (result->num_of_points == 0) {
	fout << "Zero solutions found!!!" << endl;
	return;
      }
      
      if (result->num_of_points == 1) {
        fout << "One soln in window (" << eu << ", " << nl << ", " << el << ", " << nu << ")" << endl;
        fout << "Point 1: (" << result->e1 << ", " << result->n1 << ")" << endl;
        cout << "(" << result->e1 << ", " << result->n1 << ")" << endl;
        PO_value_pairs.push_back(make_pair(result->e1, result->n1));
      }
      else if (result->num_of_points == 2) {
        fout << "Two solns in window (" << eu << ", " << nl << ", " << el << ", " << nu << ")" << endl;
        fout << "Point 1: (" << result->e1 << ", " << result->n1 << ")" << endl;
        fout << "Point 2: (" << result->e2 << ", " << result->n2 << ")" << endl;
        PO_value_pairs.push_back(make_pair(result->e1, result->n1));
        PO_value_pairs.push_back(make_pair(result->e2, result->n2));
        
        cout << "(" << result->e1 << ", " << result->n1 << ")" << endl;
        cout << "(" << result->e2 << ", " << result->n2 << ")" << endl;
      }
      
      get_PO_points_within_limits(c, s, expr_map, graph, y, z, E_h-1, nd + 1, el, nu, PO_value_pairs, fout, 1, up_reg_down_reg_size);
      get_PO_points_within_limits(c, s, expr_map, graph, y, z, eu, nl, ed + 1, N_h - 1, PO_value_pairs, fout, 2, up_reg_down_reg_size);
      
      return;
    }
}


bool GraphManagerNew::is_sat_at_existing_PO_points(z3::context& c, z3::solver& s, map<string, z3::expr>&expr_map, GraphNew * graph, vector<pair<int,int> >&PO_value_pairs, int up_reg_down_reg_size) {

	vector<pair<int, int> >::iterator i = PO_value_pairs.begin();
	while (i != PO_value_pairs.end()) {
		int curr_e = i->first;
		int curr_n = i->second;
		z3::expr expr_edge_relax = c.bv_val(curr_e, EDGE_RELAX_BOUND_BIT_LENGTH(graph));
		z3::expr expr_node_relax = c.bv_val(curr_n, NODE_RELAX_BOUND_BIT_LENGTH(up_reg_down_reg_size));

		s.push();
		s.add(ule(expr_map.at("__edgestatusrelaxbound"), expr_edge_relax));
		s.add(ule(expr_map.at("__nodestatusrelaxbound"), expr_node_relax));

		cout << "Pair (e,n): " << curr_e << " " << curr_n << endl;
		clock_t t1 = clock();
		z3::check_result is_sat = s.check();
		t1 = clock() - t1;
		cout << "Time taken (sec): " << ((float)t1)/CLOCKS_PER_SEC << endl;

		s.pop();


		if (is_sat == z3::sat) {
			cout << "Sat at node relax " << curr_n << " edge relax " << curr_e << endl;
			return true;
		}
		else if (is_sat == z3::unsat) {
			cout << "Unsat at node relax " << curr_n << " edge relax " << curr_e << endl;
			continue;
		}
		else {
			continue;
		}

		i++;

	}

	return false;
}

bool GraphManagerNew::recursive_DFS_to_detect_backedges(GraphNew *graph, int s, set<int>& visited_nids, map<int, bool>& recursion_stack, set<int>& back_edges) {
    if (visited_nids.find(s) == visited_nids.end()) {
        visited_nids.insert(s);
        recursion_stack[s] = true;

        vector<int> edge_list = graph->get_outlist(s);
        for (auto edge_iter = edge_list.begin(); edge_iter != edge_list.end(); edge_iter++) {
            int curr_edge = *edge_iter;
            int curr_target_nid = graph->get_target_node(curr_edge);
            
            if (recursion_stack[curr_target_nid]) {
                back_edges.insert(curr_edge);
                return true;
            }
            
            else if ((visited_nids.find(curr_target_nid) == visited_nids.end()) && (recursive_DFS_to_detect_backedges(graph, curr_target_nid, visited_nids, recursion_stack, back_edges))) {
                return true;
            }                
//            else if (recursion_stack[curr_target_nid]) {
//                back_edges.insert(curr_edge);
//                return true;
//            }
        }
    }
    recursion_stack[s] = false;
    return false;
    
}
   


void GraphManagerNew::DFS_to_detect_backedges(GraphNew * graph, int s, set<int>& back_edges) {
    set<int> visited_nids; 
    map<int, bool> recursion_stack;
    
    vector<int> nids = graph->get_node_ids();
    for (auto nids_iter = nids.begin(); nids_iter != nids.end(); nids_iter++) {
        int curr_nid = *nids_iter;
        recursion_stack.insert(pair<int, bool>(curr_nid, false));
    }
    
    recursive_DFS_to_detect_backedges(graph, s, visited_nids, recursion_stack, back_edges);    
     
}


int GraphManagerNew::compute_unrolled_DAG(int original_graphnum, int source_nid, int target_nid, int unrolling_levels, std::map<int, std::vector<int> >& map_nid_to_unrolled_graph_nids, std::map<int, std::vector<int> >& map_eid_to_unrolled_graph_eids) {
    
    GraphNew * original_graph = get_graph(original_graphnum);
    if (original_graph == NULL) {
        cerr << "Error: there is no graph for id " << original_graphnum << endl;
        return -1;
    }
    
    //new id for the new graph
    GraphNew* new_graph = new GraphNew;
    int new_gid = ++GraphManagerNew::graph_id_count;
    new_graph->set_graph_id(new_gid);
    add_graph(new_gid, new_graph);

    vector<int> nids = original_graph->get_node_ids();
    vector<int> eids = original_graph->get_edge_ids();
    set<int> back_edges_eids;    
    set<int> visited_nids;
    
    map<int, int> map_nid_to_dfs_index;
    
    
    
    // get all back edges in graph
    DFS_to_detect_backedges(original_graph, source_nid, back_edges_eids);
    
    
//    dfs_numbering(graph, source_nid, map_nid_to_dfs_index);
//    
//    for (auto edge_iter = eids.begin(); edge_iter != eids.end(); edge_iter++) {
//        int curr_edge_eid = *edge_iter;
//        int curr_src_nid = graph->get_source_node(curr_edge_eid);
//        int curr_tgt_nid = graph->get_target_node(curr_edge_eid);
//        if (map_nid_to_dfs_index[curr_src_nid] > map_nid_to_dfs_index[curr_tgt_nid]) {
//            back_edges_eids.insert(curr_edge_eid);
//        }
//    }
    
    cout << "No. of backedges: " << back_edges_eids.size() << endl;
        
    
    
//    // map from a node (nid_n) in graph to all copies of node n (nid_n1, nid_n2, ..., nid_nk) in new_graph
//    mpa<int, vector<int> > map_nid_to_copies;
    
    for (int level = 0; level <= unrolling_levels; level++) {
        // create new node at current level for all original nodes in graph
        for (auto node_iter = nids.begin(); node_iter != nids.end(); node_iter++) {
            int curr_node_nid = *node_iter;
            int new_node_nid = new_graph->create_new_node();
            if (new_node_nid == -1) {
                cerr << "Problem creating new node in unrolled graph" << endl;
                return -1;
            }
            new_graph->add_node_id(new_node_nid);

            string curr_node_rep_id = original_graph->get_rep_id_from_nid(curr_node_nid);
            string new_node_rep_id = curr_node_rep_id + "_" + to_string(level); // rep_id of node at current level
            new_graph->add_description_for_node(new_node_nid, curr_node_rep_id); // store original rep-id with level in the description field of class NodeNew
            new_graph->add_rep_id_for_node(new_node_nid, new_node_rep_id);
            
            this->add_node_id_graph_id(new_node_nid, new_gid);
            new_graph->add_id_for_node(new_node_nid, new_node_rep_id);
            new_graph->add_id_rep_id(new_node_rep_id, new_node_rep_id);
            new_graph->add_id_rep_id(curr_node_rep_id, new_node_rep_id);
            new_graph->add_node_type(new_node_nid, original_graph->get_node_type(curr_node_nid));
            new_graph->add_display_id_for_node(new_node_nid, kegg_hsa_id_to_display_name_map[curr_node_rep_id]);
        
            // map to keep track of nids of original graph to its copies in the unrolled graph
            if (map_nid_to_unrolled_graph_nids.find(curr_node_nid) == map_nid_to_unrolled_graph_nids.end()) {
                vector<int> new_nid_vector;
                new_nid_vector.push_back(new_node_nid);
                map_nid_to_unrolled_graph_nids.insert(pair<int, vector<int> >(curr_node_nid, new_nid_vector));
            }
            else {
                map_nid_to_unrolled_graph_nids[curr_node_nid].push_back(new_node_nid);
            }
        }
        
        
        // create new edge at current level for all original edges except the back edges
        for (auto edge_iter = eids.begin(); edge_iter != eids.end(); edge_iter++) {
            int curr_edge_eid = *edge_iter;
            int curr_src_nid = original_graph->get_source_node(curr_edge_eid);
            int curr_tgt_nid = original_graph->get_target_node(curr_edge_eid);
            // if not a back edge
            if (back_edges_eids.find(curr_edge_eid) == back_edges_eids.end()) {
                
                // get source node in new graph at current level
                string src_rep_id_in_orig_graph = original_graph->get_rep_id_from_nid(curr_src_nid);
                string src_rep_id_in_new_graph = src_rep_id_in_orig_graph + "_" + level;
                int src_nid_in_new_graph = new_graph->get_nid_from_rep_id(src_rep_id_in_new_graph);
                if (src_nid_in_new_graph == -1) {
                    cerr << "Problem retrieving source node for edge while creating unrolled graph" << endl;
                    return -1;
                }
                
                // get target node in new graph at current level
                string tgt_rep_id_in_orig_graph = original_graph->get_rep_id_from_nid(curr_tgt_nid);
                string tgt_rep_id_in_new_graph = tgt_rep_id_in_orig_graph + "_" + level;
                int tgt_nid_in_new_graph = new_graph->get_nid_from_rep_id(tgt_rep_id_in_new_graph);
                if (tgt_nid_in_new_graph == -1) {
                    cerr << "Problem retrieving target node for edge while creating unrolled graph" << endl;
                    return -1;
                }
                
                // create edge between these source and target nodes
                int new_edge_eid = new_graph->create_new_edge();
                if (new_edge_eid == -1) {
                    cerr << "Problem creating new edge in unrolled graph" << endl;
                    return -1;
                }
                new_graph->add_edge_id(new_edge_eid);
                add_edge_id_graph_id(new_edge_eid, new_gid);
                new_graph->add_edge_type(new_edge_eid, original_graph->get_edge_type(curr_edge_eid));
                new_graph->add_edge_to_outlist_of_node(src_nid_in_new_graph, new_edge_eid);
                new_graph->add_edge_to_inlist_of_node(tgt_nid_in_new_graph, new_edge_eid);
                new_graph->add_source_node(new_edge_eid, src_nid_in_new_graph);
                new_graph->add_target_node(new_edge_eid, tgt_nid_in_new_graph);
                     
                // map to keep track of nids of original graph to its copies in the unrolled graph
                if (map_eid_to_unrolled_graph_eids.find(curr_edge_eid) == map_eid_to_unrolled_graph_eids.end()) {
                    vector<int> new_eid_vector;
                    new_eid_vector.push_back(new_edge_eid);
                    map_eid_to_unrolled_graph_eids.insert(pair<int, vector<int> >(curr_edge_eid, new_eid_vector));
                }
                else {
                    map_eid_to_unrolled_graph_eids[curr_edge_eid].push_back(new_edge_eid);
                } 
                
            }
            else { // is a back edge
                if (level > 0) { // not the first level of unrolling
                    
                    // get source node nid in unrolled graph
                    int nid_of_src_in_orig_graph = original_graph->get_source_node(curr_edge_eid);
                    string rep_id_of_src_in_orig_graph = original_graph->get_rep_id_from_nid(nid_of_src_in_orig_graph);
                    string rep_id_of_src_in_new_graph = rep_id_of_src_in_orig_graph + "_" + toString(level - 1); // source node is at previous level of unrolling
                    int nid_of_src_in_new_graph = new_graph->get_nid_from_rep_id(rep_id_of_src_in_new_graph);
                    if (nid_of_src_in_new_graph == -1) {
                        cerr << "Source node not created in unrolled graph. Cannot create edge across levels" << endl;
                        return -1;
                    }
                    
                    // get target node nid in unrolled graph
                    int nid_of_tgt_in_orig_graph = original_graph->get_target_node(curr_edge_eid);
                    string rep_id_of_tgt_in_orig_graph = original_graph->get_rep_id_from_nid(nid_of_tgt_in_orig_graph);
                    string rep_id_of_tgt_in_new_graph = rep_id_of_tgt_in_orig_graph + "_" + toString(level); // target node is at current level of unrolling
                    int nid_of_tgt_in_new_graph = new_graph->get_nid_from_rep_id(rep_id_of_tgt_in_new_graph);
                    if (nid_of_tgt_in_new_graph == -1) {
                        cerr << "Target node not created in unrolled graph. Cannot create edge across levels" << endl;
                        return -1;
                    }
                    
                    // create edge across levels
                    int new_edge_eid = new_graph->create_new_edge();
                    if (new_edge_eid == -1) {
                        cerr << "Problem creating new edge across levels in unrolled graph" << endl;
                        return -1;
                    }
                    new_graph->add_edge_id(new_edge_eid);
                    add_edge_id_graph_id(new_edge_eid, new_gid);
                    new_graph->add_edge_type(new_edge_eid, original_graph->get_edge_type(curr_edge_eid));
                    new_graph->add_edge_to_outlist_of_node(nid_of_src_in_new_graph, new_edge_eid);
                    new_graph->add_edge_to_inlist_of_node(nid_of_tgt_in_new_graph, new_edge_eid);
                    new_graph->add_source_node(new_edge_eid, nid_of_src_in_new_graph);
                    new_graph->add_target_node(new_edge_eid, nid_of_tgt_in_new_graph);
                    
                    
                    // map to keep track of nids of original graph to its copies in the unrolled graph
                    if (map_eid_to_unrolled_graph_eids.find(curr_edge_eid) == map_eid_to_unrolled_graph_eids.end()) {
                        vector<int> new_eid_vector;
                        new_eid_vector.push_back(new_edge_eid);
                        map_eid_to_unrolled_graph_eids.insert(pair<int, vector<int> >(curr_edge_eid, new_eid_vector));
                    }
                    else {
                        map_eid_to_unrolled_graph_eids[curr_edge_eid].push_back(new_edge_eid);
                    } 
                    
                    
                }
                
            }
            
            
            
            
        }
        
        
    }
    

    
    
    
    
    
    
    // create node t*
    int curr_node_nid = target_nid;
    int t_star_node_nid = new_graph->create_new_node();
    if (t_star_node_nid == -1) {
        cerr << "Problem creating t_star node in unrolled graph" << endl;
        return -1;
    }
    new_graph->add_node_id(t_star_node_nid);

    string curr_node_rep_id = original_graph->get_rep_id_from_nid(curr_node_nid);
    string t_star_node_rep_id = curr_node_rep_id;
    new_graph->add_rep_id_for_node(t_star_node_nid, t_star_node_rep_id);
    new_graph->add_description_for_node(t_star_node_nid, curr_node_rep_id); // store original in the description field of class NodeNew

    this->add_node_id_graph_id(t_star_node_nid, new_gid);
    new_graph->add_id_for_node(t_star_node_nid, t_star_node_rep_id);
    new_graph->add_id_rep_id(t_star_node_rep_id, t_star_node_rep_id);
    new_graph->add_id_rep_id(curr_node_rep_id, t_star_node_rep_id);
    new_graph->add_node_type(t_star_node_nid, original_graph->get_node_type(curr_node_nid));
    new_graph->add_display_id_for_node(t_star_node_nid, kegg_hsa_id_to_display_name_map[curr_node_rep_id]);

    

    // create edges from all targets to t_star node
    vector<int> all_copies_of_target_nids = map_nid_to_unrolled_graph_nids[target_nid];
    for (auto t_iter = all_copies_of_target_nids.begin(); t_iter != all_copies_of_target_nids.end(); t_iter++) {
        int curr_target_nid = *t_iter;
        // create edge to t_star node
        int new_edge_eid = new_graph->create_new_edge();
        if (new_edge_eid == -1) {
            cerr << "Problem creating edge to t_star node unrolled graph" << endl;
            return -1;
        }
        new_graph->add_edge_id(new_edge_eid);
        add_edge_id_graph_id(new_edge_eid, new_gid);
        new_graph->add_edge_type(new_edge_eid, "dummy");
        new_graph->add_edge_to_outlist_of_node(curr_target_nid, new_edge_eid);
        new_graph->add_edge_to_inlist_of_node(t_star_node_nid, new_edge_eid);
        new_graph->add_source_node(new_edge_eid, curr_target_nid);
        new_graph->add_target_node(new_edge_eid, t_star_node_nid);
    }


    return new_gid;
    
    
}


void GraphManagerNew::count_paths_through_vertex(GraphNew * unrolled_graph, int source_nid, int target_nid, int path_length, vector<vector<int> >& PathsVertices, vector<vector<int> >& PathsEdges) {
        
    vector<int> unrolled_graph_nids = unrolled_graph->get_node_ids();
    vector<int> unrolled_graph_eids = unrolled_graph->get_edge_ids();
    int unrolled_num_of_nodes = unrolled_graph_nids.size();
    int unrolled_num_of_edges = unrolled_graph_eids.size();
    
    vector<vector<int> > PathsS(unrolled_num_of_nodes, vector<int>(path_length + 1, 0));
    vector<vector<int> > PathsT(unrolled_num_of_nodes, vector<int>(path_length + 1, 0));
    
    
//    for (auto nid_iter = nids.begin(); nid_iter != nids.end(); nid_iter++) {
//        int curr_nid = *nid_iter;
//        int curr_nseq = GET_NODE_SEQ_NUM(graph, curr_nid);
//        
//        for (int k = 0; k <= path_length; k++) {
//            PathsS[curr_nseq][k] = 0;
//            PathsT[curr_nseq][k] = 0;
//            PathsVertices[curr_nseq][k] = 0;            
//        }
//       
//    }
//    for (auto eid_iter = eids.begin(); eid_iter != eids.end(); eid_iter++) {
//        int curr_eid = *eid_iter;
//        int curr_eseq = GET_EDGE_SEQ_NUM(graph, curr_eid);
//        
//        for (int k = 0; k <= path_length; k++) {
//            
//            PathsEdges[curr_eseq][k] = 0;
//        }
//    }
    
    
    int source_nseq = GET_NODE_SEQ_NUM(unrolled_graph, source_nid);
    int target_nseq = GET_NODE_SEQ_NUM(unrolled_graph, target_nid);
    PathsS[source_nseq][0] = 1;
    PathsT[target_nseq][0] = 1;
    
    
    vector<int> topologically_sorted_nids;
    
    topologically_sort_nids_using_dfs(unrolled_graph, source_nid, topologically_sorted_nids, FORWARD);
    //topologically_sort_nids_using_bfs(graph, source_nid, topologically_sorted_nids, FORWARD);
    cout << "Forward topological sort done" << endl;
    
        
    assert (unrolled_num_of_nodes == topologically_sorted_nids.size());
    
    int ii = 1;
    for (auto i = topologically_sorted_nids.begin(); i != topologically_sorted_nids.end(); i++) {
        cout << ii << " " << unrolled_graph->get_rep_id_from_nid(*i) << endl;
        ii++;
    }
    
    
    for (auto i = topologically_sorted_nids.begin(); i != topologically_sorted_nids.end(); i++) {
        
        int curr_tgt_nid = *i;
        
        if (curr_tgt_nid == source_nid)
            continue;
        
        int curr_tgt_nseq = GET_NODE_SEQ_NUM(unrolled_graph, curr_tgt_nid);
        vector<int> inlist = unrolled_graph->get_inlist(curr_tgt_nid);
        for (auto inlist_iter = inlist.begin(); inlist_iter != inlist.end(); inlist_iter++) {
            int curr_in_edge = *inlist_iter;
            int curr_src_nid = unrolled_graph->get_source_node(curr_in_edge);            
            int curr_src_nseq = GET_NODE_SEQ_NUM(unrolled_graph, curr_src_nid);
            for (int k = 1; k <= path_length; k++) {
                
                PathsS[curr_tgt_nseq][k] = PathsS[curr_tgt_nseq][k] + PathsS[curr_src_nseq][k-1];
                
            }
            
        }
        
    }
    

    
    
    
//    cout << "PathsS calculated" << endl;
//    for (int x = 0; x < PathsS.size(); x++) {
//        for (int y = 0; y < PathsS[x].size(); y++) {
//            cout << "PathsS " << x << " " << y << " " << PathsS[x][y] << endl;
//        }
//    }
    
    
    topologically_sorted_nids.clear();
    topologically_sort_nids_using_dfs(unrolled_graph, target_nid, topologically_sorted_nids, BACKWARD);
    //topologically_sort_nids_using_bfs(graph, target_nid, topologically_sorted_nids, BACKWARD);
    cout << "Backward topological sort done" << endl;

    
    ii = 1;
    for (auto i = topologically_sorted_nids.begin(); i != topologically_sorted_nids.end(); i++) {
        cout << ii << " " << unrolled_graph->get_rep_id_from_nid(*i) << endl;
        ii++;
    }
    
    
    for (auto i = topologically_sorted_nids.begin(); i != topologically_sorted_nids.end(); i++) {
        int curr_src_nid = *i;
        
        if (curr_src_nid == target_nid)
            continue;
        
        int curr_src_nseq = GET_NODE_SEQ_NUM(unrolled_graph, curr_src_nid);
        vector<int> outlist = unrolled_graph->get_outlist(curr_src_nid);
        for (auto outlist_iter = outlist.begin(); outlist_iter != outlist.end(); outlist_iter++) {
            int curr_out_edge = *outlist_iter;
            int curr_tgt_nid = unrolled_graph->get_target_node(curr_out_edge);
            int curr_tgt_nseq = GET_NODE_SEQ_NUM(unrolled_graph, curr_tgt_nid);
            for (int k = 1; k <= path_length; k++) {
                
                PathsT[curr_src_nseq][k] = PathsT[curr_src_nseq][k] + PathsT[curr_tgt_nseq][k-1];
                
            }
            
        }
        
    }
    
//    cout << "PathsT calculated" << endl;
//    for (int x = 0; x < PathsT.size(); x++) {
//        for (int y = 0; y < PathsT[x].size(); y++) {
//            cout << "PathsT " << x << " " << y << " " << PathsT[x][y] << endl;
//        }
//    }
    for (auto nids_iter = unrolled_graph_nids.begin(); nids_iter != unrolled_graph_nids.end(); nids_iter++) {
        int curr_nid = *nids_iter;
        int curr_nseq = GET_NODE_SEQ_NUM(unrolled_graph, curr_nid);
        for (int k = 0; k <= path_length; k++) {
            for (int l = 0; l <= k; l++) {
                PathsVertices[curr_nseq][k] = PathsVertices[curr_nseq][k] + (PathsS[curr_nseq][l] * PathsT[curr_nseq][k - l]);                
            }            
        }
    }
//    cout << "PathsVertices calculated" << endl;
//    for (int x = 0; x < PathsVertices.size(); x++) {
//        for (int y = 0; y < PathsVertices[x].size(); y++) {
//            cout << "PathsVertices " << x << " " << y << " " << PathsVertices[x][y] << endl;
//        }
//    }
    
    
    cout << "PathsVertices calculated" << endl;
    
    for (auto eids_iter = unrolled_graph_eids.begin(); eids_iter != unrolled_graph_eids.end(); eids_iter++) {
        int curr_eid = *eids_iter;
        int curr_eseq = GET_EDGE_SEQ_NUM(unrolled_graph, curr_eid);
        int curr_src_nseq = GET_NODE_SEQ_NUM(unrolled_graph, unrolled_graph->get_source_node(curr_eid));
        int curr_tgt_nseq = GET_NODE_SEQ_NUM(unrolled_graph, unrolled_graph->get_target_node(curr_eid));
        for (int k = 0; k <= path_length; k++) {
            for (int l = 0; l < k; l++) {
                PathsEdges[curr_eseq][k] = PathsEdges[curr_eseq][k] + (PathsS[curr_src_nseq][l] * PathsT[curr_tgt_nseq][k - l - 1]);
            }
            
        }
    }
    
//    cout << "PathsEdges calculated" << endl;
//    for (int x = 0; x < PathsEdges.size(); x++) {
//        for (int y = 0; y < PathsEdges[x].size(); y++) {
//            cout << "PathsEdges " << x << " " << y << " " << PathsEdges[x][y] << endl;
//        }
//    }
    
    cout << "PathsEdges calculated" << endl;
    
}



void GraphManagerNew::recursive_topological_sort(GraphNew * graph, int curr_nid, set<int>& visited, list<int>& stack, int direction) {
    
    visited.insert(curr_nid);
    vector<int> edgelist;
    
    if (direction == FORWARD)     
        edgelist = graph->get_outlist(curr_nid);
    else if (direction == BACKWARD)
        edgelist = graph->get_inlist(curr_nid);
    
    for (auto edge_iter = edgelist.begin(); edge_iter != edgelist.end(); edge_iter++)  {
        
        int curr_edge = *edge_iter;
        int curr_adj_nid;
        if (direction == FORWARD)
            curr_adj_nid = graph->get_target_node(curr_edge);
        else if (direction == BACKWARD)
            curr_adj_nid = graph->get_source_node(curr_edge);
            
        if (visited.find(curr_adj_nid) == visited.end()) {
            recursive_topological_sort(graph, curr_adj_nid, visited, stack, direction);
        }
    }   
    
    stack.push_front(curr_nid);
}


void GraphManagerNew::topologically_sort_nids_using_dfs(GraphNew * graph, int source_nid, vector<int>& topologically_sorted_nids, int direction) {
    
    vector<int> nids = graph->get_node_ids();
    
    list<int> stack;
    set<int> visited;
    
    for (auto nid_iter = nids.begin(); nid_iter != nids.end(); nid_iter++) {
        int curr_nid = *nid_iter;
        if (visited.find(curr_nid) == visited.end()) {
            recursive_topological_sort(graph, curr_nid, visited, stack, direction);
        }        
    }
    
//    if (visited.find(source_nid) == visited.end()) {
//        recursive_topological_sort(graph, source_nid, visited, stack, direction);
//    }        
    
    
    
    while (!stack.empty()) {
        topologically_sorted_nids.push_back(stack.front());
        stack.pop_front();
    }
    
}


void GraphManagerNew::topologically_sort_nids_using_bfs(GraphNew * graph, int source_nid, vector<int>& topologically_sorted_nids, int direction) {
    
    vector<int> nids = graph->get_node_ids();
    
    list<int> queue;
    set<int> visited;
    vector<int> edgelist;
    
    
    queue.push_back(source_nid);
    //topologically_sorted_nids.push_back(source_nid);
    
    while (!queue.empty()) {
        int curr_nid = queue.front();
        
        if (visited.find(curr_nid) == visited.end()) {
            topologically_sorted_nids.push_back(curr_nid);
        }
        
        
        visited.insert(curr_nid);
        
        
        
        queue.pop_front();
        
        if (direction == FORWARD)     
            edgelist = graph->get_outlist(curr_nid);
        else if (direction == BACKWARD)
            edgelist = graph->get_inlist(curr_nid);
    
        for (auto edge_iter = edgelist.begin(); edge_iter != edgelist.end(); edge_iter++)  {

            int curr_edge = *edge_iter;
            int curr_adj_nid;
            if (direction == FORWARD)
                curr_adj_nid = graph->get_target_node(curr_edge);
            else if (direction == BACKWARD)
                curr_adj_nid = graph->get_source_node(curr_edge);

            if (visited.find(curr_adj_nid) == visited.end()) {
                queue.push_back(curr_adj_nid);
                
            }
        }   
    
    }
        
    
    
}



void GraphManagerNew::print_nodes_ranked_by_fraction_of_paths(string file_prefix, GraphNew * original_graph, GraphNew * unrolled_graph, int source_nid, int target_nid, int path_length, int& total_paths, vector<vector<int> >& PathsVertices, vector<vector<int> >& PathsEdges, std::map<int, std::vector<int> >& map_nid_to_unrolled_graph_nids) {
    map<int, int> vec_orig_nid_to_paths;
    vector<pair<int, double> > vec_of_pairs_nid_to_fraction;
    
    vector<int> original_nids = original_graph->get_node_ids();
    vector<int> unrolled_nids = unrolled_graph->get_node_ids();
    
    string histo_file = file_prefix + "_histogram_nodes";
    ofstream hout(histo_file.c_str());
    
    
    hout << "Source: " << original_graph->get_rep_id_from_nid(source_nid) << endl;
    hout << "target: " << original_graph->get_rep_id_from_nid(target_nid) << endl;
    
    
    int paths_thru_src = 0;
    int paths_thru_tgt = 0;
    
    for (auto nid_iter = original_nids.begin(); nid_iter != original_nids.end(); nid_iter++) {
        int curr_nid = *nid_iter;
        int curr_unrolled_nseq;
        hout << "node" << "\t" << original_graph->get_rep_id_from_nid(curr_nid) << endl;
        cout << "node" << "\t" << original_graph->get_rep_id_from_nid(curr_nid) << endl;
        for (auto iter = map_nid_to_unrolled_graph_nids.begin(); iter != map_nid_to_unrolled_graph_nids.end(); iter++) {
            int original_curr_nid = iter->first;
            
            
            vector<int> unrolled_nids_of_curr_node = iter->second;
            
            int num_of_paths = 0;
            for (auto i=unrolled_nids_of_curr_node.begin(); i != unrolled_nids_of_curr_node.end(); i++) {
                
                int curr_unrolled_nid = *i;
                curr_unrolled_nseq = GET_NODE_SEQ_NUM(unrolled_graph, curr_unrolled_nid);
                
                for (int k = 0; k <= path_length; k++) {
                    num_of_paths = num_of_paths + PathsVertices[curr_unrolled_nseq][k];
                }
                
            }
            vec_orig_nid_to_paths[original_curr_nid] = num_of_paths;
            
            if (original_curr_nid == source_nid) {
                paths_thru_src = num_of_paths;
            }
            if (original_curr_nid == target_nid) {
                paths_thru_tgt = num_of_paths;
            }
        }        
        hout << endl;
        for (int k = 0; k <= path_length; k++) {
            int count_at_k = 0;
            vector<int> corresponding_unrolled_nids = map_nid_to_unrolled_graph_nids[curr_nid];
            for (auto n = corresponding_unrolled_nids.begin(); n != corresponding_unrolled_nids.end(); n++) {
                int nseq = GET_NODE_SEQ_NUM(unrolled_graph, *n);

                    count_at_k = count_at_k + PathsVertices[nseq][k];

                
            }     
            hout << "has " << count_at_k << " paths " << " of length " << k <<  endl;
            cout << "has " << count_at_k << " paths " << " of length " << k <<  endl;
        }
        cout << endl;
    }
    
//    int paths_thru_src = vec_orig_nid_to_paths[source_nid];
//    int paths_thru_tgt = vec_orig_nid_to_paths[target_nid];
    cout << "paths_thru_src: " << paths_thru_src << endl;
    cout << "paths_thru_tgt: " << paths_thru_tgt << endl;
    assert (paths_thru_src == paths_thru_tgt);
    assert (paths_thru_src > 0);
    total_paths = paths_thru_src;
    
    for (auto nid_iter = original_nids.begin(); nid_iter != original_nids.end(); nid_iter++) {
        int curr_nid = *nid_iter;
        int num_of_paths = vec_orig_nid_to_paths[curr_nid];
        cout << "No. of paths through " << original_graph->get_rep_id_from_nid(curr_nid) << " is " << num_of_paths << endl;
        double fraction = (((double)num_of_paths / (double)paths_thru_src) * 100);
        vec_of_pairs_nid_to_fraction.push_back(make_pair(curr_nid, fraction));
    }
    
    sort(vec_of_pairs_nid_to_fraction.begin(), vec_of_pairs_nid_to_fraction.end(), compare_pair_on_second_descending_int_double);
    
    string ranked_nodes_filename = file_prefix + "_nodes_ranked_by_path_freq";
    ofstream fout(ranked_nodes_filename.c_str());
    
    int rank = 1;
    for (auto vec_iter = vec_of_pairs_nid_to_fraction.begin(); vec_iter != vec_of_pairs_nid_to_fraction.end(); vec_iter++) {
        int curr_nid = vec_iter->first;
        double fraction = vec_iter->second;
        
        string curr_repid = original_graph->get_rep_id_from_nid(curr_nid);
        string curr_display_name = kegg_hsa_id_to_display_name_map[curr_repid];
        if (curr_display_name == "")
            curr_display_name = curr_repid;
        fout << rank << "\t" << fraction << "\t" << curr_repid << "\t" << curr_display_name << "\t" << endl;
        rank++;
    }
    
    fout.close();
}



void GraphManagerNew::print_edges_ranked_by_fraction_of_paths(string file_prefix, GraphNew * original_graph, GraphNew * unrolled_graph, int source_nid, int target_nid, int path_length, int& total_paths, vector<vector<int> >& PathsVertices, vector<vector<int> >& PathsEdges, std::map<int, std::vector<int> >& map_eid_to_unrolled_graph_eids) {
    map<int, int> vec_orig_eid_to_paths;
    vector<pair<int, double> > vec_of_pairs_eid_to_fraction;
    
    string histo_file = file_prefix + "_histogram_edges";
    ofstream hout(histo_file.c_str());
    
    vector<int> original_eids = original_graph->get_edge_ids();
    vector<int> unrolled_eids = unrolled_graph->get_edge_ids();
    
    for (auto eid_iter = original_eids.begin(); eid_iter != original_eids.end(); eid_iter++) {
        int curr_eid = *eid_iter;
        int curr_unrolled_eseq;
        cout << "node" << "\t" << original_graph->get_rep_id_from_nid(original_graph->get_source_node(curr_eid)) << "\t" << original_graph->get_rep_id_from_nid(original_graph->get_target_node(curr_eid)) << endl;
        for (auto iter=map_eid_to_unrolled_graph_eids.begin(); iter != map_eid_to_unrolled_graph_eids.end(); iter++) {
            int original_curr_eid = iter->first;
            vector<int> unrolled_eids_of_curr_edge = iter->second;
             
            int num_of_paths = 0;
            for (auto i = unrolled_eids_of_curr_edge.begin(); i != unrolled_eids_of_curr_edge.end(); i++) {
                int curr_unrolled_eid = *i;
                curr_unrolled_eseq = GET_EDGE_SEQ_NUM(unrolled_graph, curr_unrolled_eid);
                
                for (int k = 0; k <= path_length; k++) {
                    num_of_paths = num_of_paths + PathsEdges[curr_unrolled_eseq][k];
                }
            }
            
            vec_orig_eid_to_paths[original_curr_eid] = num_of_paths;
            
        }
        
        for (int k = 0; k <= path_length; k++) {
            int count_at_k = 0;
            vector<int> corresponding_unrolled_eids = map_eid_to_unrolled_graph_eids[curr_eid];
            for (auto e = corresponding_unrolled_eids.begin(); e != corresponding_unrolled_eids.end(); e++) {
                int eseq = GET_EDGE_SEQ_NUM(unrolled_graph, *e);

                    count_at_k = count_at_k + PathsEdges[eseq][k];
                
            }     
            hout << "has " << count_at_k << " paths " << " of length " << k <<  endl;
            cout << "has " << count_at_k << " paths " << " of length " << k <<  endl;
        }
        cout << endl;
        
        
    }
        
    for (auto eid_iter = original_eids.begin(); eid_iter != original_eids.end(); eid_iter++) {
        int curr_eid = *eid_iter;
        int num_of_paths = vec_orig_eid_to_paths[curr_eid];
        cout << "No. of paths through " << original_graph->get_rep_id_from_nid(original_graph->get_source_node(curr_eid)) << " - " << original_graph->get_rep_id_from_nid(original_graph->get_target_node(curr_eid)) << " is " << num_of_paths << endl;
        double fraction = (((double)num_of_paths / (double)total_paths) * 100);
        vec_of_pairs_eid_to_fraction.push_back(make_pair(curr_eid, fraction));
    }
    
    sort(vec_of_pairs_eid_to_fraction.begin(), vec_of_pairs_eid_to_fraction.end(), compare_pair_on_second_descending_int_double);
    
    string ranked_edges_filename = file_prefix + "_edges_ranked_by_path_freq";
    ofstream fout(ranked_edges_filename.c_str());
    
    int rank = 1;
    for (auto vec_iter = vec_of_pairs_eid_to_fraction.begin(); vec_iter != vec_of_pairs_eid_to_fraction.end(); vec_iter++) {
        int curr_eid = vec_iter->first;
        double fraction = vec_iter->second;
        
        
        int curr_src = original_graph->get_source_node(curr_eid);
        int curr_tgt = original_graph->get_target_node(curr_eid);
        
        string curr_src_repid = original_graph->get_description_for_node(curr_src);
        string curr_src_display_name = kegg_hsa_id_to_display_name_map[curr_src_repid];
        if (curr_src_display_name == "")
            curr_src_display_name = curr_src_repid;
        
        string curr_tgt_repid = original_graph->get_description_for_node(curr_tgt);
        string curr_tgt_display_name = kegg_hsa_id_to_display_name_map[curr_tgt_repid];
        if (curr_tgt_display_name == "")
            curr_tgt_display_name = curr_tgt_repid;
        
        vector<string> all_edge_types = original_graph->get_edge_subtypes_of_edge(curr_eid);
        string edge_type = concatenate_strings2(all_edge_types, "_");
        
        
        fout << rank << "\t" << fraction << "\t" << curr_src_repid << "\t" << curr_src_display_name << "\t" << curr_tgt_repid << "\t" << curr_tgt_display_name << "\t" << edge_type << endl;
        rank++;
    }
    
    fout.close();
}





void GraphNew::get_nids_ranked_by_degree(vector< pair<int, int> >& vec_degree_to_nid) {
    vector<int> nids = get_node_ids();
   
    for (vector<int>::iterator vec_itr = nids.begin(); vec_itr != nids.end(); vec_itr++) {
        int curr_nid = *vec_itr;
        int degree = 0;

        vector<int> outlist = get_outlist(curr_nid);
        vector<int> inlist = get_inlist(curr_nid);

        for (vector<int>::iterator vec_itr = outlist.begin(); vec_itr != outlist.end(); vec_itr++) {
#ifdef ONLY_INTERAC_EDGES_FOR_MINCUT
            if (!NOT_INTERAC_EDGE(this, *vec_itr))
#endif
                degree++;
        }

        for (vector<int>::iterator vec_itr = inlist.begin(); vec_itr != inlist.end(); vec_itr++) {
#ifdef ONLY_INTERAC_EDGES_FOR_MINCUT
            if (!NOT_INTERAC_EDGE(this, *vec_itr))
#endif
                degree++;
        }

        //int degree = get_inlist(curr_nid).size() + get_outlist(curr_nid).size();
        vec_degree_to_nid.push_back(make_pair(curr_nid, degree));
    }

    sort(vec_degree_to_nid.begin(), vec_degree_to_nid.end(), compare_pair_on_second_descending);

}




void GraphManagerNew::print_nodes_ranked_by_degree(GraphNew * graph, string degree_filename) {
    vector<int> nids = graph->get_node_ids();
 
    vector< pair<int, int> > nid_to_degree_map;
    graph->get_nids_ranked_by_degree(nid_to_degree_map);
            
    list<pair<int, float> > sorted_nid_to_degree_list;
    
    for (auto itr = nid_to_degree_map.begin(); itr != nid_to_degree_map.end(); itr++) {
    
        int key = itr->first;
        float value = itr->second;
        sorted_nid_to_degree_list.push_back(make_pair(key, value));
    }
    
    ofstream fout(degree_filename.c_str());
    
    int rank = 1;
    for (auto l_itr = sorted_nid_to_degree_list.begin(); l_itr != sorted_nid_to_degree_list.end(); l_itr++) {
                
        int nid = l_itr->first;
        
        string name = kegg_hsa_id_to_display_name_map[graph->get_rep_id_from_nid(nid)];
        
        fout << rank << "\t"  << graph->get_rep_id_from_nid(nid) << "\t" <<  name << "\t" << l_itr->second << endl;
        rank++;
    }
    
    fout << endl;
    fout.close();
}



void GraphManagerNew::process_z3_model(GraphNew * graph, map<string, z3::expr>& var_to_expr_map, z3::model& m, vector<int>& present_node_nids, vector<int>& present_edge_eids, vector<int>& active_node_nids, vector<int>& relaxed_node_nids, vector<int>& relaxed_edge_eids, z3::expr& soln_clause) {
    
    
    
    for (unsigned i = 0; i < m.size(); i++) {
        z3::func_decl v = m[i];
        //std::cout << v.name() << " = " << m.get_const_interp(v) << "\n";  

        std::stringstream ss;
        ss << v.name();
        string full_var_name = ss.str().c_str();

        std::size_t start, end;
        start = full_var_name.find("__");
        if (start == std::string::npos)
            continue;

        string var_name = full_var_name.substr(start+2);
        //cout << "Name: " << var_name << endl;

        z3::expr e = m.get_const_interp(v);
        
//        // generate clause from solution
//        if (e.is_bool()) {
//            if ()
//            soln_clause = soln_clause && v;
//        }
        
        std::stringstream tt;
        tt << m.get_const_interp(v);
        string truth_val = tt.str().c_str();

        list<string> tokens;
        split_string_into_list(var_name, "_", tokens);

        string type = tokens.front();

        // generate clause from solution

        
        if (e.is_bool()) {
            
            if ( (type == "connect"))
                ;
            if ( (type == "noderelax") || (type == "edgerelax")  || (type == "node") || (type == "nodeactive") || (type == "edge") ) {
            //if ( (type == "node") || (type == "nodeactive") || (type == "edge") ) {
                if (truth_val == "true")
                    soln_clause = soln_clause && (var_to_expr_map.at(full_var_name));
                else
                    soln_clause = soln_clause && (!var_to_expr_map.at(full_var_name));
            }
        }
        else if (e.is_bv()) {
            if ( (type == "nodestatusrelaxbound") || (type == "edgestatusrelaxbound")  || (type == "nodebound") || (type == "edgebound") || (type == "pathbound")) {
                ;
            }
//            else {
//                soln_clause = soln_clause && (var_to_expr_map.at(full_var_name) == e);
//            }
        }

        
        
        if (type == "node") {

            if (truth_val == "true") { 
                tokens.pop_front();
                int node_nid = stoi(tokens.front());
                present_node_nids.push_back(node_nid);
            }

        }
        else if (type == "nodeactive") {

            if (truth_val == "true") { 
                tokens.pop_front();
                int node_nid = stoi(tokens.front());                                        
                active_node_nids.push_back(node_nid);
            }

        }
        else if (type == "noderelax") {

            if (truth_val == "true") { 
                tokens.pop_front();
                int node_nid = stoi(tokens.front());
                relaxed_node_nids.push_back(node_nid);
            }

        }

        else if (type == "edge") {

            if (truth_val == "true") { 
                tokens.pop_front();
                int edge_eid = stoi(tokens.front());
                present_edge_eids.push_back(edge_eid);
            }

        }

        else if (type == "edgerelax") {

            if (truth_val == "true") {
                tokens.pop_front();
                int edge_eid = stoi(tokens.front());
                relaxed_edge_eids.push_back(edge_eid);


            }

        } 
        
        
    }
    
    
    
    
}



void GraphManagerNew::print_variables_from_z3_model(GraphNew * graph, set<int>& up_reg_nids_to_use, set<int>& down_reg_nids_to_use, vector<int>& present_node_nids, vector<int>& present_edge_eids, vector<int>& active_node_nids, vector<int>& relaxed_node_nids, vector<int>& relaxed_edge_eids, ofstream& soln_out, ofstream&  relax_out) {
    
    
    vector<int> nids = graph->get_node_ids();
    vector<int> eids = graph->get_edge_ids();

    
    for (auto node_iter = nids.begin(); node_iter != nids.end(); node_iter++) {
        int curr_nid = *node_iter;
        
        bool up_reg = false;
        bool down_reg = false;
        bool present = false;
        bool active = false;
        
        string node_expr_status = "NA";
        string node_present_status = "NA";
        string node_activation_status = "NA";

        
        
        if (up_reg_nids_to_use.find(curr_nid) != up_reg_nids_to_use.end()) {
            node_expr_status = "up_reg";
        }
        else if (down_reg_nids_to_use.find(curr_nid) != down_reg_nids_to_use.end()) {
            node_expr_status = "down_reg";
        }
        else {
            node_expr_status = "not_diff_expr";
        }
            
        if (std::find(present_node_nids.begin(), present_node_nids.end(), curr_nid) != present_node_nids.end()) {
            node_present_status = "present";
        }
        else {
            node_present_status = "not_present";
        }
           
                
        if (std::find(active_node_nids.begin(), active_node_nids.end(), curr_nid) != active_node_nids.end()) {
            node_activation_status = "active";
        }
        else {
            node_activation_status = "inactive";
        }
            
        
        
        string hsa_id = graph->get_rep_id_from_nid(curr_nid);
        string disp_name = kegg_hsa_id_to_display_name_map[hsa_id];
        if (disp_name == "")
            disp_name = hsa_id;
	if (node_present_status == "present") { // Changed by Supratik to print only nodes that are present: Oct 12, 2019
	  soln_out << curr_nid << "\t" << hsa_id << "\t" << disp_name << "\t" << node_expr_status << "\t" << node_present_status << "\t" << node_activation_status << endl;
	}

        if (std::find(relaxed_node_nids.begin(), relaxed_node_nids.end(), curr_nid) != relaxed_node_nids.end()) {
            relax_out << curr_nid << "\t" << hsa_id << "\t" << disp_name << "\t" << node_expr_status << "\t" << node_present_status << "\t" << node_activation_status << endl;
        }

    }
     
    soln_out << endl;
    relax_out << endl;

    for (auto edge_iter = eids.begin(); edge_iter != eids.end(); edge_iter++) {
        int curr_eid = *edge_iter;

        string edge_present_status = "NA";
        string edge_relaxation_stuatus = "NA";
        
        int src_nid = graph->get_source_node(curr_eid);
        int tgt_nid = graph->get_target_node(curr_eid);
        
        string src_hsa_id = graph->get_rep_id_from_nid(src_nid);
        string tgt_hsa_id = graph->get_rep_id_from_nid(tgt_nid);
        string src_display_name = kegg_hsa_id_to_display_name_map[src_hsa_id];
        if (src_display_name == "")
            src_display_name = src_hsa_id;
        string tgt_display_name = kegg_hsa_id_to_display_name_map[tgt_hsa_id];
        if (tgt_display_name == "")
            tgt_display_name = tgt_hsa_id;
        
        string src_present_status = "NA";
        string tgt_present_status = "NA";
        string src_activation_status = "NA";
        string tgt_activation_status = "NA";
        
        if (std::find(present_edge_eids.begin(), present_edge_eids.end(), curr_eid) != present_edge_eids.end()) {
            edge_present_status = "present";
        }
        else {
            edge_present_status = "not_present";
        }
        


        // source node present
        if (std::find(present_node_nids.begin(), present_node_nids.end(), src_nid) != present_node_nids.end()) {
            src_present_status = "src_present";
        }
        else {
            src_present_status = "src_not_present";
        }

        // target node present
        if (std::find(present_node_nids.begin(), present_node_nids.end(), tgt_nid) != present_node_nids.end()) {
            tgt_present_status = "tgt_present";
        }
        else {
            tgt_present_status = "tgt_not_present";
        }

        // source node active
        if (std::find(active_node_nids.begin(), active_node_nids.end(), src_nid) != active_node_nids.end()) {
            src_activation_status = "src_active";
        }
        else {
            src_activation_status = "src_inactive";
        }

        // target node active
        if (std::find(active_node_nids.begin(), active_node_nids.end(), tgt_nid) != active_node_nids.end()) {
            tgt_activation_status = "tgt_active";
        }
        else {
            tgt_activation_status = "tgt_inactive";
        }


        vector<string> edge_subtypes = graph->get_edge_subtypes_of_edge(curr_eid);
        string edge_subtypes_str = concatenate_strings2(edge_subtypes, "_");

	// Added facility to print pathways from where edges are taken:
	// Supratik Nov 20, 2019
	
	vector<string> pathways = graph->get_all_pathways_for_edge(curr_eid);
	string concatenated_pathways = concatenate_strings2(pathways, " ");

	if (edge_present_status == "present") { // Changed by Supratik to print only edges that are present: Oct 12, 2019

	  soln_out << curr_eid << "\t" << edge_present_status << "\t" << edge_subtypes_str << "\t" << src_hsa_id << "\t" << src_display_name << "\t" << tgt_hsa_id << "\t" << tgt_display_name <<  "\t" 
		   << src_present_status << "\t" << src_activation_status << "\t" << tgt_present_status << "\t" << tgt_activation_status << " [" << concatenated_pathways << "]" << endl;
	}

        
        if (std::find(relaxed_edge_eids.begin(), relaxed_edge_eids.end(), curr_eid) != relaxed_edge_eids.end()) {
            relax_out << curr_eid << "\t" << edge_present_status << "\t" << edge_subtypes_str << "\t" << src_hsa_id << "\t" << src_display_name << "\t" << tgt_hsa_id << "\t" << tgt_display_name << "\t" 
                << src_present_status << "\t" << src_activation_status << "\t" << tgt_present_status << "\t" << tgt_activation_status << " [" << concatenated_pathways << "]" << endl;
        }
        

    }
    
    
    soln_out << endl;
    soln_out << endl;
    
    relax_out << endl;
    relax_out << endl;
    
}
